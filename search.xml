<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内核相关的思维导图</title>
    <url>/posts/e72cba4c.html</url>
    <content><![CDATA[<p>这里 mark 几张内核相关的思维导图。</p>
<span id="more"></span>

<h2 id="深入浅出linux系统的内存管理和调试"><a href="#深入浅出linux系统的内存管理和调试" class="headerlink" title="深入浅出linux系统的内存管理和调试"></a>深入浅出 linux 系统的内存管理和调试</h2><iframe src="https://www.processon.com/embed/60cd30361efad474365f1cf4" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe>

<h2 id="linux内核动态追踪技术20讲"><a href="#linux内核动态追踪技术20讲" class="headerlink" title="linux内核动态追踪技术20讲"></a>linux 内核动态追踪技术 20 讲</h2><iframe src="https://www.processon.com/embed/6284b55363768936dabbffc1" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe>

<h2 id="linux性能调试和优化"><a href="#linux性能调试和优化" class="headerlink" title="linux性能调试和优化"></a>linux 性能调试和优化</h2><iframe src="https://www.processon.com/embed/62b445eb1e08530756f27e1e" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen=""></iframe>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习笔记</title>
    <url>/posts/21db94ec.html</url>
    <content><![CDATA[<h2 id="修改上次git-commit时间"><a href="#修改上次git-commit时间" class="headerlink" title="修改上次git commit时间"></a>修改上次 git commit 时间</h2><p>命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git commit --amend  --date="commit_time_you_want_change"</span><br></pre></td></tr></tbody></table></figure>

<p>这里需要填写的时间 <code>commit_time_you_want_change</code> 具有特定的格式要求，和 <code>date -R</code> 命令的输出格式保持一致：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ date -R</span><br><span class="line">Tue, 17 May 2022 19:03:12 +0800</span><br></pre></td></tr></tbody></table></figure>

<p>如果想改成当前时间，直接使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git commit --amend --date="$(date -R)"</span><br></pre></td></tr></tbody></table></figure>

<p>如果想改成其他时间，需要按照格式构造时间：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git commit --amend --date="Tue, 17 May 2022 19:03:12 +0800"</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>将 git 信息编译进可执行程序</title>
    <url>/posts/50c08953.html</url>
    <content><![CDATA[<h2 id="脚本build-sh"><a href="#脚本build-sh" class="headerlink" title="脚本build.sh"></a>脚本 build.sh</h2><p>运行 build.sh 脚本会生成最新的头文件，其包含 git 信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">commit_ts=`git log -1 --format="%ct"`</span><br><span class="line">commit_time=`date -d@$commit_ts +"%Y-%m-%d %H:%M:%S"`</span><br><span class="line">current_time=`date +"%Y-%m-%d %H:%M:%S"`</span><br><span class="line">git_version=`git log -1 --format="%h"`</span><br><span class="line">sed  s/MYVERSION/"version: $git_version commit: $commit_time build: $current_time"/g version.h.tmp &gt; version.h</span><br><span class="line">make clean</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure>

<p>将脚本内容保存为 build.sh 每次提交源码之后，直接运行 build.sh 脚本即会生成最新的头文件，该头文件被编译到程序中，可以看到版本信息包含了最新的版本号，提交时间，编译时间。</p>
<h2 id="模版文件version-h-tmp"><a href="#模版文件version-h-tmp" class="headerlink" title="模版文件version.h.tmp"></a>模版文件 version.h.tmp</h2><p>其中有一个模版文件 version.h.tmp，其内容如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#ifndef _VERSION_</span><br><span class="line">#define _VERSION_ "MYVERSION"</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<h2 id="头文件version-h"><a href="#头文件version-h" class="headerlink" title="头文件version.h"></a>头文件 version.h</h2><p>运行 build.sh 之后生成的 version.h 文件类似如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#ifndef _VERSION_</span><br><span class="line">#define _VERSION_ "version: 082472d commit: 2017-07-06 16:35:42 build: 2017-07-11 21:01:31"</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>在源文件中直接使用 <em>VERSION</em> 宏就可以啦，在 git 提交版本的时候应该将 version.h.tmp 模版文件添加到版本控制系统中，而脚本生成的 version.h 由于每次 build 都会变化，可以忽略掉。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>本地 Git 仓库关联多个远程仓库</title>
    <url>/posts/cd5585d8.html</url>
    <content><![CDATA[<p>常规情况下，一个本地仓库关联一个远程仓库，有时候为了在多个远程位置发布源码或进行备份，需要将本地仓库关联多个远程仓库。此时可以通过给已有的远程仓库额外添加一个 URL 地址，使本地仓库 push 的时候，同时推送到两个位置。</p>
<span id="more"></span>

<ol>
<li>查看本地已关联的远程仓库 <code>git remote -v</code></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">origin git@github.com:my-repo:first-git-repo/code.git (fetch)</span><br><span class="line">origin git@github.com:my-repo:first-git-repo/code.git (push)</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>不额外添加远程仓库，只是给现有远程仓库添加额外的 URL</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git remote set-url --add origin git@172.16.xx.xx:/home/second-git-repo/code.git</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>再次查看，发现多了个 push 的远程仓库地址 </li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">origin git@github.com:my-repo:first-git-repo/code.git (fetch)</span><br><span class="line">origin git@github.com:my-repo:first-git-repo/code.git (push)</span><br><span class="line">origin git@172.16.xx.xx:/home/second-git-repo/code.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>实现原理：并没有增加远程仓库的数目，而是给一个远程仓库赋予多个地址，这样每次本地 push 后，同时推送到多个地址。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>本地电脑同时关联 GitHub 和 Gitee</title>
    <url>/posts/1f76836b.html</url>
    <content><![CDATA[<h2 id="清除git全局设置"><a href="#清除git全局设置" class="headerlink" title="清除git全局设置"></a>清除 git 全局设置</h2><p>若之前没有设置过全局的可以跳过这一步，若之前对 git 设置过全局的 user.name 和 user.email，进行过如下操作：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "你的名字"</span><br><span class="line">git config --global user.email  "你的邮箱"</span><br></pre></td></tr></tbody></table></figure>

<p>要先进行清除操作：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git config --global --unset user.name "你的名字"</span><br><span class="line">git config --global --unset user.email "你的邮箱"</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生成GitHub和Gitee独立的-ssh-key"><a href="#生成GitHub和Gitee独立的-ssh-key" class="headerlink" title="生成GitHub和Gitee独立的 ssh key"></a>生成 GitHub 和 Gitee 独立的 ssh key</h2><p>在命令行窗口依次输入下面命令来生成 ssh key，这里要将 <code>name@email.com</code> 改为自己指定的邮箱。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C "name@email.com"</span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C "name@email.com"</span><br></pre></td></tr></tbody></table></figure>

<p>ssh-keygen 命令用于为 “ssh” 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。<br>ssh-keygen  常用参数：</p>
<table>
<thead>
<tr>
<th>-b</th>
<th> 指定密钥长度</th>
</tr>
</thead>
<tbody><tr>
<td> -e</td>
<td> 读取 openssh 的私钥或者公钥文件</td>
</tr>
<tr>
<td> -f</td>
<td> 指定用来保存密钥的文件名</td>
</tr>
<tr>
<td> -t</td>
<td> 指定要创建的密钥类型</td>
</tr>
<tr>
<td> -C</td>
<td> 添加注释</td>
</tr>
</tbody></table>
<p>然后，每次命令需要敲三次回车，就生成 SSH 公钥和私钥：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C "liupaopao520@163.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Passphrases do not match.  Try again.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa.github</span><br><span class="line">Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.github.pub</span><br><span class="line"></span><br><span class="line">Administrator@DESKTOP-4IPRNUP MINGW64 ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C "liupaopao520@163.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa.gitee</span><br><span class="line">Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.gitee.pub</span><br></pre></td></tr></tbody></table></figure>

<p>随后，会在～/.ssh 文件夹下出现 GitHub 和 Gitee 独立的公钥和私钥：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">id_rsa.gitee  id_rsa.gitee.pub  id_rsa.github  id_rsa.github.pub  known_hosts</span><br></pre></td></tr></tbody></table></figure>

<h2 id="将GitHub和Gitee私钥添加到-SSH-agent"><a href="#将GitHub和Gitee私钥添加到-SSH-agent" class="headerlink" title="将GitHub和Gitee私钥添加到 SSH agent"></a>将 GitHub 和 Gitee 私钥添加到 SSH agent</h2><p>因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line"></span><br><span class="line">$ ssh-add ~/.ssh/id_rsa.github</span><br><span class="line">Identity added: /c/Users/Administrator/.ssh/id_rsa.github (liupaopao520@163.com)</span><br><span class="line"></span><br><span class="line">Administrator@DESKTOP-4IPRNUP MINGW64 ~/.ssh</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa.gitee</span><br><span class="line">Identity added: /c/Users/Administrator/.ssh/id_rsa.gitee (liupaopao520@163.com)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="将公钥添加到GitHub和Gitee网站"><a href="#将公钥添加到GitHub和Gitee网站" class="headerlink" title="将公钥添加到GitHub和Gitee网站"></a>将公钥添加到 GitHub 和 Gitee 网站</h2><p>进入 GitHub 网站，点击右上角头像，进入 Settings –&gt; SSH and GPG keys –&gt; SSH keys  –&gt; New SSH keys，填写 Title 并粘贴 id_rsa.github.pub 里的内容。</p>
<p>进入 Gitee 网站，点击右上角头像，进入设置 –&gt; SSH 公钥 –&gt; 添加公钥，填写标题并粘贴 id_rsa.gitee.pub 里的内容。</p>
<h2 id="配置ssh-config文件"><a href="#配置ssh-config文件" class="headerlink" title="配置ssh config文件"></a>配置 ssh config 文件</h2><p>在～/.ssh 文件夹下新建一个 config 文件，里面的内容如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.github</span><br><span class="line"></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa.gitee</span><br></pre></td></tr></tbody></table></figure>

<h2 id="验证是否关联成功"><a href="#验证是否关联成功" class="headerlink" title="验证是否关联成功"></a>验证是否关联成功</h2><p>打开 git bash，依次输入下面命令，验证是否关联成功。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></tbody></table></figure>

<p>当看到信息 “You’ve successfully authenticated……”，则说明已成功关联 GitHub 和 Gitee。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi HanxuLiu! You've successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line">$ ssh -T git@gitee.com</span><br><span class="line">Hi 刘跑跑! You've successfully authenticated, but GITEE.COM does not provide shell access.</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 windows 下 git 不显示中文问题</title>
    <url>/posts/b6c75ca.html</url>
    <content><![CDATA[<p>windows 使用 git bash 时，中文会显示编码方式，看着很不人性化：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202303101032331.png" alt="image-20230310103203251"></p>
<p>可以修改成中文正常显示，步骤如下：</p>
<span id="more"></span>

<ul>
<li>（1）右击窗口上方，进入 Options–&gt;Text 界面，设置 zh_CN 中文编码方式：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202303101026580.png" alt="image-20230310102606682"></p>
<ul>
<li>（2）在命令行执行命令：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></tbody></table></figure>



<p>然后就能正常显示中文了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202303101036656.png" alt="image-20230310103634568"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统后重新关联 GitHub</title>
    <url>/posts/df1ca536.html</url>
    <content><![CDATA[<p>重装系统后， 系统盘文件都会被清空，会删除 .ssh 目录下绑定好的 ssh 公钥和私钥，此时 git push 本地仓库，便会报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></tbody></table></figure>

<p>对此，需要本地重新关联 GitHub 账号，才能继续 push 本地仓库。</p>
<h2 id="本地创建-ssh-key"><a href="#本地创建-ssh-key" class="headerlink" title="本地创建 ssh key"></a>本地创建 ssh key</h2><p>在命令行窗口输入 <code>ssh-keygen -t rsa -C "your_email@youremail.com"</code>，这里要将 <code>your_email@youremail.com</code> 改为自己指定的邮箱。然后，敲三次回车，就生成了 ssh key。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "liupaopao520@163.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa</span><br><span class="line">Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:v9WQpeyCOJKOJG2vKrCbFfKnIo7tbFnZ4Qnp8LVSU2E liupaopao520@163.com</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|        E.       |</span><br><span class="line">|       ..        |</span><br><span class="line">|     . .      .  |</span><br><span class="line">|  . o =    . +   |</span><br><span class="line">|*Oo* . .   +     |</span><br><span class="line">|OBB.o     .      |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></tbody></table></figure>

<p>生成的 ssh key 文件位于 <code>C:\Users\Administrator\.ssh</code> 目录下，打开 id_rsa.pub，复制里面的公钥。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/c/Users/Administrator/.ssh</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br><span class="line"></span><br><span class="line">$ cat id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDEy......l8xl8s8VEc= liupaopao520@163.com</span><br></pre></td></tr></tbody></table></figure>

<h2 id="GitHub添加ssh-key"><a href="#GitHub添加ssh-key" class="headerlink" title="GitHub添加ssh key"></a>GitHub 添加 ssh key</h2><p>进入 GitHub 网站，进入 Account Settings，左边选择 SSH and GPG keys，然后在 SSH keys 分类里，点击 New SSH keys，Title 随便填，粘贴刚才复制的 Key。</p>
<p>打开 git bash，输入 <code>ssh -T git@github.com</code>，验证是否关联成功。看到如下信息，则说明已成功关联 GitHub。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi HanxuLiu! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse+CDT 配置 Linux 平台 C、C++ 开发环境</title>
    <url>/posts/77d5779c.html</url>
    <content><![CDATA[<p>Eclipse 开发集成环境常用来开发 Java 项目，如果想通过 eclipse 进行 C、C++ 开发，就需要安装 eclipse 插件 <a href="https://projects.eclipse.org/projects/tools.cdt">CDT(C/C++ Development Tooling)</a>。</p>
<span id="more"></span>

<h3 id="下载CDT插件"><a href="#下载CDT插件" class="headerlink" title="下载CDT插件"></a>下载 CDT 插件</h3><p>根据自己的 eclipse 版本，下载对应的 CDT 插件版本：</p>
<p><a href="https://github.com/eclipse-cdt/cdt/blob/main/Downloads.md">https://github.com/eclipse-cdt/cdt/blob/main/Downloads.md</a></p>
<h3 id="安装CDT插件"><a href="#安装CDT插件" class="headerlink" title="安装CDT插件"></a>安装 CDT 插件</h3><p>菜单栏 help –&gt; install new software</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211062028028.png" alt="image-20221106202812901"></p>
<p>把解析出来的插件内容全部勾选，然后下一步开始安装，再 accept 版权协议，就完成安装了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211062237603.png" alt="image-20221106223704467"></p>
<p>最后安装过程可能要几分钟：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211062239908.png" alt="image-20221106223918826"></p>
<p>下图是 eclipse 官方给出的插件安装方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211062025692.png" alt="img"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 VSCode 插件离线安装时版本不兼容问题</title>
    <url>/posts/defb2725.html</url>
    <content><![CDATA[<h2 id="插件离线安装方法"><a href="#插件离线安装方法" class="headerlink" title="插件离线安装方法"></a>插件离线安装方法</h2><ol>
<li><p>去官网插件库搜索需要的插件 <a href="https://marketplace.visualstudio.com/">https://marketplace.visualstudio.com/</a>。</p>
</li>
<li><p>然后在插件详情页面右边点击 <code>Download Extension</code>，下载 VSIX 格式插件。</p>
</li>
<li><p>打开 VSCode 插件窗口，点击 <code>Install from VSIX</code>，此时安装会报错版本不兼容。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Unable to install extension 'xxx' as it is not compatible with VS Code '1.56.xx'</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h2 id="解决版本不兼容报错"><a href="#解决版本不兼容报错" class="headerlink" title="解决版本不兼容报错"></a>解决版本不兼容报错</h2><ol>
<li><p>修改 vsix 插件后缀名为.zip，然后双击通过解压软件打开，找到 Extension 目录下 package.json 文件，修改其 engine 版本号为当前 vscode 的版本号。</p>
</li>
<li><p>修改完成后，记得保存，再将后缀名修改回去，重新安装插件即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM 介绍</title>
    <url>/posts/22588541.html</url>
    <content><![CDATA[<h1 id="RPM-命令"><a href="#RPM-命令" class="headerlink" title="RPM 命令"></a>RPM 命令</h1><p><strong>一、RPM 介绍</strong></p>
<p>1. 什么是 rpm ？</p>
<p>rpm 即 RedHat Package Management，是 RedHat 的发明之一</p>
<p>2. 为什么需要 rpm ？</p>
<p>在一个操作系统下，需要安装实现各种功能的软件包。这些软件包一般都有各自的程序，<br>但是同时也有错综复杂的依赖关系。同时还需要 解决软件包的版本，以及安装，配置，<br>卸载的自动化问题。为了解决 这些问题，RedHat 针对自己的系统提出了一个较好的办法<br>来管理成千 上百的软件。这就是 RPM 管理系统。在系统中安装了 rpm 管理系统以后，<br>只要是符合 rpm 文件标准的打包程序都可以方便地安装、升级、卸载。</p>
<p>3. 是不是所有的 linux 都使用 rpm ？</p>
<p>任何系统都需要包管理系统，因此很多 linux 都使用 rpm 系统。 rpm 系统是 Redhat Linux 和<br>Fedora Core 的软件包管理器，但是 Mandriva、SuSE 等 Linux 发行版也都使用 rpm。由于 rpm<br>的源程序可以在别的系统上进行编译，所以有可能在别的系统上也使用 rpm。除了 rpm，<br>其他一些系统也有自己的软件包管理程序， 例如 debian 的 deb 包。</p>
<p>4.rpm 包的文件名为什么那么长 ？</p>
<p>rpm 包的文件名中包含了这个软件包的版本信息，操作系统信息，硬件要求等等。<br>比如 mypackage-1.1-2RH.i386.rpm，其中 mypackage 是在系统中登记的软件包的名字 1.1<br>是软件的版本号，2 是发行号，RH 表示用于 RH 操作系统。i386 表示用于 intel x86 平台。</p>
<p>5. 软件包文件名中的 i386,i686 是什么意思</p>
<p>rpm 软件包的文件名中，不仅包含了软件名称，版本信息，还包括了适用的硬件架构的信息。</p>
<p>i386 指这个软件包适用于 intel 80386 以上的 x86 架构的计算机 (AI32)<br>i686 指这个软件包适用于 intel 80686 以上 (奔腾 pro 以上) 的 x86 架构的计算机 (IA32)<br>noarch 指这个软件包与硬件架构无关，可以通用。</p>
<p>i686 软件包通常针对 CPU 进行了优化，现在通常配置的机器都可以使用 i686 软件包。</p>
<p>6. 不同操作系统发行的 rpm 包可否混用？</p>
<p>对于已经编译成二进制的 rpm 包，由于操作系统环境不同，一般不能混用。<br>对于以 src.rpm 发行的软件包，由于需要安装时进行本地编译，所以通常可以在不同系统下安装。</p>
<p><strong>二、RPM 包管理的用途</strong></p>
<p>1、可以安装、删除、升级和管理以 rpm 包形式发布的软件；<br>2、可以查询某个 rpm 包中包含哪些文件，以及某个指定文件属于哪个 rpm 包；<br>3、可以在查询系统中的某个 rpm 包是否已安装以及其版本；<br>4、作为开发者可以把自己开发的软件打成 rpm 包发布；<br>5、依赖性的检查，查询安装某个 rpm 包时，需要哪些其它的 rpm 包。</p>
<p>注：RPM 软件的安装、删除、更新只有 root 权限才能使用；<br>对于查询功能任何用户都可以操作。</p>
<p><strong>三、rpm 的一点简单用法</strong></p>
<p>rpm 的一般格式：</p>
<p>rpm [选项] [rpm 软件包]</p>
<p>1、初始化 rpm 数据库（可以省略）</p>
<p>rpm –initdb<br>rpm –rebuilddb % 注：这个要花好长时间</p>
<p>% 注：有时 rpm 系统出了问题，不能安装和查询，大多是这里出了问题。</p>
<p>2、RPM 软件包管理的查询功能：</p>
<p>rpm -q [select-options] [query-options]</p>
<p>RPM 的查询功能是极为强大，是极为重要的功能之一；这里举几个常用的例子，更为详细的具体的，请参考 man rpm</p>
<p><em>对系统中已安装软件的查询</em></p>
<p>1）查询系统已安装的软件</p>
<p>语法：rpm -q 软件名</p>
<p>例：rpm -q gaim<br>% -q 就是 –query，此选项表示询问系统是不是安装了 gaim 软件包；<br>% 如果已安装会有信息输出；如果没有安装，会输出 gaim 没有安装的信息；</p>
<p>% 查看系统中所有已经安装的包，要加 -a 参数<br>rpm -qa</p>
<p>% 如果分页查看，再加一个管道 | 和 more 命令<br>rpm -qa |more</p>
<p>% 如果要查找某个软件包，可以用 grep 抽取出来<br>rpm -qa |grep mplayer</p>
<p>2）查询一个已经安装的文件属于哪个软件包；</p>
<p>语法: rpm -qf 文件名</p>
<p>注：文件名所在的绝对路径要指出</p>
<p>例：rpm -qf /usr/lib/libacl.la</p>
<p>3）查询已安装软件包都安装到何处；</p>
<p>语法：rpm -ql 软件包名</p>
<p>例：rpm -ql mplayer</p>
<p>4）查询一个已安装软件包的信息</p>
<p>语法： rpm -qi 软件包名</p>
<p>例：rpm -qi mplayer</p>
<p>5）查看一下已安装软件的配置文件；</p>
<p>语法格式：rpm -qc 软件名</p>
<p>例：rpm -qc mplayer</p>
<p>6）查看一个已经安装软件的文档安装位置：</p>
<p>语法格式： rpm -qd 软件名</p>
<p>例：rpm -qd mplayer</p>
<p>7）查看一下已安装软件所依赖的软件包及文件；</p>
<p>语法格式： rpm -qR 软件名</p>
<p>例：rpm -qR mplayer</p>
<p><strong>注</strong>：可以把几个参数组合起来用，如 rpm -qil mplayer</p>
<p><em>对于未安装的软件包的查看</em> : 查看的前提是当前目录下已存在一个.rpm 文件。</p>
<p>1）查看一个软件包的用途、版本等信息；</p>
<p>语法： rpm -qpi file.rpm</p>
<p>例：rpm -qpi mplayer-1.0pre7try2-2.i386.rpm</p>
<p>2）查看一件软件包所包含的文件；</p>
<p>语法： rpm -qpl file.rpm</p>
<p>例：rpm -qpl mplayer-1.0pre7try2-2.i386.rpm</p>
<p>3）查看软件包的文档所在的位置；</p>
<p>语法： rpm -qpd file.rpm</p>
<p>例：rpm -qpd mplayer-1.0pre7try2-2.i386.rpm</p>
<p>4）查看一个软件包的配置文件；</p>
<p>语法： rpm -qpc file.rpm</p>
<p>例：rpm -qpc mplayer-1.0pre7try2-2.i386.rpm</p>
<p>5）查看一个软件包的依赖关系</p>
<p>语法： rpm -qpR file.rpm</p>
<p>例：rpm -qpR mplayer-1.0pre7try2-2.i386.rpm</p>
<p>3、软件包的安装、升级、删除等； <em>安装和升级一个 rpm 包</em></p>
<p>语法：<br>rpm -ivh file.rpm % 这个是用来安装一个新的 rpm 包<br>rpm -Uvh file.rpm % 这是用来升级一个 rpm 包</p>
<p>% 如果有依赖关系的，需解决依赖关系。<br>% 如果找不到依赖关系的包，可以用下面的命令强制安装：</p>
<p>rpm -ivh –nodeps –force file.rpm<br>rpm -Uvh –nodeps –force file.rpm</p>
<p>例：<br>rpm -ivh –test mplayer-1.0pre7try2-2.i386.rpm<br>% –test 表示测试，并不真正安装。</p>
<p>rpm -ivh –relocate /=/usr/local/mplayer mplayer-1.0pre7try2-2.i386.rpm<br>% 为软件包指定安装目录：要加 –relocate 参数<br>% 安装在指定目录中的程序如何调用呢？<br>% 通常可执行程序都放在安装目录下的 bin 或者 sbin 目录中。</p>
<p><em>删除一个 rpm 包</em></p>
<p>首先查出需要删除的 rpm 包，然后用下面的命令来卸载：</p>
<p>rpm -e 软件包名</p>
<p>例：rpm -e mplayer % 卸载 mplayer<br>% 如果有其它的 rpm 依赖于该 rpm 包，系统会出现警告。<br>% 如果一定要卸载，可以用选项 –nodeps 忽略依赖关系。但最好不要这么做。</p>
<p><strong>四、RPM 管理包管理器支持网络安装和查询</strong></p>
<p>rpm [选项] rpm 包的 http 或者 ftp 的地址</p>
<p>比如我们想通过 Fedora Core 4.0 的一个镜像查询、安装软件包。</p>
<p>rpm -qpi <a href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 查询</p>
<p>rpm -ivh <a href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 安装</p>
<p><strong>五、对已安装 rpm 包查询的一点补充</strong></p>
<p>可以用 locate 来查询一些软件的安装位置，可能需要先运行 updatedb 来更新已安装软件库</p>
<p><strong>六、从 rpm 软件包抽取文件</strong></p>
<p>rpm2cpio xxx.rpm | cpio -idmv<br>% i 表示提取文件，v 表示指示执行进程<br>% d 表示根据包中文件原来的路径建立目录<br>% m 表示保持文件的更新时间</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>df 命令 - 显示磁盘空间</title>
    <url>/posts/22729.html</url>
    <content><![CDATA[<h2 id="df命令介绍"><a href="#df命令介绍" class="headerlink" title="df命令介绍"></a>df 命令介绍</h2><p>df 命令的英文全称即 <code>Disk Free</code>，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为 KB，建议使用 “df -h” 的参数组合，根据磁盘容量自动变换合适的单位，更利于人性化阅读。</p>
<p>日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p>
<h2 id="df命令常用参数"><a href="#df命令常用参数" class="headerlink" title="df命令常用参数"></a>df 命令常用参数</h2><table>
<thead>
<tr>
<th>-a</th>
<th> 显示所有系统文件</th>
</tr>
</thead>
<tbody><tr>
<td> -h</td>
<td> 以容易阅读的方式显示</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="df默认选项"><a href="#df默认选项" class="headerlink" title="df默认选项"></a><code>df</code> 默认选项</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao ~]# df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs          347636       0    347636   0% /dev</span><br><span class="line">tmpfs             362780       0    362780   0% /dev/shm</span><br><span class="line">tmpfs             362780   41188    321592  12% /run</span><br><span class="line">tmpfs             362780       0    362780   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       20510332 1610056  17835368   9% /</span><br><span class="line">tmpfs              72556       0     72556   0% /run/user/0</span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></tbody></table></figure>
<h3 id="df-h便于人性化阅读"><a href="#df-h便于人性化阅读" class="headerlink" title="df -h便于人性化阅读"></a><code>df -h</code> 便于人性化阅读</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        340M     0  340M   0% /dev</span><br><span class="line">tmpfs           355M     0  355M   0% /dev/shm</span><br><span class="line">tmpfs           355M   41M  315M  12% /run</span><br><span class="line">tmpfs           355M     0  355M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        20G  1.6G   18G   9% /</span><br><span class="line">tmpfs            71M     0   71M   0% /run/user/0</span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></tbody></table></figure>
<h3 id="df-ah显示全部文件系统"><a href="#df-ah显示全部文件系统" class="headerlink" title="df -ah显示全部文件系统"></a><code>df -ah</code> 显示全部文件系统</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao ~]# df -ah</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">sysfs              0     0     0    - /sys</span><br><span class="line">proc               0     0     0    - /proc</span><br><span class="line">devtmpfs        340M     0  340M   0% /dev</span><br><span class="line">securityfs         0     0     0    - /sys/kernel/security</span><br><span class="line">tmpfs           355M     0  355M   0% /dev/shm</span><br><span class="line">devpts             0     0     0    - /dev/pts</span><br><span class="line">tmpfs           355M   41M  315M  12% /run</span><br><span class="line">tmpfs           355M     0  355M   0% /sys/fs/cgroup</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore             0     0     0    - /sys/fs/pstore</span><br><span class="line">bpf                0     0     0    - /sys/fs/bpf</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/perf_event</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/rdma</span><br><span class="line">none               0     0     0    - /sys/kernel/tracing</span><br><span class="line">configfs           0     0     0    - /sys/kernel/config</span><br><span class="line">/dev/vda1        20G  1.6G   18G   9% /</span><br><span class="line">mqueue             0     0     0    - /dev/mqueue</span><br><span class="line">hugetlbfs          0     0     0    - /dev/hugepages</span><br><span class="line">debugfs            0     0     0    - /sys/kernel/debug</span><br><span class="line">systemd-1          -     -     -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">binfmt_misc        0     0     0    - /proc/sys/fs/binfmt_misc</span><br><span class="line">tmpfs            71M     0   71M   0% /run/user/0</span><br><span class="line">[root@paopao ~]#      </span><br></pre></td></tr></tbody></table></figure>
<h3 id="df-目录-指定目录下的文件’指定文件所在分区的磁盘使用情况"><a href="#df-目录-指定目录下的文件’指定文件所在分区的磁盘使用情况" class="headerlink" title="df  目录 指定目录下的文件’指定文件所在分区的磁盘使用情况"></a><code>df  目录</code> 指定目录下的文件’指定文件所在分区的磁盘使用情况</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao ~]# df /root/.bashrc </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/vda1       20510332 1610068  17835356   9% /</span><br><span class="line">[root@paopao ~]# </span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>mount 命令 - 挂载磁盘</title>
    <url>/posts/37407.html</url>
    <content><![CDATA[<h2 id="mount命令介绍"><a href="#mount命令介绍" class="headerlink" title="mount命令介绍"></a>mount 命令介绍</h2><p>用于加载文件系统到指定的加载点。此命令的最常用于挂载 cdrom，使我们可以访问 cdrom 中的数据，因为你将光盘插入 cdrom 中，Linux 并不会自动挂载，必须使用 Linux mount 命令来手动完成挂载。</p>
<h2 id="mount命令常用参数"><a href="#mount命令常用参数" class="headerlink" title="mount命令常用参数"></a>mount 命令常用参数</h2><table>
<thead>
<tr>
<th>-t</th>
<th> 指定挂载类型</th>
</tr>
</thead>
<tbody><tr>
<td> -a</td>
<td> 加载文件 “/etc/fstab” 中描述的所有文件系统</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>挂载 /dev/cdrom 到 /mnt：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# mount /dev/cdrom /mnt</span><br></pre></td></tr></tbody></table></figure>

<p>启动所有挂载：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# mount -a</span><br></pre></td></tr></tbody></table></figure>

<p>挂载 nfs 格式文件系统：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@linuxcool ~]# mount -t nfs /123 /mnt  </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>rz、sz 命令 - 文件传输</title>
    <url>/posts/42689.html</url>
    <content><![CDATA[<h1 id="1-软件安装"><a href="#1-软件安装" class="headerlink" title="1. 软件安装"></a>1. 软件安装</h1><p>rz/sz 命令用来在 xshell 远程服务器和本地之间传输文件，主要有两种方式安装，yum 安装或者编译安装。</p>
<h2 id="1-1-yum包安装"><a href="#1-1-yum包安装" class="headerlink" title="1.1 yum包安装"></a>1.1 yum 包安装</h2><p>root 账号登陆后执行以下命令：</p>
<blockquote>
<p>yum install -y lrzsz</p>
</blockquote>
<h2 id="2-2-源码编译安装"><a href="#2-2-源码编译安装" class="headerlink" title="2.2 源码编译安装"></a>2.2 源码编译安装</h2><p>root 账号登陆后，依次执行以下命令：</p>
<blockquote>
<p>cd /tmp<br>wget <a href="http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a><br>tar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20<br>./configure &amp;&amp; make &amp;&amp; make install</p>
</blockquote>
<p>上面安装过程默认把 lsz/lrz 安装到了 /usr/local/bin/ 目录下，现在我们还不能使用 sz/rz 命令，需要手动建立软链接：</p>
<blockquote>
<p>cd /usr/bin<br>ln -s /usr/local/bin/lsz sz<br>ln -s /usr/local/bin/lrz rz</p>
</blockquote>
<h1 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2. 使用说明"></a>2. 使用说明</h1><h2 id="2-1-sz命令：发送文件到本地目录"><a href="#2-1-sz命令：发送文件到本地目录" class="headerlink" title="2.1 sz命令：发送文件到本地目录"></a>2.1 sz 命令：发送文件到本地目录</h2><blockquote>
<p>sz filename</p>
</blockquote>
<h2 id="2-2-rz命令：将本地文件上传到linux服务器"><a href="#2-2-rz命令：将本地文件上传到linux服务器" class="headerlink" title="2.2 rz命令：将本地文件上传到linux服务器"></a>2.2 rz 命令：将本地文件上传到 linux 服务器</h2><blockquote>
<p>rz</p>
</blockquote>
<p>执行此命令后，在弹出框中选择要上传的文件即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>yum 命令 - RPM 包管理器</title>
    <url>/posts/29820.html</url>
    <content><![CDATA[<h2 id="yum命令介绍"><a href="#yum命令介绍" class="headerlink" title="yum命令介绍"></a>yum 命令介绍</h2><p>yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理 RPM 软件包，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
<h2 id="yum命令常用参数"><a href="#yum命令常用参数" class="headerlink" title="yum命令常用参数"></a>yum 命令常用参数</h2><table>
<thead>
<tr>
<th>-h</th>
<th> 显示帮助信息</th>
</tr>
</thead>
<tbody><tr>
<td> -y</td>
<td> 对所有的提问都回答 “yes”</td>
</tr>
<tr>
<td>install</td>
<td> 安装 rpm 软件包</td>
</tr>
<tr>
<td> update</td>
<td> 更新 rpm 软件包</td>
</tr>
<tr>
<td> check-update</td>
<td> 检查是否有可用的更新 rpm 软件包</td>
</tr>
<tr>
<td> remove</td>
<td> 删除指定的 rpm 软件包</td>
</tr>
<tr>
<td> list</td>
<td> 显示软件包的信息</td>
</tr>
<tr>
<td> search</td>
<td> 检查软件包的信息</td>
</tr>
<tr>
<td> info</td>
<td> 显示指定的 rpm 软件包的描述信息和概要信息</td>
</tr>
<tr>
<td> clean</td>
<td> 清理 yum 过期的缓存</td>
</tr>
<tr>
<td> resolvedep</td>
<td> 显示 rpm 软件包的依赖关系</td>
</tr>
<tr>
<td> localinstall</td>
<td> 安装本地的 rpm 软件包</td>
</tr>
<tr>
<td> localupdate</td>
<td> 显示本地 rpm 软件包进行更新</td>
</tr>
<tr>
<td> deplist</td>
<td> 显示 rpm 软件包的所有依赖关系</td>
</tr>
</tbody></table>
<h2 id="国内-yum-源"><a href="#国内-yum-源" class="headerlink" title="国内 yum 源"></a>国内 yum 源</h2><p>网易（163）yum 源是国内最好的 yum 源之一 ，无论是速度还是软件版本，都非常的不错。</p>
<p>将 yum 源设置为 163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p>
<h3 id="yum源配置方法"><a href="#yum源配置方法" class="headerlink" title="yum源配置方法"></a>yum 源配置方法</h3><p>首先备份 /etc/yum.repos.d/CentOS-Base.repo</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></tbody></table></figure>

<p>下载对应版本 repo 文件，放入 /etc/yum.repos.d/ (操作前请做好相应备份)</p>
<ul>
<li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">CentOS5</a> ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li>
<li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">CentOS6</a> ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li>
<li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">CentOS7</a> ：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></tbody></table></figure>

<p>运行以下命令生成缓存</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 一行执行多条命令</title>
    <url>/posts/2732b274.html</url>
    <content><![CDATA[<h3 id="分号"><a href="#分号" class="headerlink" title=";(分号)"></a>;(分号)</h3><p>被分号 (;) 所分隔的命令会连续的执行下去，就算是错误命令也会继续执行后面的命令.</p>
<h3 id=""><a href="#" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>如果命令被 &amp;&amp; 所分隔，那么命令也会一直执行下去，但是中间有错误的命令存在就不会执行后面的命令，没错就直行至完为止。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h3><p>如果每个命令被双竖线 || 所分隔，那么一遇到可以执行成功的命令就会停止执行后面的命令，而不管后面的命令是否正确与否。如果执行到错误的命令就是继续执行后一个命令，一直执行到遇到正确的命令为止。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 下压缩、解压命令汇总</title>
    <url>/posts/bfc2a6f5.html</url>
    <content><![CDATA[<p>日常工作中，在 Linux 环境下会遇到各种格式的压缩包，不同格式的压缩包需要用不同的工具和命令解压。格式种类比较多，命令也难记，所以这里梳理汇总一下，方便以后查阅。</p>
<span id="more"></span>

<h3 id="命令一览表"><a href="#命令一览表" class="headerlink" title="命令一览表"></a>命令一览表</h3><table>
<thead>
<tr>
<th>压缩包格式</th>
<th>解压命令</th>
<th>压缩命令</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td> a.tar.gz</td>
<td>tar -zxvf a.tar.gz</td>
<td>tar -zcvf a.tar.gz a.txt</td>
<td></td>
</tr>
<tr>
<td>a.tar.bz2</td>
<td>tar -jxvf a.tar.bz2</td>
<td>tar -jcvf a.tar.bz2 a.txt</td>
<td></td>
</tr>
<tr>
<td>a.zip</td>
<td>unzip a.zip</td>
<td>zip a.zip a.txt</td>
<td></td>
</tr>
<tr>
<td>a.rar</td>
<td>unrar e a.rar</td>
<td>rar a a.rar a.txt</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下段错误生成 core 文件的相关配置</title>
    <url>/posts/831131d.html</url>
    <content><![CDATA[<h2 id="core-dump-介绍"><a href="#core-dump-介绍" class="headerlink" title="core dump 介绍"></a>core dump 介绍</h2><p>在 Linux 环境下调试 C/C++ 程序时，经常会因为内存访问错误产生段错误（核心已转储），而在当前目录却找不到转储的 core 文件，此时需要检查系统 core dump 配置是否打开。</p>
<p>如果打开系统 core dump 功能，那么在程序运行报段错误后，系统就会将程序的内存映像转储到硬盘，随后可以用 gdb 对生成的 core 文件进行分析，还原程序发生段错误时刻的堆栈调用信息。</p>
<h2 id="查看系统-core-dump-配置"><a href="#查看系统-core-dump-配置" class="headerlink" title="查看系统 core dump 配置"></a>查看系统 core dump 配置</h2><p>通过 <code>ulimit -a</code> 命令查看系统 core 文件的大小限制，可以看到第一行 core file size 设置为 0，即没有打开 core dump 开关。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 31400</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 31400</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置系统生成的-core-文件大小"><a href="#设置系统生成的-core-文件大小" class="headerlink" title="设置系统生成的 core 文件大小"></a>设置系统生成的 core 文件大小</h2><p>使用 <code>ulimit -c [kbytes]</code> 命令设置系统允许生成的 core 文件大小。</p>
<ul>
<li>ulimit -c 0 ：不产生 core 文件</li>
<li> ulimit -c 100 ：设置 core 文件最大为 100kb</li>
<li>ulimit -c unlimited ：不限制 core 文件大小</li>
</ul>
<p>通常会设置为 unlimited，即不限制文件大小。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ ulimit -c unlimited </span><br></pre></td></tr></tbody></table></figure>

<p>然后，再查看下系统 core dump 配置，可以看到第一行 core file size 变为了 unlimited。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 31400</span><br><span class="line">max locked memory       (kbytes, -l) 65536</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 31400</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置-core-文件保存路径"><a href="#配置-core-文件保存路径" class="headerlink" title="配置 core 文件保存路径"></a>配置 core 文件保存路径</h2><p>core 文件具体存放在哪个目录取决于系统参数 kernel.core_pattern：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@ubuntu:# cat /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E</span><br></pre></td></tr></tbody></table></figure>

<p>修改 <code>/proc/sys/kernel/core_pattern</code> 设置格式化的 core 文件保存位置或文件名：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@ubuntu:# cat /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E</span><br><span class="line"></span><br><span class="line">root@ubuntu:# echo "/home/lhx/test/coredump/core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line">root@ubuntu:/home/lhx/test/coredump# cat /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="meta prompt_">/home/lhx/test/coredump/core-%</span><span class="language-bash">e-%p-%t</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>% E：添加可执行程序的完整路径<br>% e：添加可执行程序名<br>% p：添加 pid<br>% t：进程奔溃的时间戳<br>% s：添加导致产生 core 的信号<br>% u - 添加当前 uid<br>% g - 添加当前 gid</p>
</blockquote>
<p>然后重新设置 ulimit，再测试一下，发现生成了对应的 core 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@ubuntu:/home/lhx/test/coredump# ulimit -c unlimited</span><br><span class="line">root@ubuntu:/home/lhx/test/coredump# ./a.out </span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">root@ubuntu:/home/lhx/test/coredump# ls</span><br><span class="line">a.out  core-a.out-9209-1653703102  coredump.c</span><br></pre></td></tr></tbody></table></figure>

<h2 id="复杂情况处理"><a href="#复杂情况处理" class="headerlink" title="复杂情况处理"></a>复杂情况处理</h2><ol>
<li><p>一般情况下，使用 <code>ulimit -c unlimited</code> 命令后，会默认在当前目录生成对应 core 文件。</p>
</li>
<li><p>如果当前目录没有找到 core 文件，使用命令 <code>cat /proc/sys/kernel/core_pattern</code> 却看到 <code>/usr/share/apport/apport</code> 类似的路径，注意这个并不是系统保存的路径！Ubuntu 下 coredump 会被  Apport 来处理。</p>
</li>
<li><p>此时建议进行格式化设置 core 文件路径和名称，然后，基本就能正常显示 core 文件。</p>
</li>
<li><p>如果还是找不到 core 文件，则使用下面的终极方法：</p>
</li>
</ol>
<p>使用 <code>cat /var/log/apport.log</code> 查看日志：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/share/apport# cat /var/log/apport.log </span><br><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: called for pid 3163, signal 11, core limit 18446744073709551615, dump mode 1</span><br><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: ignoring implausibly big core limit, treating as unlimited</span><br><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: executable: /home/lhx/test/coredump/a.out (command line "./a.out")</span><br><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: executable does not belong to a package, ignoring</span><br><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: writing core dump to core._home_lhx_test_coredump_a_out.0.b0a0dac1-9489-4362-b93e-5b795f497130.3163.16880 (limit: -1)</span><br></pre></td></tr></tbody></table></figure>

<p>会看到一行关键信息，包含可执行程序名称、路径和时间戳，这就是 core 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ERROR: apport (pid 3164) Fri May 27 22:29:20 2022: writing core dump to core._home_lhx_test_coredump_a_out.0.b0a0dac1-9489-4362-b93e-5b795f497130.3163.16880 (limit: -1)</span><br></pre></td></tr></tbody></table></figure>

<p>然后全局范围内搜索文件名，会发现 core 文件位于 <code>/var/lib/apport/coredump/</code> 目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:/$ sudo find . -name "core._home_lhx_test_coredump_a_out.0.b0a0dac1*"</span><br><span class="line">/var/lib/apport/coredump/core._home_lhx_test_coredump_a_out.0.b0a0dac1-9489-4362-b93e-5b795f497130.3163.16880</span><br></pre></td></tr></tbody></table></figure>

<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><ol>
<li>注意 <code>ulimit -c unlimited</code> 命令只针对当前 shell 窗口有效。</li>
<li>格式化设置 core 文件路径和名称时，注意要用 root 或 sudo 权限。</li>
<li>如果上述方法还是不行，建议全局使用 root 账户。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>coredump</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中关于包安装命令 apt、yum、dpkg、rpm 的区别</title>
    <url>/posts/7a422bf0.html</url>
    <content><![CDATA[<h2 id="Linux两大派系"><a href="#Linux两大派系" class="headerlink" title="Linux两大派系"></a>Linux 两大派系</h2><p>介绍这几个命令之前，需要先了解下 Linux 两大派系：Debian 系列和 RedHat 系列。</p>
<ul>
<li>Debian 系列：Debian、Ubuntu 等；国产包括深度 uos、银河麒麟、普华等。</li>
<li>RedHat 系列：Redhat、Centos、Fedora 等；国产包括中标麒麟等。</li>
</ul>
<h2 id="两种包管理工具"><a href="#两种包管理工具" class="headerlink" title="两种包管理工具"></a>两种包管理工具</h2><p>两大派系都有自己的一套软件包管理工具和安装包格式。</p>
<ul>
<li>Debian 系列的包管理工具是 apt（或 apt-get），安装包格式 deb 包。</li>
</ul>
<p>deb 包安装命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo dpkg –i 软件包.deb</span><br></pre></td></tr></tbody></table></figure>
<p>deb 包卸载命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo dpkg -r 软件包名</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里 <code>r</code> 表示 <code>remove package</code></p>
</blockquote>
<ul>
<li>RedHat 系列的包管理工具是 yum，安装包格式 rpm 包。</li>
</ul>
<p>rpm 包安装命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo rpm –ivh 软件包.rpm</span><br></pre></td></tr></tbody></table></figure>
<p>rpm 包卸载命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Sudo rpm –e 软件包.rpm</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这里 <code>e</code> 表示 <code>erase (uninstall) package</code></p>
</blockquote>
<h2 id="查看软件包依赖关系"><a href="#查看软件包依赖关系" class="headerlink" title="查看软件包依赖关系"></a>查看软件包依赖关系</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">apt-cache depends 软件包 # 依赖哪些包</span><br><span class="line"></span><br><span class="line">apt-cache rdepends 软件包 # 被哪些包依赖</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yum deplist 软件包 # 依赖哪些包</span><br><span class="line">或者 rpm -qR 软件包 # 查软件包依赖哪些包，R表示requires</span><br><span class="line"></span><br><span class="line">rpm -e --test 软件包 # 被哪些包依赖</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>通过–test 进行测试删除，查看是否有依赖关系，如果有会阻止删除</p>
</blockquote>
<h2 id="apt和dpkg区别"><a href="#apt和dpkg区别" class="headerlink" title="apt和dpkg区别"></a>apt 和 dpkg 区别</h2><ul>
<li>apt 是会解决和安装模块的依赖问题，并会咨询软件仓库，是在线安装</li>
<li> dpkg 只能安装本地的 deb 文件，不会关心 ubuntu 软件仓库的软件，不会解决模块的依赖关系</li>
</ul>
<h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><table>
<thead>
<tr>
<th>Linux 派系</th>
<th> Debian 系列</th>
<th> RedHat 系列</th>
</tr>
</thead>
<tbody><tr>
<td>安装包格式</td>
<td> deb 包</td>
<td> rpm 包</td>
</tr>
<tr>
<td>包管理命令</td>
<td> dpkg</td>
<td>rpm</td>
</tr>
<tr>
<td> 安装命令</td>
<td> dpkg –i xx.deb</td>
<td>rpm –ivh xx.rpm</td>
</tr>
<tr>
<td> 卸载命令</td>
<td> dpkg -r xx.deb</td>
<td>rpm –e xx.rpm</td>
</tr>
<tr>
<td> 包管理工具</td>
<td> apt</td>
<td>yum</td>
</tr>
<tr>
<td> 安装 / 卸载命令</td>
<td> apt install/remove xx</td>
<td>yum install/remove xx</td>
</tr>
<tr>
<td> 查询安装包</td>
<td> dpkg -l | grep xx</td>
<td>rpm –qa | grep xx</td>
</tr>
<tr>
<td> 查询依赖哪些</td>
<td> apt-cache depends xx</td>
<td>yum deplist xx</td>
</tr>
<tr>
<td> 查询被哪些依赖</td>
<td> apt-cache rdepends xx</td>
<td>rpm -e –test xx</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 关闭地址空间随机化 ASLR</title>
    <url>/posts/c34223c8.html</url>
    <content><![CDATA[<p>在编写 Linux 简单的调试器代码时，调试发现每次 ptrace 获取的 IP 寄存器都不一样，地址总是在变化，于是联想到 Linux 内核的 ASLR 机制，关闭地址空间随机化后，IP 指针值就固定下来了。</p>
<p>开启 ASLR 后，每次程序运行时的时候，装载的可执行文件和共享库都会被映射到虚拟地址空间的不同地址处；而关掉 ASLR，则可以保证每次运行时都会被映射到虚拟地址空间的相同地址处。</p>
<span id="more"></span>

<h2 id="地址空间随机化ASLR"><a href="#地址空间随机化ASLR" class="headerlink" title="地址空间随机化ASLR"></a>地址空间随机化 ASLR</h2><p>地址空间随机化 ASLR（Address Space Layout Randomization）配置通过内核参数 kernel.randomize_va_space 来实现，该参数取值范围为：0，1，2。系统默认开启 2 全随机模式。</p>
<ul>
<li>0：表示关闭进程地址空间随机化。</li>
<li>1：表示部分随机化，将共享库、栈、mmap () 以及 VDSO 进行随机化。</li>
<li>2：表示全部随机化，在 1 的基础上增加 heap 的随机化。</li>
</ul>
<h2 id="关闭随机化"><a href="#关闭随机化" class="headerlink" title="关闭随机化"></a>关闭随机化</h2><p>查看：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></tbody></table></figure>

<p>关闭（切换到 root 后再执行命令）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></tbody></table></figure>

<p>当使用  gdb 调试一个程序时，GDB 会自动关掉 ASLR。可以通过以下命令将它打开：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) set disable-randomization off</span><br><span class="line">(gdb) info poc map # 查看进程地址映射表</span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试 demo</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_sp</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">	<span class="keyword">asm</span>(<span class="string">"mov %rsp, %rax\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sp = get_sp();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SP ==&gt; 0x%lx\n"</span>, sp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@ubuntu:~# gcc test.c -o test</span><br><span class="line">root@ubuntu:~# echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7ffeccac2e60</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7fffb5a29c70</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7ffd1005e3b0</span><br><span class="line">root@ubuntu:~# echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7fffffffe500</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7fffffffe500</span><br><span class="line">root@ubuntu:~# ./test </span><br><span class="line">SP ==&gt; 0x7fffffffe500</span><br></pre></td></tr></tbody></table></figure>


<h2 id="get小技巧"><a href="#get小技巧" class="headerlink" title="get小技巧"></a>get 小技巧</h2><p>关掉 ASLR，可以保证在可执行程序和共享库不发生变更的情况下，每次执行时的进程地址空间映射表的一致。我们可通过运行时某动态符号（不知其名）的地址，减去其所在的共享库在地址映射表中起始地址，算出它相对于共享库数据段中的偏移，然后借助 objdump、readelf, nm 等工具查看对应 ELF 文件中全局符号的相对偏移，就可以反推出该符号的名字。这种调试手段对于那些被 strip 掉符号表的程序而言非常有效。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存管理中的缺页中断机制</title>
    <url>/posts/7af99990.html</url>
    <content><![CDATA[<p>为了解决内存碎片化问题，充分利用物理内存资源，Linux 提供了虚拟内存功能，并建立虚拟地址和物理地址直接的映射关系。进程无法直接访问物理地址，而是通过虚拟地址间接访问。一般虚拟地址都要比物理地址范围大，虚拟地址和物理地址并非总是一一对应关系，有时候虚拟地址尚未映射的物理地址，而只是一个空壳。当访问到尚未映射的虚拟地址时，就会触发缺页中断机制。</p>
<span id="more"></span>

<p>通过保存内存页表，可以实现从虚拟地址到物理地址的转换。虚拟内存以页为单位进行划分和管理，地址转换也是以页为单位。</p>
<p>页面大小取决于 CPU 架构，x86_64 页面大小为 4KB。</p>
<p>参照下图，如果进程访问 0~300 的虚拟地址，则 CPU 通过页表将其转换成对应的物理地址进行访问，无需经过内核处理。</p>
<p>如果访问 300~500 的虚拟地址，则 CPU 会发生缺页中断，中止正在执行的命令，并启动内核中的缺页中断处理机制。</p>
<p>一般每次访问新的虚拟内存，都是先触发缺页中断，然后分配物理地址，并更新对应的页表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301121543238.png" alt="image-20230112154344062"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令行 tab 补全命令时忽略大小写</title>
    <url>/posts/46abf88a.html</url>
    <content><![CDATA[<ol>
<li>在用户主目录新建<code>.inputrc</code> 配置文件，inputrc 文件是处理键盘映射的，来告诉系统如何根据处理键盘操作。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">vim .inputrc </span><br></pre></td></tr></tbody></table></figure>
<p><code>~/.inputrc</code> 仅供当前用户使用，<code>/etc/inputrc</code> 可以供所有用户使用。</p>
<ol start="2">
<li><p>在<code>.inputrc</code> 配置文件里填写 <code>set completion-ignore-case on</code></p>
</li>
<li><p>然后保存，再 <code>source .inputrc</code> 命令更新一下就可以了。</p>
</li>
</ol>
<span id="more"></span>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 和 Windows 下查看文件哈希值</title>
    <url>/posts/b6b9c575.html</url>
    <content><![CDATA[<h2 id="哈希值介绍"><a href="#哈希值介绍" class="headerlink" title="哈希值介绍"></a>哈希值介绍</h2><p>哈希值是文件内容经过哈希函数的计算，返回的一个独一无二的字符串。哪怕原始内容只改动一个字节，哈希码也会完全不同。用户下载软件后，只要计算一下哈希码，再跟作者给出的哈希码比较一下，就会知道软件有没有被改动。</p>
<p>目前，常用的三种哈希函数是 MD5、SHA1 和 SHA256。安全性：SHA256 &gt; SHA1 &gt; MD5。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li>md5sum 文件名</li>
<li> sha1sum 文件名</li>
<li> sha256sum 文件名 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ md5sum a.txt </span><br><span class="line">905138a85e85e74344e90d25dba7299e  a.txt</span><br><span class="line"></span><br><span class="line">$ sha1sum a.txt </span><br><span class="line">b1fda0e52e8099d2aeb80f57bb91548cace3093f  a.txt</span><br><span class="line"></span><br><span class="line">$ sha256sum a.txt </span><br><span class="line">a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889  a.txt</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul>
<li>certutil -hashfile 文件名&nbsp; MD5</li>
<li>certutil -hashfile 文件名&nbsp; SHA1</li>
<li>certutil -hashfile 文件名&nbsp; SHA256</li>
</ul>
<blockquote>
<p>【certutil 用法】<br>  CertUtil [选项] -hashfile InFile [HashAlgorithm]   通过文件生成并显示加密哈希<br>  哈希算法（大小写都可以）: MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&gt; certutil -hashfile a.txt md5</span><br><span class="line">MD5 的 a.txt 哈希:</span><br><span class="line">905138a85e85e74344e90d25dba7299e</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">&gt; certutil -hashfile a.txt sha1</span><br><span class="line">SHA1 的 a.txt 哈希:</span><br><span class="line">b1fda0e52e8099d2aeb80f57bb91548cace3093f</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">&gt; certutil -hashfile a.txt sha256</span><br><span class="line">SHA256 的 a.txt 哈希:</span><br><span class="line">a4bf1f6be616bf6a0de2ff6264de43a64bb768d38c783ec2bc74b5d4dcf5f889</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 环境编译安装 boost 库</title>
    <url>/posts/4a7db0c.html</url>
    <content><![CDATA[<p>三步实现 boost 库编译安装：</p>
<ol>
<li><code>./bootstrap.sh</code> 配置</li>
<li><code>./b2</code> 编译</li>
<li><code>./b2 install --prefix=/path/to/install</code> 安装</li>
</ol>
<span id="more"></span>

<h2 id="编译安装boost-1-58-0"><a href="#编译安装boost-1-58-0" class="headerlink" title="编译安装boost-1.58.0"></a>编译安装 boost-1.58.0</h2><ol>
<li>下载源码并解压，进入源码目录，运行脚本<code>./bootstrap.sh</code> 进行配置，随后会生成 b2 构建工具。b2 使用文本格式的构建脚本来管理代码，其名称通常 “jamfile” 或 “Jamfile”（类似 make 构建工具的 makefile 脚本一样）。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/boost/boost158/boost_1_58_0$ ./bootstrap.sh </span><br></pre></td></tr></tbody></table></figure>

<p>当看到下面的信息，则说明配置成功。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Building Boost.Build engine with toolset gcc... tools/build/src/engine/bin.linuxx86_64/b2</span><br><span class="line">Detecting Python version... 2.7</span><br><span class="line">Detecting Python root... /usr</span><br><span class="line">Unicode/ICU support for Boost.Regex?... /usr</span><br><span class="line">Generating Boost.Build configuration in project-config.jam...</span><br><span class="line"></span><br><span class="line">Bootstrapping is done. To build, run:</span><br><span class="line"></span><br><span class="line">    ./b2</span><br><span class="line">    </span><br><span class="line">To adjust configuration, edit 'project-config.jam'.</span><br><span class="line">Further information:</span><br><span class="line"></span><br><span class="line">   - Command line help:</span><br><span class="line">     ./b2 --help</span><br><span class="line">     </span><br><span class="line">   - Getting started guide: </span><br><span class="line">     http://www.boost.org/more/getting_started/unix-variants.html</span><br><span class="line">     </span><br><span class="line">   - Boost.Build documentation:</span><br><span class="line">     http://www.boost.org/build/doc/html/index.html</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>输入命令<code>./b2</code> 进行编译。当看到下面的信息，则说明编译成功。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc.compile.c++ bin.v2/libs/wave/build/gcc-9/release/link-static/threading-multi/cpplexer/re2clex/cpp_re.o</span><br><span class="line">gcc.archive bin.v2/libs/wave/build/gcc-9/release/link-static/threading-multi/libboost_wave.a</span><br><span class="line">common.copy stage/lib/libboost_wave.a</span><br><span class="line">...failed updating 58 targets...</span><br><span class="line">...skipped 12 targets...</span><br><span class="line">...updated 1061 targets...</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>输入命令<code>./b2 install --prefix=/path/to/boost/install</code> 进行安装，使用–prefix 指定安装位置。如果不指定，则默认安装到 /usr/local/lib 和 /usr/local/include/boost 位置。</li>
</ol>
<p>当看到下面的信息，则说明编译成功。进到安装目录会看到 include 和 lib 两个目录。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">...failed updating 58 targets...</span><br><span class="line">...skipped 12 targets...</span><br><span class="line">...updated 11610 targets...</span><br><span class="line">lhx@ubuntu:~/boost/boost158/boost_1_58_0$ cd ../install/</span><br><span class="line">lhx@ubuntu:~/boost/boost158/install$ ls</span><br><span class="line">include  lib</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>boost库</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 环境 jdk8 和 jdk11 安装和切换方式</title>
    <url>/posts/e052c00d.html</url>
    <content><![CDATA[<h2 id="安装jdk-8"><a href="#安装jdk-8" class="headerlink" title="安装jdk-8"></a>安装 jdk-8</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br><span class="line">sudo yum install java-8-openjdk</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装jdk-11"><a href="#安装jdk-11" class="headerlink" title="安装jdk-11"></a>安装 jdk-11</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br><span class="line">sudo yum install java-11-openjdk</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h2 id="用alternatives或update-alternatives命令查看已安装jdk版本"><a href="#用alternatives或update-alternatives命令查看已安装jdk版本" class="headerlink" title="用alternatives或update-alternatives命令查看已安装jdk版本"></a>用 alternatives 或 update-alternatives 命令查看已安装 jdk 版本</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">alternatives --config java</span><br><span class="line">update-alternatives --config java</span><br></pre></td></tr></tbody></table></figure>

<p>然后根据列举出来的序号选择对应的 Java 版本</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/hpc/test$ update-alternatives --config java</span><br><span class="line">有 2 个候选项可用于替换 java (提供 /usr/bin/java)。</span><br><span class="line"></span><br><span class="line">  选择       路径                                          优先级  状态</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      自动模式</span><br><span class="line">  1            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      手动模式</span><br><span class="line">  2            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      手动模式</span><br></pre></td></tr></tbody></table></figure>

<p>最后查看下 java 版本号</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>每天学个 Linux 命令 | dpkg</title>
    <url>/posts/4119ab6c.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>dpkg</code> 命令全称是 <code>Debian package</code>，即 Debian 系统的软件安装、管理、卸载工具，基于 Debian 系列 Linux 发行版基本都用 <code>dpkg</code> 命令来管理软件安装包。</p>
<span id="more"></span>

<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">dpkg [参数] 软件包</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@PAOPAO:~# dpkg -l vim</span><br><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                        Version            Architecture       Description</span><br><span class="line">+++-===========================-==================-==================-===========================================================</span><br><span class="line">ii  vim                         2:8.0.1453-1ubuntu amd64              Vi IMproved - enhanced vi editor</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@PAOPAO:~# dpkg -L vim</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/bin</span><br><span class="line">/usr/bin/vim.basic</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/bug</span><br><span class="line">/usr/share/bug/vim</span><br><span class="line">/usr/share/bug/vim/presubj</span><br><span class="line">/usr/share/bug/vim/script</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/vim</span><br><span class="line">/usr/share/doc/vim/NEWS.Debian.gz</span><br><span class="line">/usr/share/doc/vim/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/vim/copyright</span><br><span class="line">/usr/share/lintian</span><br><span class="line">/usr/share/lintian/overrides</span><br><span class="line">/usr/share/lintian/overrides/vim</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 可视模式下多行操作技巧</title>
    <url>/posts/71f253a3.html</url>
    <content><![CDATA[<h2 id="三种可视化模式"><a href="#三种可视化模式" class="headerlink" title="三种可视化模式"></a>三种可视化模式</h2><ol>
<li><p>按 <code>v</code> 进入字符可视模式（– VISUAL –）。文本选择是以字符为单位的。</p>
</li>
<li><p>按 <code>V</code> 或 <code>Shift+v</code> 进入可视行模式（– VISUAL LINE –)。文本选择是以行为单位的。</p>
</li>
<li><p>按 <code>Ctrl+v</code> 进入可视块模式（– VISUAL BLOCK –）。文本选择是以纵向的列为单位的。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="添加多行注释"><a href="#添加多行注释" class="headerlink" title="添加多行注释"></a>添加多行注释</h2><ol>
<li><p>按 <code>Ctrl+v</code> 进入可视块模式</p>
</li>
<li><p>通过上下按键选中多行</p>
</li>
<li><p>按 <code>I</code> 或 <code>Shift+i</code> 进行行首插入</p>
</li>
<li><p>添加注释字符</p>
</li>
<li><p>按 <code>Esc</code> 退出插入模式</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022049277.gif" alt="添加多行注释"></p>
<h2 id="删除多行注释"><a href="#删除多行注释" class="headerlink" title="删除多行注释"></a>删除多行注释</h2><ol>
<li>按 <code>Ctrl+v</code> 进入可视块模式</li>
<li>通过上下按键选中多行</li>
<li>按 <code>delete</code> 进行删除</li>
<li>按 <code>Esc</code> 退出插入模式</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022049421.gif" alt="删除多行注释"></p>
<h2 id="添加内容到多行行尾"><a href="#添加内容到多行行尾" class="headerlink" title="添加内容到多行行尾"></a>添加内容到多行行尾</h2><ol>
<li>按 <code>Ctrl+v</code> 进入可视块模式</li>
<li>通过上下按键选中多行</li>
<li>按 <code>$</code> 定位到行尾</li>
<li>按 <code>A</code> 或 <code>Shift+a</code> 进行行尾插入</li>
<li>添加插入内容</li>
<li>按 <code>Esc</code> 退出插入模式</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022049642.gif" alt="添加内容到多行行尾"></p>
<h2 id="对多行进行大小写转换"><a href="#对多行进行大小写转换" class="headerlink" title="对多行进行大小写转换"></a>对多行进行大小写转换</h2><ol>
<li>在三种可视模式下都能操作，先进入一种可视模式</li>
<li>通过上下左右按键选中多行</li>
<li>按 <code>~</code> 大小写互换</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022058620.gif" alt="大小写互换"></p>
<ol start="4">
<li>按 <code>U</code> 全部变大写</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022121964.gif" alt="全部变大写"></p>
<ol start="5">
<li>按 <code>u</code> 全部变小写</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212022058108.gif" alt="全部变小写"></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 速查图_中英文版</title>
    <url>/posts/6c0adc53.html</url>
    <content><![CDATA[<h2 id="中文翻译版"><a href="#中文翻译版" class="headerlink" title="中文翻译版"></a>中文翻译版</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202203181645094.jpg" alt="vim速查图_中文版"></p>
<h2 id="英文原版"><a href="#英文原版" class="headerlink" title="英文原版"></a>英文原版</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202203181645480.jpg" alt="vim速查图_英文版"></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 学习笔记</title>
    <url>/posts/102383ca.html</url>
    <content><![CDATA[<h2 id="多行添加注释和取消注释"><a href="#多行添加注释和取消注释" class="headerlink" title="多行添加注释和取消注释"></a>多行添加注释和取消注释</h2><p><strong>正常模式 –&gt; 可视模式：</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td> v</td>
<td> 可视模式</td>
</tr>
<tr>
<td> ctrl+v</td>
<td> 可视块模式</td>
</tr>
<tr>
<td> shift+v</td>
<td> 可视行模式</td>
</tr>
</tbody></table>
<p>可视块模式有一个非常实用的作用：选多行进行注释</p>
<ul>
<li><p>多行添加注释：<br>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- <code>shift + i</code>，进入 insert 模式<br>- 输入 <code>//</code><br>- <code>esc</code></p>
</li>
<li><p>多行取消注释：<br>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- 按 <code>d</code></p>
</li>
</ul>
<h2 id="同一窗口操作多个文件"><a href="#同一窗口操作多个文件" class="headerlink" title="同一窗口操作多个文件"></a>同一窗口操作多个文件</h2><ol>
<li>同时打开两个文件并分割窗口</li>
</ol>
<p>上下分割：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ vim -o filename1 filename2  </span><br></pre></td></tr></tbody></table></figure>
<p>左右分割：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ vim -O filename1 filename2</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>已打开一个文件，同时再打开另一个文件</li>
</ol>
<p>上下分割：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:vs filename</span><br></pre></td></tr></tbody></table></figure>
<p>左右分割：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:sp filename</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>其中，vs 可以用 vsplit 替换，sp 可以用 split 替换。<br>如果 finename 不存在，则会新建该文件并打开。</p>
</blockquote>
<ol start="3">
<li>切换窗口</li>
</ol>
<p>先 <code>ctrl + w</code> 开启窗口切换后，再选择按上下左右键进行跳转：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ctrl + w w  // 即按住ctrl键，再按两下w键。或者ctrl + w &lt;h|j|k|l&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>即按住 ctrl 键，按一次 w 键，再按一次表示方向的 h 或 j 或 k 或 l，则光标会切换到当前窗口的 左｜下｜上｜右 侧的窗口。</p>
</blockquote>
<ol start="4">
<li>关闭 vim 窗口</li>
</ol>
<p>关闭光标所在的窗口：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></tbody></table></figure>
<p>关闭所有窗口：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:qa</span><br></pre></td></tr></tbody></table></figure>
<p>关闭除光标所在的窗口之外的其他窗口：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:only</span><br></pre></td></tr></tbody></table></figure>


<h2 id="统计字符串出现次数"><a href="#统计字符串出现次数" class="headerlink" title="统计字符串出现次数"></a>统计字符串出现次数</h2><ul>
<li>命令 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:%s/pattern//gn</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参数说明</li>
</ul>
<p> % ：指明操作区间，% 表示全文本；可以使用 1,$ 或者行区间代替<br> s：substitute，表示替换<br> pattern：要查找的字符串<br> //：替代文本应该放在这里，两个斜杠中间没有任何字符表示无替代文本<br> g：替换该行所有出现的字符串，如果没有该参数则只替换该行第一次出现的地方<br> n：表示匹配的行数</p>
<ul>
<li>扩展</li>
</ul>
<p>统计 k 行到 l 行出现 pattern 的次数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:k,ls/pattern//gn</span><br></pre></td></tr></tbody></table></figure>

<p>统计在当前编辑文本出现的次数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">:%s/pattern//gn</span><br></pre></td></tr></tbody></table></figure>

<p>统计在文件中出现的行数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cat file|greg –i pattern |wc –l</span><br></pre></td></tr></tbody></table></figure>

<h2 id="鼠标选中不能复制"><a href="#鼠标选中不能复制" class="headerlink" title="鼠标选中不能复制"></a>鼠标选中不能复制</h2><p>vim 中鼠标选中不能复制并进入可视模式，习惯了在 vim 中鼠标选中即复制的效果，对此问题从网上查了下发现是 vim 的默认配置导致的。</p>
<ul>
<li>解决方法：</li>
</ul>
<ol>
<li><p>修改 vim 的默认配置文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vim /usr/share/vim/vim81/defaults.vim</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>输入 <code>/mouse</code> 搜索关键词 <code>mouse</code> ，定位到下面位置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if has('mouse')</span><br><span class="line">set mouse=a</span><br><span class="line">endif</span><br></pre></td></tr></tbody></table></figure>
<p>将 <code>set mouse=a</code> 改为 <code>set mouse-=a</code>（在等号前面加上一个减号）</p>
</li>
<li><p>输入 <code>:wq!</code> 保存即可解决问题。</p>
</li>
</ol>
<h2 id="删除多余空格"><a href="#删除多余空格" class="headerlink" title="删除多余空格"></a>删除多余空格</h2><ul>
<li><p>删除行尾多余的空格和 tab 符号。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">%s/\s\+$//g</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>命令解释：</p>
<blockquote>
<p>【% s】表示全文替换<br>【% s/str1/str2/g】表示将全文中 <code>str1</code> 替换成 <code>str2</code><br>【\s+$】要替换的内容 <code>str1</code>，其中 <code>\s</code> 表示空格和 tab，<code>\+</code> 表示一个或多个，<code>$</code> 表示行尾（表示行末（$）前的一个或者多个（+）空格（\s））<br>【//】替换后的内容 <code>str2</code>，其中 // 直接为空，表示替换为空，即达到删除效果<br>【g】表示全局替换（global）</p>
</blockquote>
<ul>
<li><p>只删除行尾空格，不能删除 tab</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">%s/ *$//g</span><br></pre></td></tr></tbody></table></figure>
<p>/ 和 * 中间有空格，只能删除行尾空格，对于 tab 不能删除</p>
</li>
</ul>
<h2 id="vim新建文件自动添加头部注释"><a href="#vim新建文件自动添加头部注释" class="headerlink" title="vim新建文件自动添加头部注释"></a>vim 新建文件自动添加头部注释</h2><ul>
<li>修改 <code>~/.vimrc</code>，在文件最后添加以下内容：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">" 【vim创建程序文件自动添加头部注释】</span><br><span class="line">" 当新建.h .c .hpp .cpp .sh文件时自动调用SetTitle函数添加头部注释</span><br><span class="line">autocmd BufNewFile *.[ch],*.hpp,*.cpp,*.sh exec ":call SetTitle()"</span><br><span class="line">" 定义.h .c .hpp .cpp注释格式</span><br><span class="line">func SetComment()</span><br><span class="line">	call setline(1,"/*================================================================")</span><br><span class="line">	call append(line("."),   "*  Author: paopao")</span><br><span class="line">	call append(line(".")+1, "*  Date: ".strftime("%Y-%m-%d"))</span><br><span class="line">	call append(line(".")+2, "*  Description: ")</span><br><span class="line">	call append(line(".")+3, "================================================================*/")</span><br><span class="line">	call append(line(".")+4, "")</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">" 定义.sh注释格式</span><br><span class="line">func SetComment_sh()</span><br><span class="line">	call setline(3, "#================================================================")</span><br><span class="line">	call setline(4, "#")</span><br><span class="line">	call setline(5, "#  Author: paopao")</span><br><span class="line">	call setline(6, "#  Date: ".strftime("%Y-%m-%d"))</span><br><span class="line">	call setline(7, "#  Description: ")</span><br><span class="line">	call setline(8, "#================================================================")</span><br><span class="line">	call setline(9, "")</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">" 定义函数SetTitle，自动插入文件头</span><br><span class="line">func SetTitle()</span><br><span class="line">	if &amp;filetype == 'sh'</span><br><span class="line">		call setline(1,"#!/bin/sh")</span><br><span class="line">		call setline(2,"")</span><br><span class="line">		call SetComment_sh()</span><br><span class="line">	else</span><br><span class="line">	     call SetComment()</span><br><span class="line">	     if expand("%:e") == 'h'</span><br><span class="line">		call append(line(".")+5, "#ifndef _".toupper(expand("%:t:r"))."_H")</span><br><span class="line">		call append(line(".")+6, "#define _".toupper(expand("%:t:r"))."_H")</span><br><span class="line">		call append(line(".")+7, "")</span><br><span class="line">		call append(line(".")+8, "#endif //".toupper(expand("%:t:r"))."_H")</span><br><span class="line">	     elseif expand("%:e") == 'hpp'</span><br><span class="line">		call append(line(".")+5, "#ifndef _".toupper(expand("%:t:r"))."_HPP")</span><br><span class="line">		call append(line(".")+6, "#define _".toupper(expand("%:t:r"))."_HPP")</span><br><span class="line">		call append(line(".")+7, "")</span><br><span class="line">		call append(line(".")+8, "#endif //".toupper(expand("%:t:r"))."_HPP")</span><br><span class="line">	     endif</span><br><span class="line">	endif</span><br><span class="line">endfunc</span><br></pre></td></tr></tbody></table></figure></li>
<li>新建 <code>a.sh</code> 和 <code>a.h</code> 来测试效果：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ vim a.sh</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#================================================================</span><br><span class="line">#</span><br><span class="line">#  Author: paopao</span><br><span class="line">#  Date: 2022-04-30</span><br><span class="line">#  Description: </span><br><span class="line">#================================================================</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ vim a.h</span><br><span class="line"></span><br><span class="line">/*================================================================</span><br><span class="line">*  Author: paopao</span><br><span class="line">*  Date: 2022-04-30</span><br><span class="line">*  Description: </span><br><span class="line">================================================================*/</span><br><span class="line"></span><br><span class="line">#ifndef _A_H</span><br><span class="line">#define _A_H</span><br><span class="line"></span><br><span class="line">#endif //A_H</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="底部状态行显示绝对路径和行列信息"><a href="#底部状态行显示绝对路径和行列信息" class="headerlink" title="底部状态行显示绝对路径和行列信息"></a>底部状态行显示绝对路径和行列信息</h2><ol>
<li>打开 vim 配置文件 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></tbody></table></figure></li>
<li>修改方法</li>
</ol>
<ul>
<li>方法 1：复制下面内容到配置文件最后面 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">" 状态栏</span><br><span class="line">set laststatus=2 " 总是显示状态栏</span><br><span class="line">highlight StatusLine cterm=bold ctermfg=yellow ctermbg=blue</span><br><span class="line">" 获取当前路径，将$HOME转化为~</span><br><span class="line">function! CurDir()</span><br><span class="line"> let curdir = substitute(getcwd(), $HOME, "~", "g")</span><br><span class="line"> return curdir</span><br><span class="line">endfunction</span><br><span class="line">set statusline=[%n]\ %f%m%r%h\ \|\ \ pwd:\ %{CurDir()}\ \ \|%=\|\ %l,%c\ %p%%\ \|\ ascii=%b,hex=%b%{((&amp;fenc==\"\")?\"\":\"\ \|\ \".&amp;fenc)}\ \|\ %{$USER}\ @\ %{hostname()}\</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>方法 2：复制下面内容到配置文件最后面 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%] "显示文件名：总行数，总的字符数</span><br><span class="line">set ruler "在编辑过程中，在右下角显示光标位置的状态行</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参数列表</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td> %{n}*</td>
<td>% 对其余的行使用高亮显示组 Usern，直到另一个 % n*。数字 n 必须从 1 到 9。用 % <em>或 %0</em> 可以恢复正常的高亮显示。</td>
</tr>
<tr>
<td>%&lt;</td>
<td> 如果状态行过长，在何处换行。缺省是在开头。</td>
</tr>
<tr>
<td>%=</td>
<td> 左对齐和右对齐项目之间的分割点。</td>
</tr>
<tr>
<td>%</td>
<td> 字符 %</td>
</tr>
<tr>
<td>%B</td>
<td> 光标下字符的十六进制形式</td>
</tr>
<tr>
<td> %F</td>
<td> 缓冲区的文件完整路径</td>
</tr>
<tr>
<td> %H</td>
<td> 如果为帮助缓冲区则显示为 HLP</td>
</tr>
<tr>
<td>%L</td>
<td> 缓冲区中的行数</td>
</tr>
<tr>
<td> %M</td>
<td> 如果缓冲区修改过则显示为 +</td>
</tr>
<tr>
<td>%N</td>
<td> 打印机页号</td>
</tr>
<tr>
<td> %O</td>
<td> 以十六进制方式显示文件中的字符偏移</td>
</tr>
<tr>
<td> %P</td>
<td> 文件中光标前的 %</td>
</tr>
<tr>
<td>%R</td>
<td> 如果缓冲区只读则为 RO</td>
</tr>
<tr>
<td>%V</td>
<td> 列数。如果与 % c 相同则为空字符串</td>
</tr>
<tr>
<td> %W</td>
<td> 如果窗口为预览窗口则为 PRV</td>
</tr>
<tr>
<td>%Y</td>
<td> 缓冲区的文件类型，如 vim</td>
</tr>
<tr>
<td>%a</td>
<td> 如果编辑多行文本，这个字行串就是 ({current} of {arguments})，例如：(5 of 18)。如果在命令行中只有一行，这个字符串为空</td>
</tr>
<tr>
<td> %b</td>
<td> 光标下的字符的十进制表示形式</td>
</tr>
<tr>
<td> %c</td>
<td> 列号</td>
</tr>
<tr>
<td> %f</td>
<td> 缓冲区的文件路径</td>
</tr>
<tr>
<td> %h</td>
<td> 如果为帮助缓冲区显示为 [Help]</td>
</tr>
<tr>
<td>%l</td>
<td> 行号</td>
</tr>
<tr>
<td> %m</td>
<td> 如果缓冲区已修改则表示为 [+]</td>
</tr>
<tr>
<td>%n</td>
<td> 缓冲区号</td>
</tr>
<tr>
<td> %o</td>
<td> 在光标前的字符数（包括光标下的字符）</td>
</tr>
<tr>
<td>%p</td>
<td> 文件中所在行的百分比</td>
</tr>
<tr>
<td> %r</td>
<td> 如果缓冲区为只读则表示为 [RO]</td>
</tr>
<tr>
<td>%t</td>
<td> 文件名 (无路径)</td>
</tr>
<tr>
<td>%v</td>
<td> 虚列号</td>
</tr>
<tr>
<td> %w</td>
<td> 如果为预览窗口则显示为 [Preview]</td>
</tr>
<tr>
<td>%y</td>
<td> 缓冲区的文件类型，如 [vim]</td>
</tr>
<tr>
<td>%{expr}</td>
<td> 表达式的结果</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 介绍和使用说明</title>
    <url>/posts/31824.html</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/people/chen-shu-yi-21"><img src="https://pic1.zhimg.com/v2-9d019104896d4a8c9b94ba1ea53eadc9_xs.jpg?source=172ae18b" alt="陈树义"></a></p>
<p><a href="https://www.zhihu.com/people/chen-shu-yi-21">陈树义</a><a href="https://www.zhihu.com/question/48510028"></a></p>
<p>广州唯品会信息科技有限公司 Java 开发工程师</p>
<p>854 人赞同了该文章</p>
<p>写博客、写文章比较多的人都知道 Markdown 是什么。</p>
<blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。—— 维基百科</p>
</blockquote>
<p>简单地说，Markdown 与 HTML 语言一样，使用一些符号就代替样式。但是它比 HTML 语言更加简单。例如我想要实现标题样式，那么我可以这么做：</p>
<p><img src="https://pic1.zhimg.com/80/v2-169597b288329de5b969b341c5fed180_720w.jpg" alt="img"></p>
<h2 id="Markdown的本质"><a href="#Markdown的本质" class="headerlink" title="Markdown的本质"></a><strong>Markdown 的本质</strong></h2><p>有些朋友会觉得，我用 Word 也可以实现同样的效果，为什么要使用 Markdown 呢？这个问题提得非常好，直戳问题本质。</p>
<p>Word 等其他文本编辑工具虽然也能实现同样的效果，但是其功能太强大了。Word 还能改变字体颜色，还可以调节字体大小。这么强大的功能可以说是 Word 的优点，但也可以说是它的缺点。</p>
<p>当功能多了，我们的注意力就会分散，我们就会去纠结：这个字体大小到底是 14 还是 16 好？我想强调这一句话，是要加粗还是标红？</p>
<p>而 Markdown 的出现让我们不需要去纠结这些问题。<strong>Markdown 的本质是让我们回归到内容本身，注重文章本身的结构，而不是样式。</strong></p>
<p>例如我们想要强调一句话，那么我们直接使用两个星号为其加粗，而不需要考虑是加粗还是标红（Markdown 中只有黑色字体，没有其他颜色字体）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-51ce4ea5fbdf997b5137476c14c18135_720w.jpg" alt="img"></p>
<p>你也不需要关心字体大小问题，因为 Markdown 中字体大小都与结构有关，无法手动设置。一级标题字体大一些，二级标题小一些。我们只需要关注哪些是一级标题，哪些是二级标题。而不需要去纠结标题字体到底要设置多大。</p>
<p><strong>Markdown 的本质是让我们回归内容本身。</strong> 当你明白这个道理的时候，你会明白为什么许多功能 Markdown 没有。</p>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><strong>Markdown 语法</strong></h2><p>原生的 Markdown 语法只包含了最基础的一些特性，例如：标题、加粗、斜体、段落、引用、超链接、图片、列表、代码块、水平分割线等。而一些自定义实现的编辑器，则有一些自定义的实现，例如：数学公式、TODO 列表等。所以当你看到有一些语法在一个编辑可以用，但到另一个编辑器又用不了的时候，那么这个语法可能就不是通用的 Markdown 原生语法了。</p>
<p>Markdown 语法非常简单，基本上只要多用几次就会了。下面简单介绍一些常用的 Markdown 语法。</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h3><p>Markdown 使用 <code>#</code> 号来表示段落。</p>
<p><img src="https://pic4.zhimg.com/80/v2-ddbecf1f0fa5a9a5e92ab996d8863d23_720w.jpg" alt="img"></p>
<h3 id="加粗、斜体、加粗斜体"><a href="#加粗、斜体、加粗斜体" class="headerlink" title="加粗、斜体、加粗斜体"></a><strong>加粗、斜体、加粗斜体</strong></h3><p>Markdown 使用一个星号表示斜体，两个星号表示加粗，三个星号表示加粗斜体。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4b35d8ad9479b746fa9ea0f45c06a6c3_720w.jpg" alt="img"></p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><strong>无序列表</strong></h3><p>使用星号或者中横线来表示无序列表，注意后面需要加个空格。</p>
<p><img src="https://pic4.zhimg.com/80/v2-dcc81e176f9d783776cc6adcd5098773_720w.jpg" alt="img"></p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><strong>有序列表</strong></h3><p>使用<code>数字+.</code> 来表示有序列表，后面同样需要价格空格。</p>
<p><img src="https://pic4.zhimg.com/80/v2-de41880f5807e6f9fdde99c2742038b7_720w.jpg" alt="img"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p>Markdown 使用 <code>&gt;</code> 符号来表示引用。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ade3a47093a0899a08074c7fc2c167c0_720w.jpg" alt="img"></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a><strong>超链接</strong></h3><p>Markdown 使用 <code>[]()</code> 来表示超链接，中括号表示链接文字，小括号表示链接地址。</p>
<p><img src="https://pic4.zhimg.com/80/v2-63cc3a2b007a0a449ac2d549d62c6277_720w.jpg" alt="img"></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h3><p>图片的样式与超链接非常相似，只需在前面加个感叹号就可以了，即用 <code>![]()</code> 表示图片。其中中括号表示图片未加载时的提示文字，小括号表示图片地址。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a059af56aadb832034c4057c0f136824_720w.jpg" alt="img"></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><p>我们使用 ` 号来表示代码块引用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-736e127b8d833dc85e0499f7f817c3a1_720w.jpg" alt="img"></p>
<h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a><strong>水平分割线</strong></h3><p>使用 <code>---</code> 来表示分割线</p>
<p><img src="https://pic1.zhimg.com/80/v2-dc4df419d95a4bd2c05d8b7ab920fed8_720w.jpg" alt="img"></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h3><p>使用一根竖线来分隔各个单元格，使用冒号来决定单元格的对齐方向。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3222f96f11294e78f28bc1f949965557_720w.jpg" alt="img"></p>
<h2 id="Markdown使用场景"><a href="#Markdown使用场景" class="headerlink" title="Markdown使用场景"></a><strong>Markdown 使用场景</strong></h2><p>目前越来越多的站点都支持了 Markdown 语法，例如：Github 等代码托管平台，简书、博客园等写作平台。因此，掌握好 Markdown 语法可以非常方便地在各个主流站点使用。</p>
<h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a><strong>编辑工具</strong></h2><p>因为 Markdown 本质上是一个纯文本，所以任何能打开纯文本的东西都可以来编辑 Markdown。但如果你想要有预览功能，那么一款顺手的编辑功能还是有必要的。</p>
<p>在 Windows 上比较不错的编辑器有：MarkdownPad、Typora。在 OSX 上比较不错的编辑器有：Mou、MacDown、MWeb。</p>
<p>而我之前使用 MouDown 和 sublime 做简单的编辑，但是笔记等的就使用印象笔记写，而要发表的文章则使用 MWeb 编写。</p>
<h2 id="兼容神器"><a href="#兼容神器" class="headerlink" title="兼容神器"></a><strong>兼容神器</strong></h2><p>使用了 Markdown 可以写出条理非常清晰的文章，文章结构特别清晰。但是对于一些老编辑器而言，例如：ATLASSIAN 的 WIKI 对于 Markdown 的支持就很弱。</p>
<p>那么怎么办呢？</p>
<p>其实很简单，因为老的编辑器基本都支持 HTML，所以我们可以将 Markdown 渲染后的 HTML 复制到老编辑器。</p>
<p>我一般是在本地写好 Markdown 文章，之后直接复制到一个 Markdown 编辑器，然后复制对应的 HTML 文本到老编辑器中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-394d2ecadb292765ac1d810cbe5672b3_720w.jpg" alt="img"></p>
<p>之后点击一下蓝色的复制按钮，就可以复制渲染后的 HTML 文本，最后直接粘贴到老编辑器中就可以了。我用的 Markdown 编辑器是：**<a href="https://link.zhihu.com/?target=https://mdnice.github.io/">https://mdnice.github.io/</a>**，样式非常漂亮。</p>
<h2 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a><strong>进阶应用</strong></h2><p>当你学会使用 Markdown 之后，你会发现 Markdown 还有更多好玩的地方。例如：开源的 gitbook 就可以教你把一个个 Markdown 文件组织起来，弄成一本电子书。</p>
<p><img src="https://pic2.zhimg.com/80/v2-cdc7ada790a4473145b3c1207a3f8495_720w.jpg" alt="img"></p>
<p>具体如何操作，可以参考这里：**<a href="https://link.zhihu.com/?target=https://github.com/chenyurong/gitbook-notebook">https://github.com/chenyurong/g</a>**</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 学习笔记 1</title>
    <url>/posts/30815.html</url>
    <content><![CDATA[<h1 id="markdown学习笔记1"><a href="#markdown学习笔记1" class="headerlink" title="markdown学习笔记1"></a>markdown 学习笔记 1</h1><h2 id="1、markdown是什么？"><a href="#1、markdown是什么？" class="headerlink" title="1、markdown是什么？"></a>1、markdown 是什么？</h2><ul>
<li>Markdown 是一种轻量级标记语言，2004 由约翰・格鲁伯（英语：John Gruber）创建，通过使用易读易写的纯文本格式编写文档，让作者把更多精力放在文章内容，不再为排版浪费时间。Markdown 文档可以导出为 HTML、Word、图像、PDF、Epub 等多种格式。</li>
</ul>
<h2 id="2、标题、换行、字体"><a href="#2、标题、换行、字体" class="headerlink" title="2、标题、换行、字体"></a>2、标题、换行、字体</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul>
<li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</li>
</ul>
<blockquote>
<p>#一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题  </p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>段落的换行是使用两个以上空格再加上回车。</li>
<li>或者使用一个空行来表示新的段落段落。</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>* 斜体文本 *<br>** 粗体文本 **<br>*** 粗斜体文本 ***  </p>
</blockquote>
<blockquote>
<p><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em>  </p>
</blockquote>
<h2 id="3、分割线、删除线、下划线"><a href="#3、分割线、删除线、下划线" class="headerlink" title="3、分割线、删除线、下划线"></a>3、分割线、删除线、下划线</h2><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><ul>
<li>在一行中用三个以上的星号、减号、底线来建立一个分隔线<blockquote>
<p>-–<br>分割线</p>
</blockquote>
</li>
</ul>
<blockquote>
<hr>
<p>分割线  </p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul>
<li>在文字的两端加上两个波浪线表示删除线</li>
</ul>
<blockquote>
<p>~~ 删除线～～</p>
</blockquote>
<blockquote>
<p><del>删除线</del>  </p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><ul>
<li>通过 HTML 的 &lt;u&gt; &lt;/u &gt; 标签来表示下划线<blockquote>
<p>&lt;u&gt; 下划线 &lt;/u&gt;</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><u> 下划线 </u></p>
</blockquote>
<h2 id="4、有序列表、无序列表、列表嵌套"><a href="#4、有序列表、无序列表、列表嵌套" class="headerlink" title="4、有序列表、无序列表、列表嵌套"></a>4、有序列表、无序列表、列表嵌套</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>无序列表使用星号 *、加号 + 或是减号 -</li>
</ul>
<blockquote>
<p>- 第一项<br>- 第二项<br>- 第三项  </p>
</blockquote>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul>
<li>有序列表使用数字并加上点号 . <blockquote>
<p>1. 第一项<br>2. 第二项<br>3. 第三项</p>
</blockquote>
</li>
</ul>
<blockquote>
<ol>
<li>第一项  </li>
<li>第二项  </li>
<li>第三项</li>
</ol>
</blockquote>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><ul>
<li>在子列表中的选项前面添加四个空格</li>
</ul>
<blockquote>
<p>1. 第一项：<br>     - 第一项嵌套的第一个元素<br>     - 第一项嵌套的第二个元素<br>2. 第二项：<br>     - 第二项嵌套的第一个元素<br>     - 第二项嵌套的第二个元素  </p>
</blockquote>
<blockquote>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="6、区块显示"><a href="#6、区块显示" class="headerlink" title="6、区块显示"></a>6、区块显示</h2><h3 id="普通区块"><a href="#普通区块" class="headerlink" title="普通区块"></a>普通区块</h3><ul>
<li>区块引用是在段落开头使用 &gt; 符号，后跟空格。<blockquote>
<p>&gt; 第一行<br>&gt; 第二行<br>&gt; 第三行</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>第一行<br>第二行<br>第三行  </p>
</blockquote>
<h3 id="嵌套区块"><a href="#嵌套区块" class="headerlink" title="嵌套区块"></a>嵌套区块</h3><ul>
<li>区块可以嵌套，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推。<blockquote>
<p>&gt; 第一行<br>&gt;&gt; 第二行<br>&gt;&gt;&gt; 第三行</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>第一行  </p>
<blockquote>
<p>第二行  </p>
<blockquote>
<p>第三行  </p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="区块加入列表"><a href="#区块加入列表" class="headerlink" title="区块加入列表"></a>区块加入列表</h3><blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h3 id="列表加入区块"><a href="#列表加入区块" class="headerlink" title="列表加入区块"></a>列表加入区块</h3><ul>
<li>在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</li>
<li>第一项<blockquote>
<p>第一行<br>第二行</p>
</blockquote>
</li>
<li>第二项<blockquote>
<p>第一行<br>第二行</p>
</blockquote>
</li>
</ul>
<h2 id="7、代码显示"><a href="#7、代码显示" class="headerlink" title="7、代码显示"></a>7、代码显示</h2><ul>
<li>代码可以用反引号把它包起来 `<blockquote>
<p>`printf(“Hello World ! \n”);`</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>printf("Hello World ! \n");</code></p>
</blockquote>
<ul>
<li>以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</li>
</ul>
<blockquote>
<p>```c<br>printf(“Hello World ! \n”);<br>```</p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World ! \n"</span>);</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<ul>
<li>用区块显示代码，代码区块使用 4 个空格或者一个制表符（Tab 键）  <blockquote>
<p>for(int i=0;i&lt;100;i++)<br>  {<br>    printf(“Hello World ! \n”);<br>  }</p>
</blockquote>
</li>
</ul>
<h2 id="8、添加链接"><a href="#8、添加链接" class="headerlink" title="8、添加链接"></a>8、添加链接</h2><ul>
<li>[链接名称](链接地址)</li>
</ul>
<blockquote>
<p>[跑跑的小屋](liupaopao.top)  </p>
</blockquote>
<blockquote>
<p><a href="liupaopao.top">跑跑的小屋</a></p>
</blockquote>
<ul>
<li> &lt;链接地址&gt;</li>
</ul>
<blockquote>
<p>&lt;<a href="https://liupaopao.top>">https://liupaopao.top&gt;</a> </p>
</blockquote>
<blockquote>
<p><a href="https://liupaopao.top/">https://liupaopao.top</a> </p>
</blockquote>
<h2 id="9、添加图片"><a href="#9、添加图片" class="headerlink" title="9、添加图片"></a>9、添加图片</h2><ul>
<li>要添加图片，首先添加感叹号（!），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。</li>
</ul>
<blockquote>
<p>![alt 属性文本](图片地址)<br>![alt 属性文本](图片地址 “可选标题”)</p>
</blockquote>
<blockquote>
<p>![百度 logo](<a href="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png">https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png</a> “baidu”)</p>
</blockquote>
<blockquote>
<p><img src="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png" alt="百度logo" title="baidu"></p>
</blockquote>
<h2 id="10、添加表格"><a href="#10、添加表格" class="headerlink" title="10、添加表格"></a>10、添加表格</h2><ul>
<li>使用三个或更多个连字符（—）来为每个列创建表头，并使用管道符（|）来分隔每个列。</li>
</ul>
<blockquote>
<p>|  表头 | 表头  |<br>|  —  | —  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |  </p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>可以设置表格的对齐方式：</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td> -:</td>
<td> 设置内容和标题栏居右对齐</td>
</tr>
<tr>
<td>:-</td>
<td> 设置内容和标题栏居左对齐</td>
</tr>
<tr>
<td>:-:</td>
<td> 设置内容和标题栏居中对齐</td>
</tr>
</tbody></table>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 1：单片机最小系统设计</title>
    <url>/posts/56027b49.html</url>
    <content><![CDATA[<h2 id="1、单片机概念"><a href="#1、单片机概念" class="headerlink" title="1、单片机概念"></a>1、单片机概念</h2><p>单片机：一种集成电路芯片，是单片微型计算机的简称。单片机由微处理器 CPU、存储器 ROM 和 RAM、输入输出 IO 接口电路组成，构成了一个既小巧又完善的计算机硬件系统。</p>
<h2 id="2、单片机用途"><a href="#2、单片机用途" class="headerlink" title="2、单片机用途"></a>2、单片机用途</h2><p>（1）智能仪器仪表，如示波器、万用表</p>
<p>（2）机电一体化产品，如机器人、数控机床、打印机</p>
<p>（3）实时工业控制，如电机转速控制</p>
<p>（4）家用电器，如冰箱、洗衣机</p>
<h2 id="3、单片机应用系统"><a href="#3、单片机应用系统" class="headerlink" title="3、单片机应用系统"></a>3、单片机应用系统</h2><p>单片机应用系统 = 软件 + 硬件（单片机 + 接口电路及外部设备）</p>
<p>单片机应用系统是以单片机为核心，配以输入、输出、显示、控制等外围电路和相应的控制、驱动软件，能完成一种或多种功能的使用系统。</p>
<h2 id="4、MCS-51系列单片机组成结构"><a href="#4、MCS-51系列单片机组成结构" class="headerlink" title="4、MCS-51系列单片机组成结构"></a>4、MCS-51 系列单片机组成结构</h2><p>（1）中央处理器 - CPU：8 位数据宽度，能同时处理 8 位二进制数据或代码。</p>
<p>（2）数据存储器 - RAM：8051 单片机有 128B 数据存储器和 21 个专用寄存器，用户能使用的只有 128B，专用寄存器通常用于存放控制指令数据，不能存放用户数据。</p>
<p>（3）程序存储器 - ROM：8051 单片机有 4KB 程序存储器，掉电后数据不会丢失。</p>
<p>（4）定时 / 计数器：8051 单片机有 2 个 16 位的可编程定时 / 计数器。</p>
<p>（5）并行 I/O 口：8051 单片机有 4 个 8 位的并行 I/O 口（P0/P1/P2/P3）。</p>
<p>（6）全双工串行口：8051 单片机有一个全双工异步串行通信口。</p>
<p>（7）中断系统：8051 单片机有 5 个中断源（2 个外中断、2 个定时 / 计数器中断和 1 个串行中断）。</p>
<p>（8）时钟电路：8051 单片机有时钟电路，只需外接晶振和震荡电容，用于产生时序脉冲供整个单片机运行。</p>
<h2 id="5、MCS-51系列单片机引脚介绍"><a href="#5、MCS-51系列单片机引脚介绍" class="headerlink" title="5、MCS-51系列单片机引脚介绍"></a>5、MCS-51 系列单片机引脚介绍</h2><p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221184228988-605752706.png" alt="img"></p>
<p> （1）电源：40 引脚 Vcc 接电源 + 5V，20 引脚 GND 接地。</p>
<p>（2）时钟：19 引脚 XTAL1 是内部振荡电路输入端。当采用外部振荡器时，此引脚接地。18 引脚 XTAL2 是内部振荡电路输出端。当采用外部振荡器时，此引脚接外部振荡源。</p>
<p>（3）控制总线：</p>
<p>（4）I/O 线：</p>
<p>P0 口（32~39 引脚）双向数据总线和低 8 位地址总线。</p>
<p>P1 口（1~8 引脚）准双向输入 / 输出口。</p>
<p>P2 口（21~28 引脚）准双向输入 / 输出口，访问外部存储器时用作高 8 位地址总线。</p>
<p>P3 口（10~17 引脚）准双向输入 / 输出口。P3 口还具第二功能。</p>
<p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221194123546-1287876210.png" alt="img"></p>
<h2 id="6、MCS-51系列单片机存储器结构"><a href="#6、MCS-51系列单片机存储器结构" class="headerlink" title="6、MCS-51系列单片机存储器结构"></a>6、MCS-51 系列单片机存储器结构</h2><p>程序存储器：存放程序和表格常数。</p>
<p>数据存储器：存放程序运行所需要的参数和运行结果。</p>
<p>从物理存储介质来看，MCS-51 系列单片机共有 4 种存储空间：片内程序存储器、片外程序存储器、片内数据存储器和片外数据存储器。</p>
<p>从逻辑地址空间来看，MCS-51 系列单片机可分为 3 部分：程序存储器、片外数据存储器和片内数据存储器。</p>
<p>单片机复位后，程序计数器 PC 为 0000H，系统从 0000H 单元开始取指令并执行。</p>
<h2 id="7、单片机最小系统电路"><a href="#7、单片机最小系统电路" class="headerlink" title="7、单片机最小系统电路"></a>7、单片机最小系统电路</h2><p>单片机最小系统电路是指单片机工作不可或缺的最基本连接电路。</p>
<p><strong>单片机最小系统电路包括单片机芯片、电源电路、时钟电路和复位电路四部分。</strong></p>
<p>（1）时钟电路。单片机内部有一个高增益反向放大器，其频率范围为 1.2<del>12MHz，XTAL1 和 XTAL2 分别为放大器的输入端和输出端。XTAL1 和 XTAL2 外接定时元件就能构成自激振荡电路。定时元件通常采用石英晶体和电容组成的并联谐振电路。电容 C1 和 C2 主要起频率微调作用，电容取值 30</del>40pF。</p>
<p><strong>振荡周期：振荡源的周期，若内部产生，则为石英晶体的振荡周期。</strong></p>
<p><strong>时钟周期：振荡周期的两倍。</strong></p>
<p><strong>机器周期：等于 6 个时钟周期，12 个振荡周期。</strong></p>
<p><strong>指令周期：完成一条操作所需要的全部时间，每条指令的执行时间都是一个或几个机器周期组成。</strong></p>
<p>例题：单片机采用内部时钟，晶振频率 f 为 6MHz，则：</p>
<p>振荡周期 = 1/6 MHz=1/6 us</p>
<p>时钟周期 = 1/3 us</p>
<p>机器周期 = 2 us</p>
<p>指令周期 = 机器周期的 1<del>4 倍 = 2</del>8us</p>
<p>（2）复位电路</p>
<p>主要分为两种：上电复位和按键复位电路。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>解决 Ubuntu 虚拟机网卡消失无法上网问题</title>
    <url>/posts/65e2dbd7.html</url>
    <content><![CDATA[<p>通过 VMware 打开 Ubuntu 虚拟机后，偶尔会发生识别不到网卡，进而无法上网问题。<code>ifconfig</code> 命令也查不到网口，只查到一个 <code>lo</code> 本地环回网络，之前的 <code>ens33</code> 网口信息消失不见了。网上一系列教程都是让该 VMware 网络配置之类的，根本没用，浪费时间和精力。</p>
<p>终极解决方法非常简单，只是一条设置 DHCP 自动获取 IP 的命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo dhclient ens33</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p><code>dhclient</code> 命令是 “DHCP client” 的缩写，是用于动态获取或释放 IP 地址。可以通过 <code>dhclient</code> 命令重新设置下网卡模式，使得 DHCP 自动获取刷新下。静态模式的网卡不会主动向服务器获取 IP 地址等网卡信息。</p>
<p>然后，<code>ifconfig</code> 命令就显示出来 ens33 网口信息了，IP 地址出来了：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ ifconfig </span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.52.129  netmask 255.255.255.0  broadcast 192.168.52.255</span><br><span class="line">        inet6 fe80::20c:29ff:fef5:e52f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:f5:e5:2f  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 572  bytes 42393 (42.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 258  bytes 33131 (33.1 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 2421  bytes 176334 (176.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2421  bytes 176334 (176.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记 -《编码：隐匿在计算机软硬件背后的语言》</title>
    <url>/posts/36fffd2c.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202112161937656.jpg" alt="书封面"></p>
<h3 id="第1章-至密亲友"><a href="#第1章-至密亲友" class="headerlink" title="第1章 至密亲友"></a>第 1 章 至密亲友</h3><p>编码：一种用来在机器和人之间传递信息的方式，编码就是交流。可以通过不同事物的组合表示出特定的信息，最常见的是通过两种事物的组合，如：</p>
<ul>
<li>手电筒的<strong>快闪</strong>和<strong>慢闪</strong>组合</li>
<li>摩尔斯电码的<strong>点</strong>和<strong>划</strong>组合</li>
</ul>
<h3 id="第2章-编码与组合"><a href="#第2章-编码与组合" class="headerlink" title="第2章 编码与组合"></a>第 2 章 编码与组合</h3><p>通过<strong>点</strong>和<strong>划</strong>组合而成的摩尔斯电码表：<br><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202112161954230.png" alt="image-20211216195448024"><br>这样就可以表示不同的字母，达到信息传递的作用。摩尔斯码又称作二进制码，因为其组合方式</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>底层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯服务器重装 UOS 系统 + 搭建本地仓库源</title>
    <url>/posts/e8c622c9.html</url>
    <content><![CDATA[<h1 id="龙芯服务器重装UOS系统-搭建本地仓库源"><a href="#龙芯服务器重装UOS系统-搭建本地仓库源" class="headerlink" title="龙芯服务器重装UOS系统+搭建本地仓库源"></a>龙芯服务器重装 UOS 系统 + 搭建本地仓库源</h1><h2 id="一、安装mips64el架构UOS系统"><a href="#一、安装mips64el架构UOS系统" class="headerlink" title="一、安装mips64el架构UOS系统"></a>一、安装 mips64el 架构 UOS 系统</h2><p>1、进入统信 UOS 官网 —&gt; 生态社区 —&gt; 资源中心 —&gt; 镜像下载页面，选择服务器版，下载 MIPS64 镜像（直达网址：<a href="https://www.chinauos.com/resource/download-server%EF%BC%89%E3%80%82">https://www.chinauos.com/resource/download-server）。</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110260942455.png" alt="img"></p>
<p>2、通过 UltraISO 软件将下载的 ISO 刻录到 U 盘里，制作一个 U 盘启动盘。</p>
<p>3、修改龙芯服务器 BIOS 启动项，把 U 盘启动改成第一启动项就进入了系统安装环境，大约要等半小时才能安装成功。</p>
<h2 id="二、配置本地仓库源"><a href="#二、配置本地仓库源" class="headerlink" title="二、配置本地仓库源"></a>二、配置本地仓库源</h2><p>如何使用统信 UOS 镜像搭建本地源？（直达网址：<a href="https://www.xtuos.com/817.html%EF%BC%89">https://www.xtuos.com/817.html）</a></p>
<p>1、将对应版本的 server iso 镜像挂在到 /mnt 目录下</p>
<p><code>sudo mount uniontechos-server-20-1040d-mips64el.iso /mnt</code></p>
<p>2、修改源地址。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"></span><br><span class="line">deb [trusted=yes] file:///mnt eagle main</span><br></pre></td></tr></tbody></table></figure>

<p>（我这里根据镜像信息，把 eagle 对应改成了 fou：deb [trusted=yes] file:///mnt fou main）</p>
<p>3、更新源。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">apt update //注意如果宿主机是桌面版需要关闭商店源和打印机源，不然update会报错</span><br></pre></td></tr></tbody></table></figure>
<p>（我这里服务器版也必须关闭商店源和打印机源：进入 /etc/apt/source.list.d，打开 appstore.list 和 printer.list 两个文件，注释掉里面的在线仓库网址）</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Typora+Picgo+Gitee 构建网络图床笔记</title>
    <url>/posts/80f1815e.html</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>之前一直在 Typora 上记录自己的笔记，但是发现 markdown 格式的笔记在插入图片时，仅能采用两种方法：1）在线图床，2）本地路径，即图片并不是像 Word 那样集成在文档内的，因此经过一番研究，发现了最新版的 Typora 已经支持在线图床功能，遂写此篇教程帮助后人构建自己的在线图床 markdown 笔记。</p>
<h2 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a><strong>所需软件</strong></h2><p>typora</p>
<p><a href="https://link.zhihu.com/?target=https://typora.io/">https://typora.io/</a></p>
<p>picgo</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p>
<p>建议选择 2.2.2 正式版本，beta 版本可能会存在不稳定的风险。</p>
<p><img src="https://pic3.zhimg.com/80/v2-be88c425ba401a71e9c91dca74f0d262_720w.jpg" alt="img"></p>
<p>Gitee</p>
<p>由于国内连接 github 时网络偶尔存在不稳定的情况，于是采用了 gitee 作为 github 图床的替代，但整体教程是一样的</p>
<p><a href="https://link.zhihu.com/?target=https://gitee.com/">https://gitee.com/</a></p>
<p><img src="https://pic3.zhimg.com/80/v2-daba73811b87533f8f032169d3d11d9a_720w.png" alt="img"></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a><strong>具体操作</strong></h2><p>主要是分为两部分操作，第一部分是 Typora 的配置，第二部分是 Picgo+Gitee 的在线图床配置</p>
<h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a><strong>Typora 配置</strong></h3><p>打开 Typora 后，点击菜单栏 - 文件 - 偏好设置</p>
<p>找到其中的 “图像” 设置，将其设置为如下内容</p>
<p><img src="https://pic3.zhimg.com/80/v2-f374bec8d90d87c2f7683c1133064166_720w.jpg" alt="img"></p>
<p>1）<strong>插入图片时… <strong>下边的选择框内选择</strong>上传图片</strong></p>
<p>2）勾选上 “<strong>对本地位置的图片应用上述规则</strong>”</p>
<p>3）上传服务选择 <strong>PicGo(app)</strong></p>
<p>4）将 <strong>PicGo 路径</strong>项设置为本地 PicGo 的安装路径</p>
<p>这样，我们就把 Typora 配置好了，下面我们进行 PicGo+Gitee 的网络图床构建</p>
<h3 id="网络图床配置"><a href="#网络图床配置" class="headerlink" title="网络图床配置"></a><strong>网络图床配置</strong></h3><p>首先，安装好 PicGo 之后，我们需要给 PicGo 配置插件以支持 Gitee 图床</p>
<p><strong>注意</strong>：你必须安装 <a href="https://link.zhihu.com/?target=https://nodejs.org/en/">Node.js</a> 之后才能安装 PicGo 的插件，因为 PicGo 要使用 <code>npm</code> 来安装插件。</p>
<p>安装好 Nodejs 后，点开左边的<strong>插件设置</strong>一栏，在输入框内输入 “github plus”，如下</p>
<p><img src="https://pic1.zhimg.com/80/v2-270b499aeadae15d014215b32b1204c8_720w.jpg" alt="img"></p>
<p>点击安装此插件，之后左侧选项栏<strong>图床设置</strong>会多一个 <strong>githubplus</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-1fd1e0c2ef8c48f1d85a5a04b8566714_720w.png" alt="img"></p>
<p>接下来我们配置 Gitee 仓库以存储图片</p>
<p>1）进入 <a href="https://link.zhihu.com/?target=https://gitee.com/">https://gitee.com/</a>，没有账号的话，先注册账号，注册以后登录，新建一个<strong>公开仓库</strong>，名字为 picgo（可以自己起其他名字）</p>
<p>2）点击右上角，进入<strong>设置</strong>，在左侧的<strong>安全设置 - 私人令牌</strong>处生成新令牌。（注意：生成的新令牌只会显示一次，一定要保存好！！！）</p>
<p>我们需要做的如下：</p>
<p>1）回到 picgo，按照如下进行设置</p>
<p><img src="https://pic3.zhimg.com/80/v2-dceba8a3986c7df4dbc3f8cb1e8ca60e_720w.jpg" alt="img"></p>
<p>其中的 repo 为 <strong>UserName / 仓库名称</strong> 格式</p>
<p>branch 填入 master</p>
<p>Token 为刚才在 Gitee 生成的私人令牌，粘贴到这里就行</p>
<p>path 为仓库下用于存储图片的路径，这个可以自行选择</p>
<p>最下边的 origin 部分选择 gitee（默认是 github）</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a><strong>结束</strong></h2><p>经过上述操作，我们就把 typora+picgo+gitee 成功配置好了，之后当我们将本地的图片粘贴到 markdown 文档内的时候，typora 会自动将图片上传到刚才我们配置好的 gitee 仓库内，并自动把 markdown 文档内的本地路径转化为 gitee 的图片外链，便于我们以后进行多端访问文档内的图片。</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人免费稳定图床 GitHub+jsDelivr+PicGo+Typora</title>
    <url>/posts/4169710f.html</url>
    <content><![CDATA[<h1 id="搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora"><a href="#搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora" class="headerlink" title="搭建个人免费稳定图床GitHub+jsDelivr+PicGo+Typora"></a>搭建个人免费稳定图床 GitHub+jsDelivr+PicGo+Typora</h1><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104520.gif" alt="IMG_256"></p>
<p>搭建完个人博客以后，写文章的时候就不可避免需要插入图片，于是就需要使用图床工具把本地图片转换成网络图片再把图片链接分享出来。市面上的图床工具非常多，但很多都需要收费，有些免费的也存在着不稳定的风险。现在有一种基于 GitHub 和 jsDelivr 加速的免费图床。PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具，支持多个图床进行使用，其中当然包括我们现在使用的 GitHub 图床了，它同时支持 Windows、macOS、Linux 平台。GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，也不用担心速度和容量问题，而且完全开源免费，再结合 Typora 编辑器，书写 markdown 格式文章，简直效率神器，快来根据下面教程搭建个人的免费稳定图床吧！ </p>
<h2 id="一、新建GitHub图床仓库"><a href="#一、新建GitHub图床仓库" class="headerlink" title="一、新建GitHub图床仓库"></a>一、新建 GitHub 图床仓库</h2><ol>
<li>登录 GitHub 账户，没有的话就注册下，然后新建 GitHub 仓库。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104523.jpg" alt="img"></p>
<p>2、填写仓库名【CDN1】，勾选上【Public】和【Add a README file】，最后点击创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107307.jpg" alt="Snipaste_2021-10-24_15-30-47"></p>
<p>3、创建 GitHub 中的 Token (令牌)</p>
<p>点击右上角头像，选中头像列表中的【Settings】，进入【Settings】，点击【Developer Settings】，再点击【<a href="https://github.com/settings/tokens">Personal access tokens</a>】，接着点击【Generate new token】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107067.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107725.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107888.jpg" alt="img"></p>
<p>在 Note 中取一个名字，选中 repo 这个框过后直接点击完成（Generate token）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107110.jpg" alt="img"></p>
<p>最后生成 token，记住这个令牌一定要复制保存，建议保存到记事本里，如果没有保存的需要删除重来一遍。</p>
<h2 id="二、配置PicGo"><a href="#二、配置PicGo" class="headerlink" title="二、配置PicGo"></a>二、配置 PicGo</h2><p>1、安装 PicGo</p>
<p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，根据默认勾选安装即可。</p>
<p>2、打开 PicGo，配置图床</p>
<p>设定仓库名：按照【GitHub 用户名 / 图床仓库名】的格式填写</p>
<p>设定分支名：【main】</p>
<p>设定 Token：粘贴 GitHub 生成的【Token】</p>
<p>指定存储路径：默认路径为【img/】，图片将会储存在此文件夹中，而我改成了 img/2021/。</p>
<p>设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照【自定义域名 + 上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%91">https://cdn.jsdelivr.net/gh/ 用户名 / 图床仓库名】</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104577.jpg" alt="2"></p>
<p>3、进入 PicGo 设置，打开时间戳重命名，避免因图片重名而导致上传失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311345102.jpg" alt="3"></p>
<p>4、可以打开上传区测试一下，选择 URL 的图片链接格式，上传完图片后复制链接，直接再浏览器打开就能看到了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104927.jpg" alt="4"></p>
<h2 id="三、配置typora"><a href="#三、配置typora" class="headerlink" title="三、配置typora"></a>三、配置 typora</h2><p>1、下载 typora：<a href="https://typora.io/">https://typora.io/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104776.jpeg" alt="111"></p>
<p>2、打开【文件】中【偏好设置】，选择【图像】，根据图片中配置进行勾选。最后再找到 PicGo 软件的安装位置，可以上传验证测试下，默认会上传 typora 图标。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104208.jpg" alt="01"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104756.jpg" alt="02"><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104944.jpg" alt="03"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104504.jpg" alt="04"></p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 主题添加霞鹜文楷字体</title>
    <url>/posts/f775e49.html</url>
    <content><![CDATA[<p>最近发现了一款好看的开源字体：<strong>霞鹜文楷字体 </strong> <a href="https://github.com/lxgw/LxgwWenKai">https://github.com/lxgw/LxgwWenKai</a>，于是打算用到我的 Hexo-NexT 博客主题里面，这里记录一下修改过程。</p>
<span id="more"></span>

<p>效果图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202308251056769.png" alt="霞鹜文楷字体"></p>
<h2 id="新建source-data-head-njk"><a href="#新建source-data-head-njk" class="headerlink" title="新建source/_data/head.njk"></a>新建 source/_data/head.njk</h2><p>添加内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css" /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>目前最新版本为 1.7.0，可以点开网址 <a href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/">https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/</a> 查询下最新版本。</p>
<h2 id="修改-config-next-yml"><a href="#修改-config-next-yml" class="headerlink" title="修改_config.next.yml"></a>修改_config.next.yml</h2><p>修改内容 1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  head: source/_data/head.njk</span><br></pre></td></tr></tbody></table></figure>

<p>修改内容 2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Font Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.googleapis.com</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: false</span><br><span class="line">    family: "LXGW WenKai"</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings for posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings for &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: false</span><br><span class="line">    family: "LXGW WenKai Mono, Source Code Pro"</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 主题美化修改记录（一）</title>
    <url>/posts/d87f7e0c.html</url>
    <content><![CDATA[<p>基于 NexT 主题 V8.10.1，第一波美化修改记录。</p>
<p>主要修改为：</p>
<ul>
<li>添加文章结束分割线</li>
<li>添加上吊猫个性化回到顶部</li>
<li>添加畅言评论系统</li>
</ul>
<span id="more"></span>

<h2 id="git-status-结果"><a href="#git-status-结果" class="headerlink" title="git status 结果"></a>git status 结果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Changed files:</span><br><span class="line">	modified:   layout/_macro/post.njk</span><br><span class="line">	modified:   layout/_partials/footer.njk</span><br><span class="line">	modified:   layout/_partials/page/tags.njk</span><br><span class="line">	modified:   source/css/_common/components/back-to-top.styl</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">	layout/_macro/passage-end-tag.njk</span><br></pre></td></tr></tbody></table></figure>
<p>新文件 layout/_macro/passage-end-tag.njk 内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    {% if not is_index %}</span><br><span class="line">        &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------     本文结束　&lt;i class="fa fa-heartbeat"&gt;&lt;/i&gt;　步履不止     -------------&lt;/div&gt;</span><br><span class="line">    {% endif %}</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="git-diff-结果"><a href="#git-diff-结果" class="headerlink" title="git diff 结果"></a>git diff 结果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">diff --git a/layout/_macro/post.njk b/layout/_macro/post.njk</span><br><span class="line">index 27851de..6c994b4 100644</span><br><span class="line">--- a/layout/_macro/post.njk</span><br><span class="line">+++ b/layout/_macro/post.njk</span><br><span class="line">@@ -102,6 +102,12 @@</span><br><span class="line">       {{ partial('_partials/post/post-related.njk') }}</span><br><span class="line">     {%- endif %}</span><br><span class="line"> </span><br><span class="line">+&lt;div&gt;</span><br><span class="line">+  {% if not is_index %}</span><br><span class="line">+    {% include 'passage-end-tag.njk' %}</span><br><span class="line">+  {% endif %}</span><br><span class="line">+&lt;/div&gt;</span><br><span class="line">+</span><br><span class="line">     &lt;footer class="post-footer"&gt;</span><br><span class="line">       {%- if is_index %}</span><br><span class="line">         &lt;div class="post-eof"&gt;&lt;/div&gt;</span><br><span class="line">diff --git a/layout/_partials/footer.njk b/layout/_partials/footer.njk</span><br><span class="line">index d39307a..a060418 100644</span><br><span class="line">--- a/layout/_partials/footer.njk</span><br><span class="line">+++ b/layout/_partials/footer.njk</span><br><span class="line">@@ -19,7 +19,7 @@</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line">   &lt;span class="author" itemprop="copyrightHolder"&gt;{{ theme.footer.copyright or author }}&lt;/span&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">-</span><br><span class="line">+&lt;!--</span><br><span class="line"> {%- if config.symbols_count_time.total_symbols or config.symbols_count_time.total_time %}</span><br><span class="line"> &lt;div class="wordcount"&gt;</span><br><span class="line">   {%- if config.symbols_count_time.total_symbols %}</span><br><span class="line">@@ -47,7 +47,7 @@</span><br><span class="line">   {%- endif %}</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> {%- endif %}</span><br><span class="line">-</span><br><span class="line">+--&gt;</span><br><span class="line"> {%- if theme.busuanzi_count.enable %}</span><br><span class="line"> &lt;div class="busuanzi-count"&gt;</span><br><span class="line">   {%- if theme.busuanzi_count.total_visitors %}</span><br><span class="line">@@ -73,14 +73,14 @@</span><br><span class="line">   {%- endif %}</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> {%- endif %}</span><br><span class="line">-</span><br><span class="line">+&lt;!--</span><br><span class="line"> {%- if theme.footer.powered %}</span><br><span class="line">   &lt;div class="powered-by"&gt;</span><br><span class="line">     {%- set next_site = 'https://theme-next.js.org' if theme.scheme === 'Gemini' else 'https://theme-next.js.org/' + theme.scheme | lower + '/' %}</span><br><span class="line">     {{- __('footer.powered', next_url('https://hexo.io', 'Hexo') + ' &amp; ' + next_url(next_site, 'NexT.' + theme.scheme)) }}</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"> {%- endif %}</span><br><span class="line">-</span><br><span class="line">+--&gt;</span><br><span class="line"> {%- if theme.add_this_id %}</span><br><span class="line">   &lt;div class="addthis_inline_share_toolbox"&gt;</span><br><span class="line">     &lt;script src="//s7.addthis.com/js/300/addthis_widget.js#pubid={{ theme.add_this_id }}" async="async"&gt;&lt;/script&gt;</span><br><span class="line">diff --git a/layout/_partials/page/tags.njk b/layout/_partials/page/tags.njk</span><br><span class="line">index c6e55cc..7cbc75c 100644</span><br><span class="line">--- a/layout/_partials/page/tags.njk</span><br><span class="line">+++ b/layout/_partials/page/tags.njk</span><br><span class="line">@@ -13,4 +13,4 @@</span><br><span class="line">       })</span><br><span class="line">     }}</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">-&lt;/div&gt;</span><br><span class="line">+&lt;/div&gt;</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/source/css/_common/components/back-to-top.styl b/source/css/_common/components/back-to-top.styl</span><br><span class="line">index d1c9152..89af070 100644</span><br><span class="line">--- a/source/css/_common/components/back-to-top.styl</span><br><span class="line">+++ b/source/css/_common/components/back-to-top.styl</span><br><span class="line">@@ -43,3 +43,26 @@ if (hexo-config('back2top.enable')) {</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line">+</span><br><span class="line">+/* 这里已经注释掉，若想生效取消注释即可，其他不用设置</span><br><span class="line">+//自定义回到顶部样式-上吊猫</span><br><span class="line">+.back-to-top {</span><br><span class="line">+  right: 60px;</span><br><span class="line">+  width: 70px;  //图片素材宽度</span><br><span class="line">+  height: 900px;  //图片素材高度</span><br><span class="line">+  top: -900px;</span><br><span class="line">+  bottom: unset;</span><br><span class="line">+  transition: all .5s ease-in-out;</span><br><span class="line">+  background: url("/images/scroll.png");</span><br><span class="line">+</span><br><span class="line">+  //隐藏箭头图标</span><br><span class="line">+  &gt; i {</span><br><span class="line">+    display: none;</span><br><span class="line">+  }</span><br><span class="line">+</span><br><span class="line">+  &amp;.back-to-top-on {</span><br><span class="line">+    bottom: unset;</span><br><span class="line">+    top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;</span><br><span class="line">+  }</span><br><span class="line">+}</span><br><span class="line">+*/</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></tbody></table></figure>

<h2 id="config-yml-修改情况"><a href="#config-yml-修改情况" class="headerlink" title="_config.yml 修改情况"></a>_config.yml 修改情况</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">24c24</span><br><span class="line">&lt;   #sidebar: source/_data/sidebar.njk</span><br><span class="line">---</span><br><span class="line">&gt;   sidebar: source/_data/sidebar.njk</span><br><span class="line">53,54c53,54</span><br><span class="line">&lt;   small: /images/favicon-16x16-next.png</span><br><span class="line">&lt;   medium: /images/favicon-32x32-next.png</span><br><span class="line">---</span><br><span class="line">&gt;   small: /images/favicon-50.png # favicon-16x16-next.png</span><br><span class="line">&gt;   medium: /images/favicon-100.png # favicon-32x32-next.png</span><br><span class="line">98,102c98,102</span><br><span class="line">&lt;   #home: / || fa fa-home</span><br><span class="line">&lt;   #about: /about/ || fa fa-user</span><br><span class="line">&lt;   #tags: /tags/ || fa fa-tags</span><br><span class="line">&lt;   #categories: /categories/ || fa fa-th</span><br><span class="line">&lt;   #archives: /archives/ || fa fa-archive</span><br><span class="line">---</span><br><span class="line">&gt;   home: / || fa fa-home</span><br><span class="line">&gt;   categories: /categories/ || fa fa-folder-open</span><br><span class="line">&gt;   tags: /tags/ || fa fa-tags</span><br><span class="line">&gt;   archives: /archives/ || fa fa-calendar # fa fa-archive</span><br><span class="line">&gt;   about: /about/ || fa fa-user</span><br><span class="line">120,121c120,121</span><br><span class="line">&lt;   position: left</span><br><span class="line">&lt;   #position: right</span><br><span class="line">---</span><br><span class="line">&gt;   #position: left</span><br><span class="line">&gt;   position: right</span><br><span class="line">143c143</span><br><span class="line">&lt;   url: #/images/avatar.gif</span><br><span class="line">---</span><br><span class="line">&gt;   url: /images/avatar.jpg</span><br><span class="line">145c145</span><br><span class="line">&lt;   rounded: false</span><br><span class="line">---</span><br><span class="line">&gt;   rounded: true</span><br><span class="line">147c147</span><br><span class="line">&lt;   rotated: false</span><br><span class="line">---</span><br><span class="line">&gt;   rotated: true</span><br><span class="line">157,158c157,158</span><br><span class="line">&lt;   #GitHub: https://github.com/yourname || fab fa-github</span><br><span class="line">&lt;   #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">---</span><br><span class="line">&gt;   #GitHub: https://github.com/liu-paopao || fab fa-github</span><br><span class="line">&gt;   #E-Mail: mailto:liupaopao520@163.com || fa fa-envelope</span><br><span class="line">170c170</span><br><span class="line">&lt;   icons_only: false</span><br><span class="line">---</span><br><span class="line">&gt;   icons_only: true</span><br><span class="line">212c212</span><br><span class="line">&lt;     name: fa fa-heart</span><br><span class="line">---</span><br><span class="line">&gt;     name: fa fa-heartbeat</span><br><span class="line">222c222</span><br><span class="line">&lt;   powered: true</span><br><span class="line">---</span><br><span class="line">&gt;   powered: false</span><br><span class="line">262a263</span><br><span class="line">&gt; </span><br><span class="line">264c265</span><br><span class="line">&lt; tag_icon: false</span><br><span class="line">---</span><br><span class="line">&gt; tag_icon: true</span><br><span class="line">375c376</span><br><span class="line">&lt;     enable: false</span><br><span class="line">---</span><br><span class="line">&gt;     enable: true</span><br><span class="line">384c385</span><br><span class="line">&lt;   scrollpercent: false</span><br><span class="line">---</span><br><span class="line">&gt;   scrollpercent: true</span><br><span class="line">409c410</span><br><span class="line">&lt;   permalink: https://github.com/yourname</span><br><span class="line">---</span><br><span class="line">&gt;   permalink: https://github.com/liu-paopao</span><br><span class="line">529c530</span><br><span class="line">&lt; fancybox: false</span><br><span class="line">---</span><br><span class="line">&gt; fancybox: true</span><br><span class="line">610,612c611,613</span><br><span class="line">&lt;   enable: false</span><br><span class="line">&lt;   appid:</span><br><span class="line">&lt;   appkey:</span><br><span class="line">---</span><br><span class="line">&gt;   enable: true</span><br><span class="line">&gt;   appid: cyw09gPog</span><br><span class="line">&gt;   appkey: 4488e6b82bfe3d819f4971a5e5c115f4</span><br><span class="line">745c746</span><br><span class="line">&lt;   enable: false</span><br><span class="line">---</span><br><span class="line">&gt;   enable: true</span><br><span class="line">857c858</span><br><span class="line">&lt;   enable: false</span><br><span class="line">---</span><br><span class="line">&gt;   enable: true</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu20.04 上安装配置私人网盘 nextcloud</title>
    <url>/posts/b53da12e.html</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol>
<li>具有 sudo 权限的用户</li>
<li>具有 example.com 域名，并成功解析到当前 ip（可选）</li>
</ol>
<h2 id="安装Nextcloud"><a href="#安装Nextcloud" class="headerlink" title="安装Nextcloud"></a>安装 Nextcloud</h2><p>这里使用 <code>snap</code> 包管理工具安装 Nextcloud，该打包系统可以安装自动处理底层系统的 <code>snap</code> 包，而不是安装和配置 Web 和数据库服务器，然后配置 Nextcloud 应用程序在其上运行，非常方便，适合不爱折腾的小白。</p>
<span id="more"></span>

<h3 id="通过snap-install安装"><a href="#通过snap-install安装" class="headerlink" title="通过snap install安装"></a>通过 <code>snap install</code> 安装</h3><p>输入命令：  </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo snap install nextcloud</span><br></pre></td></tr></tbody></table></figure>
<p>将下载 Nextcloud  snap 包并将其安装在系统上。</p>
<h3 id="通过snap-changes查看"><a href="#通过snap-changes查看" class="headerlink" title="通过snap changes查看"></a>通过 <code>snap changes</code> 查看</h3><p>Nextcloud 软件包安装到服务器后，可以通过列出与 <code>snap</code> 关联的更改来确认安装过程是否成功：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">snap changes nextcloud</span><br></pre></td></tr></tbody></table></figure>

<h3 id="获取snap其他信息"><a href="#获取snap其他信息" class="headerlink" title="获取snap其他信息"></a>获取 <code>snap</code> 其他信息</h3><p><code>snap info</code> 命令可以显示描述，可用的 Nextcloud 管理命令，以及正在跟踪的已安装版本和快照通道：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">snap info nextcloud</span><br></pre></td></tr></tbody></table></figure>

<h2 id="使用SSL保护Nextcloud-Web界面"><a href="#使用SSL保护Nextcloud-Web界面" class="headerlink" title="使用SSL保护Nextcloud Web界面"></a>使用 SSL 保护 Nextcloud Web 界面</h2><p>在我们开始使用 Nextcloud 之前，我们需要保护 Web 界面。</p>
<p>如果您的域名与 Nextcloud 服务器关联，则 Nextcloud snap 可以帮助您从 <a href="https://letsencrypt.org/">Let 的加密中</a>获取和配置受信任的 SSL 证书。 如果您的 Nextcloud 服务器<em>没有</em>域名，则 Nextcloud 可以配置自签名证书，该证书将加密您的 Web 流量，但无法验证您的服务器的身份。</p>
<h3 id="选项1：使用Let的加密设置SSL"><a href="#选项1：使用Let的加密设置SSL" class="headerlink" title="选项1：使用Let的加密设置SSL"></a>选项 1：使用 Let 的加密设置 SSL</h3><p>如果域名与 Nextcloud 服务器相关联，则保护 Web 界面的最佳选择是获取 Let 的加密 SSL 证书。</p>
<p>首先打开防火墙中允许加密用于验证域所有权的端口，将 Nextcloud 登录页面可公开访问，但由于已经配置了管理员帐户，因此没有人能够劫持安装：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo ufw allow 80,443/tcp</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，输入以下内容来请求 Let’s Encrypt 证书：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo nextcloud.enable-https lets-encrypt</span><br></pre></td></tr></tbody></table></figure>

<p>首先会询问服务器是否满足从 Let’s Encrypt 服务请求证书所需的条件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">OutputIn order for Let's Encrypt to verify that you actually own the</span><br><span class="line">domain(s) for which you're requesting a certificate, there are a</span><br><span class="line">number of requirements of which you need to be aware:</span><br><span class="line"></span><br><span class="line">1. In order to register with the Let's Encrypt ACME server, you must</span><br><span class="line">   agree to the currently-in-effect Subscriber Agreement located</span><br><span class="line">   here:</span><br><span class="line"></span><br><span class="line">       https://letsencrypt.org/repository/</span><br><span class="line"></span><br><span class="line">   By continuing to use this tool you agree to these terms. Please</span><br><span class="line">   cancel now if otherwise.</span><br><span class="line"></span><br><span class="line">2. You must have the domain name(s) for which you want certificates</span><br><span class="line">   pointing at the external IP address of this machine.</span><br><span class="line"></span><br><span class="line">3. Both ports 80 and 443 on the external IP address of this machine</span><br><span class="line">   must point to this machine (e.g. port forwarding might need to be</span><br><span class="line">   setup on your router).</span><br><span class="line"></span><br><span class="line">Have you met these requirements? (y/n)</span><br></pre></td></tr></tbody></table></figure>

<p>输入 <strong>y</strong> 继续。</p>
<p>接下来，系统会要求提供用于恢复操作的电子邮件地址：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">OutputPlease enter an email address (for urgent notices or key recovery): your_email@domain.com</span><br></pre></td></tr></tbody></table></figure>

<p>最后，输入与 Nextcloud 服务器关联的域名：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">OutputPlease enter your domain name(s) (space-separated): example.com</span><br></pre></td></tr></tbody></table></figure>

<p>您的 Let’s Encrypt 证书将被请求，并且如果一切顺利，将重新启动内部 Apache 实例以立即实施 SSL：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">OutputAttempting to obtain certificates... done</span><br><span class="line">Restarting apache... done</span><br></pre></td></tr></tbody></table></figure>

<p>到这里就说明设置成功 。</p>
<h3 id="选项2：使用自签名证书设置SSL"><a href="#选项2：使用自签名证书设置SSL" class="headerlink" title="选项2：使用自签名证书设置SSL"></a>选项 2：使用自签名证书设置 SSL</h3><p>如果您的 Nextcloud 服务器<em>没有</em>域名，您仍然可以通过生成自签名 SSL 证书来保护 Web 界面。 此证书将允许通过加密连接访问 Web 界面，但无法验证服务器的身份，因此您的浏览器可能会显示警告。</p>
<p>要生成自签名证书并配置 Nextcloud 以使用它，请键入：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo nextcloud.enable-https self-signed</span><br><span class="line">OutputGenerating key and self-signed certificate... done</span><br><span class="line">Restarting apache... done</span><br></pre></td></tr></tbody></table></figure>

<p>以上输出表明 Nextcloud 生成并启用了自签名证书。</p>
<p>现在接口是安全的，打开防火墙中的 Web 端口以允许访问 Web 界面：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo ufw allow 80,443/tcp</span><br></pre></td></tr></tbody></table></figure>

<p>您现在已准备好第一次登录 Nextcloud。</p>
<h2 id="登录Nextcloud-Web界面"><a href="#登录Nextcloud-Web界面" class="headerlink" title="登录Nextcloud Web界面"></a>登录 Nextcloud Web 界面</h2><p>现在已配置 Nextcloud，请在 Web 浏览器中访问服务器的域名或 IP 地址：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://example.com</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong>如果设置自签名 SSL 证书，则浏览器可能会显示连接不安全的警告，因为服务器的证书未由可识别的证书颁发机构签名。 这适用于自签名证书，因此请随意点击警告以继续访问该站点。输入管理员帐户后将进入 Nextcloud 页面。 </p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>私人网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过 WebDAV 将 Nextcloud 挂载到本地</title>
    <url>/posts/121d06ee.html</url>
    <content><![CDATA[<h2 id="添加网络位置"><a href="#添加网络位置" class="headerlink" title="添加网络位置"></a>添加网络位置</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181736445.png" alt="01"></p>
<h2 id="输入WebDAV地址"><a href="#输入WebDAV地址" class="headerlink" title="输入WebDAV地址"></a>输入 WebDAV 地址</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181737498.png" alt="02"></p>
<p>WebDAV 的地址从网页登录获取</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738898.png" alt="06"></p>
<h2 id="输入Nextcloud账号和密码"><a href="#输入Nextcloud账号和密码" class="headerlink" title="输入Nextcloud账号和密码"></a>输入 Nextcloud 账号和密码</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738403.png" alt="03"></p>
<p>这里可以将网络位置重命名为 Nextcloud</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738541.png" alt="04"></p>
<p>接下来就能看到我的电脑里面多了一个盘，进去后就能看到 Nextcloud 网盘里的文件了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738555.png" alt="05"></p>
<h2 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复 bug</h2><p>通过常规方法将 Nextcloud 挂载到本地后，重启电脑后会失效，进不去映射盘了，会报错 “你可能没有权限使用网络资源……”，换下面的方法重新映射即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">net use N: https://liupaopao.xyz/remote.php/dav/files/xx/  /user:liupaopao /persistent:YES password</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>N</code>：自定义的盘符</li>
<li><code>liupaopao</code>：用户名</li>
<li><code>password</code>： 密码</li>
</ul>
<p>/persistent 表示保存映射，下次开机还在。执行完，打开资源管理器，可以看到磁盘映射了。</p>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>私人网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装配置 Ubuntu 教程</title>
    <url>/posts/8b1a24dc.html</url>
    <content><![CDATA[<p>记录在树莓派上安装 Ubuntu 并配置的过程：通过树莓派镜像工具和 SD 读卡器将 Ubuntu 系统镜像烧录到 SD 卡，再将 SD 卡插到树莓派卡槽，通电即可运行，插入网线后通过 ssh 登录树莓派 Ubuntu 进行配置。</p>
<span id="more"></span>

<h2 id="烧录Ubuntu系统到SD卡"><a href="#烧录Ubuntu系统到SD卡" class="headerlink" title="烧录Ubuntu系统到SD卡"></a>烧录 Ubuntu 系统到 SD 卡</h2><ol>
<li>打开网址 <a href="https://cn.ubuntu.com/download/raspberry-pi">https://cn.ubuntu.com/download/raspberry-pi</a> 下载树莓派镜像工具（Raspberry Pi Imager），安装并打开。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212092227096.png" alt="image-20221209222658967"></p>
<ol start="2">
<li>选择对应的 Ubuntu 系统，我这里选了 Ubuntu Server 22.04.1 LTS 版本，然后选择 SD 卡位置，开始烧录，烧录成功后就自动开始校验，该过程大概需要半小时。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212092228911.png" alt="image-20221209222822843"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212092229745.png" alt="image-20221209222900679"></p>
<h2 id="连接登录树莓派Ubuntu系统"><a href="#连接登录树莓派Ubuntu系统" class="headerlink" title="连接登录树莓派Ubuntu系统"></a>连接登录树莓派 Ubuntu 系统</h2><p>用网线将树莓派连到路由器，通电开机后，系统会创建用户 ubuntu，然后进到路由器管理页面中查看树莓派的 IP 地址，找到一个名为 Ubuntu 的 IP192.168.1.12。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212092246801.png" alt="image-20221209224605715"></p>
<p>找到树莓派 IP 后通过 Xshell 软件进行 SSH 连接 <code>ssh ubuntu@192.168.1.12</code>，登录账户密码都是 ubuntu，首次登录时，系统会强制要求更改 ubuntu 用户密码。</p>
<h2 id="更换为清华镜像源"><a href="#更换为清华镜像源" class="headerlink" title="更换为清华镜像源"></a>更换为清华镜像源</h2><p>打开网址 <a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu-ports/">https://mirror.tuna.tsinghua.edu.cn/help/ubuntu-ports/</a>，选择对应的 Ubuntu 版本，将内容复制到软件源配置文件 <code>/etc/apt/sources.list</code> 里面。</p>
<p>然后执行 <code>apt update</code> 和 <code>apt upgrade</code> 命令更新源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212092235834.png" alt="image-20221209223559737"></p>
<h2 id="允许root账号远程登录"><a href="#允许root账号远程登录" class="headerlink" title="允许root账号远程登录"></a>允许 root 账号远程登录</h2><ol>
<li>执行 <code>sudo passwd</code> 修改 root 账号的密码，然后执行 <code>su -</code> 切换到 root 账号，或者直接 <code>sudo su</code> 命令切换到 root 权限。</li>
<li>编辑文件 <code>vim /etc/ssh/sshd_config</code>，修改配置为 <code>PermitRootLogin yes</code>。</li>
<li>最后 <code>reboot</code> 命令重启树莓派，就能以 root 账号 ssh 远程登录了。</li>
</ol>
]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 cloudreve 搭建私人网盘教程</title>
    <url>/posts/c0dafae.html</url>
    <content><![CDATA[<h2 id="开源、稳定、好用的三大网盘"><a href="#开源、稳定、好用的三大网盘" class="headerlink" title="开源、稳定、好用的三大网盘"></a>开源、稳定、好用的三大网盘</h2><ul>
<li>nextcloud</li>
<li>owncloud</li>
<li>cloudreve</li>
</ul>
<p>我心目中的开源网盘 TOP3，其中 nextcloud 和 cloudreve 亲身搭建测试用过，效果都不错。owncloud 据说是 nextcloud 的前身，的确感觉界面很类似。nextcloud 有各平台 app 客户端，插件丰富，功能强大。cloudreve 感觉更轻量级，部署方便，而且界面 UI 比较好看，GitHub 上 star 也非常多，感觉更受欢迎，我亲测过后也爱了。</p>
<span id="more"></span>

<h2 id="cloudreve特性"><a href="#cloudreve特性" class="headerlink" title="cloudreve特性"></a>cloudreve 特性</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202306201621997.png" alt="homepage"></p>
<p>☁️ 支持本机、从机、七牛、阿里云 OSS、腾讯云 COS、又拍云、OneDrive (包括世纪互联版) 、S3 兼容协议 作为存储端<br>📤 上传 / 下载 支持客户端直传，支持下载限速<br>💾 可对接 Aria2 离线下载，可使用多个从机节点分担下载任务<br>📚 在线 压缩 / 解压缩、多文件打包下载<br>💻 覆盖全部存储策略的 WebDAV 协议支持<br>⚡ 拖拽上传、目录上传、流式上传处理<br>🗃️ 文件拖拽管理<br>👩‍👧‍👦 多用户、用户组、多存储策略<br>🔗 创建文件、目录的分享链接，可设定自动过期<br>👁️‍🗨️ 视频、图像、音频、 ePub 在线预览，文本、Office 文档在线编辑<br>🎨 自定义配色、黑暗模式、PWA 应用、全站单页应用、国际化支持<br>🚀 All-In-One 打包，开箱即用<br>🌈 … …</p>
<h2 id="安装cloudreve"><a href="#安装cloudreve" class="headerlink" title="安装cloudreve"></a>安装 cloudreve</h2><p>GitHub 下载地址：<a href="https://github.com/cloudreve/Cloudreve/releases">https://github.com/cloudreve/Cloudreve/releases</a></p>
<p>根据操作系统和 CPU 架构下载对应的二进制文件，解压后直接运行即可：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压程序包</span></span><br><span class="line">tar -zxvf cloudreve_VERSION_OS_ARCH.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予执行权限</span></span><br><span class="line">chmod +x ./cloudreve</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Cloudreve</span></span><br><span class="line">./cloudreve</span><br></pre></td></tr></tbody></table></figure>

<p>Cloudreve 在首次启动时，会创建初始管理员账号，请注意保管管理员密码，此密码只会在首次启动时出现。如果您忘记初始管理员密码，需要删除同级目录下的 cloudreve.db，重新启动主程序以初始化新的管理员账户。</p>
<p>Cloudreve 默认会监听 5212 端口。启动后直接在浏览器中访问 <code>localhost:5212</code> 或 <code>http://服务器IP:5212</code> 进入 Cloudreve。</p>
<h3 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">geduer@gdk8:~$ mkdir cloudreve</span><br><span class="line">geduer@gdk8:~$ cd cloudreve/</span><br><span class="line">geduer@gdk8:~/cloudreve$ ls</span><br><span class="line">cloudreve_3.8.0_linux_arm64.tar.gz</span><br><span class="line">geduer@gdk8:~/cloudreve$ tar -xvf cloudreve_3.8.0_linux_arm64.tar.gz </span><br><span class="line">LICENSE</span><br><span class="line">README.md</span><br><span class="line">README_zh-CN.md</span><br><span class="line">cloudreve</span><br><span class="line">geduer@gdk8:~/cloudreve$ ls</span><br><span class="line">LICENSE  README.md  README_zh-CN.md  cloudreve  cloudreve_3.8.0_linux_arm64.tar.gz</span><br><span class="line">geduer@gdk8:~/cloudreve$ ./cloudreve </span><br><span class="line"></span><br><span class="line">___ _                 _</span><br><span class="line">  / __\ | ___  _   _  __| |_ __ _____   _____ </span><br><span class="line"> / /  | |/ _ \| | | |/ _  | '__/ _ \ \ / / _ \	</span><br><span class="line">/ /___| | (_) | |_| | (_| | | |  __/\ V /  __/</span><br><span class="line">\____/|_|\___/ \__,_|\__,_|_|  \___| \_/ \___|</span><br><span class="line"></span><br><span class="line">   V3.8.0  Commit #243c312  Pro=false</span><br><span class="line">================================================.</span><br><span class="line"></span><br><span class="line">[Info]    2023-06-19 14:44:03 Initializing database connection...</span><br><span class="line">[Info]    2023-06-19 14:44:03 Start initializing database schema...</span><br><span class="line">[Info]    2023-06-19 14:44:03 Admin user name: xxxxx</span><br><span class="line">[Info]    2023-06-19 14:44:03 Admin password: xxxxx</span><br><span class="line">[Info]    2023-06-19 14:44:04 Start executing database script "UpgradeTo3.4.0".</span><br><span class="line">[Info]    2023-06-19 14:44:04 Finish initializing database schema.</span><br><span class="line">[Info]    2023-06-19 14:44:04 Initialize task queue with WorkerNum = 10</span><br><span class="line">[Info]    2023-06-19 14:44:04 Initialize crontab jobs...</span><br><span class="line">[Info]    2023-06-19 14:44:04 Current running mode: Master.</span><br><span class="line">[Info]    2023-06-19 14:44:04 Listening to ":5212"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:55 | 200 |    18.24428ms |  192.168.43.117 | GET      "/"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:55 | 200 |   41.710503ms |  192.168.43.117 | GET      "/static/css/6.57254ef2.chunk.css"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:55 | 200 |   144.74392ms |  192.168.43.117 | GET      "/static/js/main.b28185a0.chunk.js"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:56 | 200 |  382.097422ms |  192.168.43.117 | GET      "/static/js/6.2cdf7034.chunk.js"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:56 | 200 |    1.546953ms |  192.168.43.117 | GET      "/locales/en-US/common.json?v=3.8.0-beta1"</span><br><span class="line">[GIN] 2023/06/19 - 14:45:56 | 200 |    8.654829ms |  192.168.43.117 | GET      "/api/v3/site/config"</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置cloudreve进程守护和开机启动"><a href="#设置cloudreve进程守护和开机启动" class="headerlink" title="设置cloudreve进程守护和开机启动"></a>设置 cloudreve 进程守护和开机启动</h2><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/cloudreve.service</span><br></pre></td></tr></tbody></table></figure>

<p>将下文 PATH_TO_CLOUDREVE 更换为程序所在目录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Cloudreve</span><br><span class="line">Documentation=https://docs.cloudreve.org</span><br><span class="line">After=network.target</span><br><span class="line">After=mysqld.service</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/PATH_TO_CLOUDREVE</span><br><span class="line">ExecStart=/PATH_TO_CLOUDREVE/cloudreve</span><br><span class="line">Restart=on-abnormal</span><br><span class="line">RestartSec=5s</span><br><span class="line">KillMode=mixed</span><br><span class="line"></span><br><span class="line">StandardOutput=null</span><br><span class="line">StandardError=syslog</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 更新配置</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start cloudreve</span><br><span class="line"></span><br><span class="line"># 设置开机启动</span><br><span class="line">systemctl enable cloudreve</span><br></pre></td></tr></tbody></table></figure>

<h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">systemctl start cloudreve</span><br><span class="line"></span><br><span class="line"># 停止服务</span><br><span class="line">systemctl stop cloudreve</span><br><span class="line"></span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart cloudreve</span><br><span class="line"></span><br><span class="line"># 查看状态</span><br><span class="line">systemctl status cloudreve</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实操演示-1"><a href="#实操演示-1" class="headerlink" title="实操演示"></a>实操演示</h3><p><strong>注意：</strong>如果存在配置文件对应的目录，则直接根据步骤操作即可。而我的新环境由于 /usr/lib/systemd 下没有 system 目录，vim 编辑文件后无法保存，此时需要先创建好对应的目录后，再编辑配置文件。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@gdk8:/usr/lib/systemd/system# vim cloudreve.service</span><br><span class="line">root@gdk8:/usr/lib/systemd/system# systemctl daemon-reload</span><br><span class="line">root@gdk8:/usr/lib/systemd/system# systemctl start cloudreve</span><br><span class="line">root@gdk8:/usr/lib/systemd/system# systemctl enable cloudreve</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/cloudreve.service → /usr/lib/systemd/system/cloudreve.service.</span><br><span class="line">root@gdk8:/usr/lib/systemd/system# systemctl status cloudreve</span><br><span class="line">● cloudreve.service - Cloudreve</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/cloudreve.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2023-06-19 15:24:53 CST; 13s ago</span><br><span class="line">     Docs: https://docs.cloudreve.org</span><br><span class="line"> Main PID: 1673 (cloudreve)</span><br><span class="line">    Tasks: 8 (limit: 4672)</span><br><span class="line">   CGroup: /system.slice/cloudreve.service</span><br><span class="line">           └─1673 /home/geduer/cloudreve/cloudreve</span><br><span class="line"></span><br><span class="line">Jun 19 15:24:53 gdk8 systemd[1]: Started Cloudreve.</span><br><span class="line">root@gdk8:/usr/lib/systemd/system# ls</span><br><span class="line">cloudreve.service</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>私人网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerPC 指令集架构介绍</title>
    <url>/posts/a19ee375.html</url>
    <content><![CDATA[<h2 id="PowerPC简介"><a href="#PowerPC简介" class="headerlink" title="PowerPC简介"></a>PowerPC 简介</h2><p>PowerPC，有时也被简称 PPC，是一种精简指令集（RISC）架构。PowerPC 英文全名为 “Performance Optimization With Enhanced RISC – Performance Computing”。</p>
<span id="more"></span>

<p>PowerPC 是由 Apple、IBM、Motorola 三家公司在 1991 年设计的，设计源自 IBM 的 POWER 架构，主要应用在通信、工控、航天国防等要求高性能和高可靠性的一些高端领域。</p>
<p>PowerPC 指令集架构（PowerPC Instruction Set Architecture，PowerPC ISA），主要包括寄存器类别和指令格式两部分内容。</p>
<p>PowerPC 处理器提供 32 位和 64 位两种指令运行环境。</p>
<h2 id="寄存器类别"><a href="#寄存器类别" class="headerlink" title="寄存器类别"></a>寄存器类别</h2><p>PowerPC 用户态寄存器包括：</p>
<ul>
<li>GPR（General Purpose Registers，通用寄存器，64 位），32 个</li>
<li> FPR（Floating-Point Registers，浮点寄存器，64 位），32 个</li>
<li> FPSCR（Floating-Point Status and Control Register，浮点状态和控制寄存器，32 位）</li>
<li>LR（Link Register，链接寄存器，64 位），用来存放函数的返回地址，转移指令的编码中 LK 位为 1 时，转移指令就会将当前指令地址加 4 后保存到 LR 寄存器，从而实现函数的调用和返回。</li>
<li>CTR（ Count Register，计数寄存器，64 位），用来保存循环变量。</li>
<li>XER（ Fixed-Point Exception Register，整数运算进位和溢出寄存器，64 位），用来存放整数运算的溢出、进位。分为 3 个有效位，1 个有效字段，其他是保留位。<ul>
<li>SO（第 32 位）：当检测到有指令设置 OV 时，置 1</li>
<li>OV（第 33 位）：有符号数算术运算出现溢位</li>
<li> CA（第 34 位）：无符号数算术运算出现进位</li>
<li>第 57~63 位：表示 load/store 指令传送的字节数</li>
</ul>
</li>
<li> CR（Condition Register，条件寄存器，32 位），用来存放指令执行后的状态，分为 8 个字段（CR0 ~ CR7），每个字段 4 位。整数运算指令的结果状态保存到 CR0，浮点运算指令的结果状态保存到 CR1。<ul>
<li>CR0 [0]：小于 LT，结果为负时置 1</li>
<li>CR0 [0]：大于 GT，结果为正时置 1</li>
<li>CR0 [0]：等于 EQ，结果为 0 时置 1</li>
<li>CR0 [0]：溢出 SO，结果溢出时置 1</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304052225755.png" alt="image-20230405222500629"></p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li>指令长度 4 字节 32 位，按字对齐，通常采用大端存储，指令最低 2 位忽略，通常为 0。</li>
<li>[0:5] 位表示操作码 OPCD，很多指令同时也有扩展码 XO（extended opcode）。</li>
<li>[6:31] 位根据不同指令格式，分别表示不同含义。</li>
</ul>
<h3 id="I-Form"><a href="#I-Form" class="headerlink" title="I-Form"></a>I-Form</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304052339845.png" alt="image-20230405225019176"></p>
<p><strong>无条件转移指令格式</strong>，如函数调用 bl 指令，跳转到指定函数并保存下一条指令地址：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bl LI AA=0,LK=1</span><br></pre></td></tr></tbody></table></figure>

<p>LI (6:29) ：立即数字段（Immediate field），表示 24 位带符号的二进制整数，右侧添加 0b00 （即 LI*4）并符号扩展为 64 位。</p>
<p>AA (30) ：绝对地址位（Absolute Address bit）。</p>
<blockquote>
<p>AA=0 表示立即数字段为当前指令地址的相对地址。 对于 I-form 分支指令，分支目标的有效地址是 LI 字段符号扩展到 64 位后再加上分支指令地址。 对于 B-form 分支指令，分支目标的有效地址是 BD 字段符号扩展到 64 位后再加上分支指令地址。<br>AA=1 表示立即数字段代表一个绝对地址。 对于 I-form 分支指令，分支跳转目标的有效地址是 LI 字段符号扩展到 64 位。 对于 B-form 分支指令，分支跳转目标的有效地址是 BD 字段符号扩展到 64 位。</p>
</blockquote>
<p>LK (31) ：链接位（LINK bit）。</p>
<blockquote>
<p>0 表示不设置 LR 寄存器<br>1 表示将分支指令后的下一条指令地址设置到 LR 寄存器中。</p>
</blockquote>
<h3 id="B-Form"><a href="#B-Form" class="headerlink" title="B-Form"></a>B-Form</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304052339810.png" alt="image-20230405231908193"></p>
<p><strong>条件转移指令格式</strong></p>
<p>BO (6:10)：该字段表示指令根据什么条件进行跳转。</p>
<ul>
<li>第 0 位为 1 时，bc 指令根据 CTR 寄存器进行条件跳转</li>
<li>第 1 为为 1 时，表示条件为真时进行跳转</li>
<li>第 2 为为 1 时，表示执行 bc 指令时 CTR 值不变</li>
<li>……</li>
</ul>
<p>BI (11:15)：该字段用于指定 CR 中需要由分支条件指令测试的位。</p>
<ul>
<li>BI [3:4]=00，使用 LT 状态位用作指令转移条件</li>
<li> BI [3:4]=01，使用 GT 状态位用作指令转移条件</li>
<li> BI [3:4]=10，使用 EQ 状态位用作指令转移条件</li>
<li> BI [3:4]=11，使用 SO 状态位用作指令转移条件</li>
</ul>
<p>BD (16:29)：该字段用于指定 14 位有符号数的分支位移的立即数，右侧添加 0b00 并符号扩展为 64 位。</p>
<h3 id="SC-Form"><a href="#SC-Form" class="headerlink" title="SC-Form"></a>SC-Form</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304052339466.png" alt="image-20230405232752028"></p>
<p><strong>系统调用指令格式</strong>，即 sc 指令。</p>
<p>LEV (20:26)：该字段被系统调用指令使用（System Call）。</p>
<p><code>/，//，///</code> 表示指令中保留的字段。</p>
<h3 id="D-Form和DS-Form"><a href="#D-Form和DS-Form" class="headerlink" title="D-Form和DS-Form"></a>D-Form 和 DS-Form</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304152216874.png" alt="image-20230415221607770"></p>
<p><strong>存储器、寄存器读写指令，立即数算术运算和逻辑运算指令</strong>，由 6 位操作码 + 10 位寄存器索引 + 16 位立即数构成。</p>
<p>RT (6:10)：存放指令运算结果的寄存器索引，用作目标寄存器。</p>
<p>RS (6:10)：存放指令运算结果的寄存器索引。</p>
<p>RA (11:15)：存放指令所需数据源的寄存器索引。</p>
<p>D (16:31)：存放指令所需另一个数据源，16 位有符号立即数，并符号扩展到 64 位。</p>
<p>SI (16:31)：存放指令所需另一个数据源，16 位有符号立即数。</p>
<p>UI (16:31)：存放指令所需另一个数据源，16 位无符号立即数。</p>
<p>L (10)：表示进行 32 位还是 64 位比较。</p>
<p>BF (6:8)：表示使用的 CR 字段或者 FPSCR 字段。</p>
<p>TO (6:10)：表示 trap 自陷指令的条件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304152231871.png" alt="image-20230415223101813"></p>
<p>DS (16:29)：表示 14 位有符号立即数，右侧用 0x00 进行位拼接，并符号扩展到 64 位。</p>
<p>XO (30:31)：表示扩展的操作码字段。</p>
<h3 id="X-Form"><a href="#X-Form" class="headerlink" title="X-Form"></a>X-Form</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415223333681.png" alt="image-20230415223333681"></p>
<p>X-Form 格式指令与 D-Form 类似，只是将 D 字段拆分为 RB、XO、Rc。</p>
<p>RB 和 RS 字段用来存放源操作数寄存器的索引，RT 字段存放目的操作寄存器的索引，RA 既可以当源操作数又可以当目的操作数。</p>
<p>Rc 字段为 1 表示指令运算结果将改变 CR 寄存器的值，为 0 则不改变 CR 寄存器。具有<code>.</code> 后缀的指令，其 Rc 位为 1。</p>
<h3 id="XL-Form"><a href="#XL-Form" class="headerlink" title="XL-Form"></a>XL-Form</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415223357207.png" alt="image-20230415223357207"></p>
<p>XL-Form 格式指令支持条件转移，与 B-Form 格式指令不同的是，此类指令使用 LR 或 CTR 寄存器进行跳转，而不是使用 16 位立即数进行跳转，因此可以实现一些 32 位的长跳转。</p>
<h3 id="XFX-Form、XFL-Form、XS-Form、XO-Form与A-Form"><a href="#XFX-Form、XFL-Form、XS-Form、XO-Form与A-Form" class="headerlink" title="XFX-Form、XFL-Form、XS-Form、XO-Form与A-Form"></a>XFX-Form、XFL-Form、XS-Form、XO-Form 与 A-Form</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415223415305.png" alt="image-20230415223415305"></p>
<p>XFX-Form 格式指令用于访问 SPR 寄存器和 CR 寄存器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162235074.png" alt="image-20230416223505933"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162235590.png" alt="image-20230416223530521"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162235669.png" alt="image-20230416223543594"></p>
<p>XO-Form 格式指令用来支持带进位的算术运算和乘除法指令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162235709.png" alt="image-20230416223558649"></p>
<p>A-Form 格式指令用于浮点计算。</p>
<h3 id="M-Form、MD-Form和MDS-Form"><a href="#M-Form、MD-Form和MDS-Form" class="headerlink" title="M-Form、MD-Form和MDS-Form"></a>M-Form、MD-Form 和 MDS-Form</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162237885.png" alt="image-20230416223700825"></p>
<p>M-Form 格式指令用于对选定的字段进行循环左移并做一些相应的掩码操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162237553.png" alt="image-20230416223714490"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304162237330.png" alt="image-20230416223724263"></p>
]]></content>
      <categories>
        <category>指令集架构</category>
      </categories>
      <tags>
        <tag>PowerPC</tag>
      </tags>
  </entry>
  <entry>
    <title>aarch64 架构通过 mov 和 movk 指令实现立即数装载</title>
    <url>/posts/2ed0bfd1.html</url>
    <content><![CDATA[<p>对 64 位数据装载到寄存器这一操作不同架构实现不同，x86 能直接通过 mov 指令实现，而 aarch64 的 mov 指令一步只能装载 16 位，对于 64 位立即数必须分四部分进行装载，下面就是 x86 和 aarch64 对比验证过程。</p>
<span id="more"></span>

<p>x86 能够通过 mov 指令实现 64 位立即数装载到寄存器，测试过程如下，通过 mov 指令对寄存器 r9 进行赋值，然后通过嵌汇编获取 r9 的值并且打印出来。</p>
<h2 id="测试用例test-asm-x86-c："><a href="#测试用例test-asm-x86-c：" class="headerlink" title="测试用例test_asm_x86.c："></a><strong>测试用例 test_asm_x86.c：</strong></h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_r9</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *r9)</span> {</span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">"mov %%r9, %0"</span></span><br><span class="line">        :<span class="string">"=m"</span>(*r9)</span><br><span class="line">        ::<span class="string">"memory"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"r9 = 0x%llx\n"</span>, *r9);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> r9;</span><br><span class="line">  __asm__(<span class="string">"mov $0xa1b2, %r9"</span>);</span><br><span class="line">  print_r9(&amp;r9);</span><br><span class="line">  __asm__(<span class="string">"mov $0xa1b2c3d4, %r9"</span>);</span><br><span class="line">  print_r9(&amp;r9);</span><br><span class="line">  __asm__(<span class="string">"mov $0xa1b2c3d4e5f6f7f8, %r9"</span>);</span><br><span class="line">  print_r9(&amp;r9);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">**结果为：**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>r9 = 0xa1b2<br>r9 = 0xa1b2c3d4<br>r9 = 0xa1b2c3d4e5f6f7f8</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">## **测试用例test_asm_aarch64.c：**</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">// x19-x28 is callee-saved</span><br><span class="line">void print_x19() {</span><br><span class="line">    unsigned long long x19_val;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        "mov %0, x19"</span><br><span class="line">        :"=r"(x19_val)</span><br><span class="line">        ::);</span><br><span class="line">    printf("x19 = 0x%llx\n", x19_val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">  __asm__("mov x19, #0xaaaa");</span><br><span class="line">  print_x19();</span><br><span class="line">  // Error: immediate cannot be moved by a single instruction</span><br><span class="line">  __asm__("mov x19, #0xbbbbaaaa");</span><br><span class="line">  print_x19();</span><br><span class="line">  return 0;</span><br><span class="line">}</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">**编译报错：**</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">Assembler messages:</span><br><span class="line">Error: immediate cannot be moved by a single instruction</span><br></pre></td></tr></tbody></table></figure>

<p>报错来源于<code>__asm__("mov x19, #0xbbbbaaaa");</code> 这条汇编，查阅资料发现 aarch64 不能通过 mov 指令实现超过 16 位的立即数装载，即 mov 指令不能一次将 64 位立即数装入寄存器，需要借助 movk 指令分四次装载。movk 指令意思是 <code>move and keep</code>，可以将一个 16 位立即数偏移存入指定寄存器，并且保留寄存器其他位的数值。</p>
<p>若想把 <code>0xddddccccbbbbaaaa</code>64 位立即数装入，则需要把立即数分割成四部分依次装载（对于 64 位指针也是这样分四次装载）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">__asm__(<span class="string">"mov x19, #0xaaaa"</span>);</span><br><span class="line">__asm__(<span class="string">"movk x19, #0xbbbb, lsl #16"</span>);</span><br><span class="line">__asm__(<span class="string">"movk x19, #0xcccc, lsl #32"</span>);</span><br><span class="line">__asm__(<span class="string">"movk x19, #0xdddd, lsl #48"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果为：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">x19 = 0xaaaa</span><br><span class="line">x19 = 0xbbbbaaaa</span><br><span class="line">x19 = 0xccccbbbbaaaa</span><br><span class="line">x19 = 0xddddccccbbbbaaaa</span><br></pre></td></tr></tbody></table></figure>
<p>如果想单独装载 16 位数据到高位，可以根据 mov 规则，对立即数先进行 16、32、48 移位，然后再根据需要往对应位置装载 16 位立即数，下面四条嵌汇编都能正确执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">__asm__(<span class="string">"mov x19, #0xaaaa"</span>);</span><br><span class="line">__asm__(<span class="string">"mov x19, #0xbbbb0000"</span>);</span><br><span class="line">__asm__(<span class="string">"mov x19, #0xcccc00000000"</span>);</span><br><span class="line">__asm__(<span class="string">"mov x19, #0xdddd000000000000"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>能够发现，上述四条汇编只是提前进行了 lsl 移位，所以本质上是一样的。如果没有根据规定进行 16、32、48 特定的移位就会报错，比如立即数 0xbbbb000 只是把 0xbbbb 左移 12 位，此时就会报错：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">__asm__(<span class="string">"mov x19, #0xbbbb000"</span>); <span class="comment">//Error: immediate cannot be moved by a single instruction</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>指令集架构</category>
      </categories>
      <tags>
        <tag>aarch64</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 qemu 在 x86 上实现全系统模拟 PowerPC</title>
    <url>/posts/66d22827.html</url>
    <content><![CDATA[<p>某软件开发过程中，需要参考 PowerPC 架构代码，但并没有 ppc 架构的机器环境，VMware 只能模拟同架构的 OS，而想要模拟不同架构，进行跨架构开发的话只能通过 qemu 进行模拟。本文记录了在 Linux 和 Windows 两种环境下实现过程：在 Windows 通过 VMware 建立 Ubuntu18.04 虚拟机，然后在 Ubuntu18.04 下用 qemu 实现全系统模拟 PowerPC；或者直接在 Windows 下用 win-64bits 的 qemu 来实现，两种方法都可行。</p>
<span id="more"></span>

<h1 id="Ubuntu18-04搭建过程"><a href="#Ubuntu18-04搭建过程" class="headerlink" title="Ubuntu18.04搭建过程"></a>Ubuntu18.04 搭建过程</h1><h2 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装 qemu</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></tbody></table></figure>

<h2 id="下载ppc镜像"><a href="#下载ppc镜像" class="headerlink" title="下载ppc镜像"></a>下载 ppc 镜像</h2><p>Ubuntu16.04.6 之后的版本不再支持 ppc 架构，这里使用最后一个发行版 <code>ubuntu-16.04.6-server-powerpc.iso</code>，下载地址：<br><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/releases/16.04/release/ubuntu-16.04.6-server-powerpc.iso">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/releases/16.04/release/ubuntu-16.04.6-server-powerpc.iso</a></p>
<h2 id="生成硬盘镜像"><a href="#生成硬盘镜像" class="headerlink" title="生成硬盘镜像"></a>生成硬盘镜像</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 ubuntu16.qcow2 60G</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">qemu-system-ppc -L pc-bios -boot d -M mac99 -m 1024 -net nic,model=sungem -net user -hda ubuntu16.qcow2 -cdrom ubuntu-16.04.6-server-powerpc.iso</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">qemu-system-ppc -L pc-bios -boot c -prom-env "boot-device=hd:,\yaboot" -prom-env "boot-args=conf=hd:,\yaboot.conf" -M mac99 -m 1024 -net nic,model=sungem -net user -hda ubuntu16.qcow2 -g 1024x768x32</span><br></pre></td></tr></tbody></table></figure>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305192313183.png" alt="image-20230519231357094"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305192326191.png" alt="image-20230519232612089"></p>
<h1 id="Windows10搭建过程"><a href="#Windows10搭建过程" class="headerlink" title="Windows10搭建过程"></a>Windows10 搭建过程</h1><h2 id="安装qemu-1"><a href="#安装qemu-1" class="headerlink" title="安装qemu"></a>安装 qemu</h2><p><a href="https://www.qemu.org/download/#windows">qemu 官网</a>已经支持 Windows，并提供了二进制工具集，直接下载二进制使用最为方面。QEMU Binaries for Windows (64 bit) 下载地址：<br><a href="https://qemu.weilnetz.de/w64/">https://qemu.weilnetz.de/w64/</a></p>
<h2 id="方法一：复制Linux硬盘镜像"><a href="#方法一：复制Linux硬盘镜像" class="headerlink" title="方法一：复制Linux硬盘镜像"></a>方法一：复制 Linux 硬盘镜像</h2><p>如果已经在 Ubuntu Linux 环境下成功安装了 ppc 系统，可以直接把 <code>ubuntu16.qcow2</code> 镜像文件复制到 Windows 环境下使用。</p>
<p>进入 qemu 二进制存放目录，在 Windows 命令行下运行：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\qemu-system-ppc.exe -L pc-bios -boot c -prom-env "boot-device=hd:,\yaboot" -prom-env "boot-args=conf=hd:,\yaboot.conf" -M mac99 -m 1024 -net nic,model=sungem -net user -hda ubuntu16.qcow2 -g 1024x768x32</span><br></pre></td></tr></tbody></table></figure>

<h2 id="方法二：参照Ubuntu搭建过程从零开始"><a href="#方法二：参照Ubuntu搭建过程从零开始" class="headerlink" title="方法二：参照Ubuntu搭建过程从零开始"></a>方法二：参照 Ubuntu 搭建过程从零开始</h2><p>Windows 环境搭建过程和 Ubuntu 搭建方法一样，只是记得把命令中的 <code>qemu-system-ppc</code> 换成<code>.\qemu-system-ppc.exe</code>。</p>
<p><strong>三步走：</strong></p>
<ol>
<li>生成硬盘镜像 </li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\qemu-img.exe create -f qcow2 ubuntu16.qcow2 60G</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>安装系统 </li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\qemu-system-ppc.exe -L pc-bios -boot d -M mac99 -m 1024 -net nic,model=sungem -net user -hda ubuntu16.qcow2 -cdrom ubuntu-16.04.6-server-powerpc.iso</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>开始运行 </li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\qemu-system-ppc.exe -L pc-bios -boot c -prom-env "boot-device=hd:,\yaboot" -prom-env "boot-args=conf=hd:,\yaboot.conf" -M mac99 -m 1024 -net nic,model=sungem -net user -hda ubuntu16.qcow2 -g 1024x768x32</span><br></pre></td></tr></tbody></table></figure>

<h2 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305192301296.png" alt="image-20230519230101675"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305192310523.png" alt="image-20230519231054400"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一开始查阅的中文教程，实操过程中出现各种问题，然后 google 上用英文搜索后，发现了一些英文靠谱的教程，一试便成功了。参考的是 GitHub 上 ross-newman 大佬给出的方法：</p>
<p><a href="https://gist.github.com/ross-newman/a744988b298ea1ad47c5dae1baafcb22">https://gist.github.com/ross-newman/a744988b298ea1ad47c5dae1baafcb22</a></p>
<p>Building PPC Linux code using QEMU on Ubuntu 18.04 LTS：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo "Building Debina 10 QEMU instance..."</span><br><span class="line">wget https://cdimage.debian.org/cdimage/ports/10.0/powerpc/iso-cd/debian-10.0-powerpc-NETINST-1.iso</span><br><span class="line">sudo apt install qemu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create new disk <span class="keyword">for</span> install</span></span><br><span class="line">qemu-img create -f qcow2 debian10.qcow2 2000M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Boot the install image</span></span><br><span class="line">qemu-system-ppc -L pc-bios -boot d -M mac99 -m 1024 -net nic,model=sungem -net user -hda debian10.qcow2 -cdrom ./debian-10.0-powerpc-NETINST-1.iso -g 1024x768x8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the image</span></span><br><span class="line">qemu-system-ppc -L pc-bios -boot c -prom-env "boot-device=hd:,\yaboot" -prom-env "boot-args=conf=hd:,\yaboot.conf" \</span><br><span class="line"> -M mac99 -m 1024 -net nic,model=sungem -net user -hda debian10.qcow2 -g 1024x768x32</span><br><span class="line"></span><br><span class="line">echo "Building lUbuntu 16.04 QEMU instance..."</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget http://cdimage.ubuntu.com/releases/14.04/release/ubuntu-14.04.6-server-powerpc.iso</span></span><br><span class="line">wget http://cdimage.ubuntu.com/lubuntu/releases/16.04.1/release/lubuntu-16.04-desktop-powerpc.iso</span><br><span class="line">qemu-img create -f qcow2 lubuntu14.qcow2 2000M</span><br><span class="line">qemu-system-ppc -L pc-bios -boot d -M mac99 -m 1024 -net nic,model=sungem -net user -hda lubuntu14.qcow2 -cdrom lubuntu-14.04.5-desktop-powerpc.iso</span><br><span class="line">qemu-system-ppc -L pc-bios -boot c -prom-env "boot-device=hd:,\yaboot" -prom-env "boot-args=conf=hd:,\yaboot.conf" -M mac99 -m 1024 -net nic,model=sungem -net user -hda lubuntu14.qcow2 -cdrom lubuntu-14.04.5-desktop-powerpc.iso</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Building u-boot <span class="keyword">for</span> PPC</span></span><br><span class="line">echo "Building U-Boot for QEMU..."</span><br><span class="line">sudo apt install gcc-powerpc-linux-gnu</span><br><span class="line">git clone https://git.denx.de/u-boot.git</span><br><span class="line">make ARCH=powerpc CROSS_COMPILE=powerpc-linux-gnu- qemu-ppce500_defconfig</span><br><span class="line">make ARCH=powerpc CROSS_COMPILE=powerpc-linux-gnu-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">qemu-system-ppc -machine <span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">qemu-system-ppc -cpu <span class="built_in">help</span></span></span><br><span class="line">qemu-system-ppc -M ppce500 -m 1024 -nographic -kernel ./u-boot</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>指令集架构</category>
      </categories>
      <tags>
        <tag>PowerPC</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray 多用户配置</title>
    <url>/posts/21a98812.html</url>
    <content><![CDATA[<h1 id="v2ray多用户配置"><a href="#v2ray多用户配置" class="headerlink" title="v2ray多用户配置"></a>v2ray 多用户配置</h1><blockquote>
<p>本文转载自：<a href="https://v2raytech.com/v2ray-multiple-users/%EF%BC%8C%E5%A6%82%E6%96%87%E4%B8%AD%E5%86%85%E5%AE%B9%E6%9C%89%E9%94%99%E8%AF%AF%E8%AF%B7%E5%88%B0%E5%8E%9F%E6%96%87%E6%9F%A5%E7%9C%8B%E5%8E%9F%E5%A7%8B%E7%89%88(%E6%9C%80%E6%96%B0%E7%89%88)">https://v2raytech.com/v2ray-multiple-users/，如文中内容有错误请到原文查看原始版 (最新版)</a></p>
</blockquote>
<blockquote>
<p>如有问题，欢迎到 <a href="https://hijk.club/">网络跳越论坛</a> 或 TG 群组 <a href="https://t.me/hijkclub">https://t.me/hijkclub</a> 交流</p>
</blockquote>
<p>部分网友自行搭建好 v2ray 科学上网环境后，不好意思拒绝朋友的分享请求，所以想设置一个不同的端口或者 id 再分享。类似的需求 v2ray 都是支持的，配置起来也不算麻烦。本文就 v2ray 普通版、伪装版分别介绍 v2ray 多用户配置。</p>
<p>注意：自行更改配置文件需要用到 vi/vim/nano 等编辑器，或者把配置文件下载到本地修改，修改完再上传到服务端。下载和上传教程请参考：<a href="https://v2xtls.org/bitvise%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/">Bitvise 连接 Linux 服务器教程</a> (Windows 用户)、<a href="https://v2xtls.org/mac%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5linux%E6%95%99%E7%A8%8B/">Mac 电脑连接 Linux 教程</a> (Mac 用户)。</p>
<h2 id="普通版多用户配置"><a href="#普通版多用户配置" class="headerlink" title="普通版多用户配置"></a>普通版多用户配置</h2><p><a href="https://v2xtls.org/v2ray%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC/">v2ray 一键脚本</a> 运行完后，会输出配置文件路径，默认是 <code>/etc/v2ray/config.json</code>，其内容类似这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "log": {</span><br><span class="line">    "loglevel": "info",</span><br><span class="line">    "access": "/var/log/v2ray/access.log",</span><br><span class="line">    "error": "/var/log/v2ray/error.log"</span><br><span class="line">  },</span><br><span class="line">  "inbounds": [{</span><br><span class="line">    "port": 12345,</span><br><span class="line">    "protocol": "vmess",</span><br><span class="line">    "settings": {</span><br><span class="line">      "clients": [</span><br><span class="line">        {</span><br><span class="line">          "id": "6be0aa25-09c1-4d8b-a96f-75cd3485021f",</span><br><span class="line">          "level": 1,</span><br><span class="line">          "alterId": 53</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }],</span><br><span class="line">  "outbounds": [{</span><br><span class="line">    "protocol": "freedom",</span><br><span class="line">    "settings": {}</span><br><span class="line">  },{</span><br><span class="line">    "protocol": "blackhole",</span><br><span class="line">    "settings": {},</span><br><span class="line">    "tag": "blocked"</span><br><span class="line">  }],</span><br><span class="line">  "routing": {</span><br><span class="line">    "rules": [</span><br><span class="line">      {</span><br><span class="line">        "type": "field",</span><br><span class="line">        "ip": ["geoip:private"],</span><br><span class="line">        "outboundTag": "blocked"</span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下文教程的修改都是参考这个文件，如果出现问题，请注意与原来文件的差异。</p>
<p>v2ray 多用户分成两种：同端口不同 id，不同端口不同 id。v2ray 两种类型都支持，接下来分别做介绍。</p>
<h3 id="同端口不同id"><a href="#同端口不同id" class="headerlink" title="同端口不同id"></a>同端口不同 id</h3><p>这是最简单的配置多用户方式。方法是编辑 <code>/etc/v2ray/config.json</code> 文件，在”<strong>clients</strong>“一节中增加新增用户配置。例如在上面配置基础上增加一个用户：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "log": {</span><br><span class="line">    "loglevel": "info",</span><br><span class="line">    "access": "/var/log/v2ray/access.log",</span><br><span class="line">    "error": "/var/log/v2ray/error.log"</span><br><span class="line">  },</span><br><span class="line">  "inbounds": [{</span><br><span class="line">    "port": 12345,</span><br><span class="line">    "protocol": "vmess",</span><br><span class="line">    "settings": {</span><br><span class="line">      "clients": [</span><br><span class="line">        {</span><br><span class="line">          "id": "6be0aa25-09c1-4d8b-a96f-75cd3485021f",</span><br><span class="line">          "level": 1,</span><br><span class="line">          "alterId": 53</span><br><span class="line">        }, # 逗号不能少</span><br><span class="line">        # 下面是新增的内容</span><br><span class="line">        {</span><br><span class="line">          "id": "2a1292fd-07be-37e7-af20-57668b4a546a",  # id可以用 /usr/bin/v2ray/v2ctl uuid生成</span><br><span class="line">          "level": 1, # 这个不用改</span><br><span class="line">          "alterId": 63 # 建议50-150之间的一个整数</span><br><span class="line">        }</span><br><span class="line">        # 新增内容结束</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }],</span><br><span class="line">  # 下面的内容保持不变</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong>“#” 和后面的东西都不能出现在配置文件中，上面只是为了解释说明。</p>
<p>编辑好文件后，重启 v2ray：<code>systemctl restart v2ray</code>。如果命令失败，或者 <code>netstat -nltp | grep v2ray</code> 输出为空，说明配置文件有错误，请仔细检查，改好后再重启。</p>
<p>接下来就可以用新的 id 和 alterId 配置客户端，其余信息保持不变。</p>
<h3 id="不同端口不同id"><a href="#不同端口不同id" class="headerlink" title="不同端口不同id"></a>不同端口不同 id</h3><p>如果希望端口也不一样，请按照如下步骤做：</p>
<p>\1. 首先编辑 <code>/etc/v2ray/config.json</code> 文件，按照”<strong>inbounds</strong>“格式新增入口和用户。例如新增一个端口和用户后，配置文件变成：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "log": {</span><br><span class="line">    "loglevel": "info",</span><br><span class="line">    "access": "/var/log/v2ray/access.log",</span><br><span class="line">    "error": "/var/log/v2ray/error.log"</span><br><span class="line">  },</span><br><span class="line">  "inbounds": [{</span><br><span class="line">    "port": 12345,</span><br><span class="line">    "protocol": "vmess",</span><br><span class="line">    "settings": {</span><br><span class="line">      "clients": [</span><br><span class="line">        {</span><br><span class="line">          "id": "6be0aa25-09c1-4d8b-a96f-75cd3485021f",</span><br><span class="line">          "level": 1,</span><br><span class="line">          "alterId": 53</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }, # 逗号不能省，原来这里是"}],"</span><br><span class="line">  # 以下是新增的配置</span><br><span class="line">  {</span><br><span class="line">    "port": 54321, # 端口是1000-65535之间的一个整数</span><br><span class="line">    "protocol": "vmess", # 也可以改成其他协议，如果你知道怎么配置的话</span><br><span class="line">    "settings": {</span><br><span class="line">      "clients": [</span><br><span class="line">        {</span><br><span class="line">          "id": "24813255-228d-b0e0-c3fa-e5d4c9defda1", # id可以用 /usr/bin/v2ray/v2ctl uuid生成</span><br><span class="line">          "level": 1, # 0或1都可以</span><br><span class="line">          "alterId": 57 # 建议50-150之间的一个整数</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }],</span><br><span class="line">  # 新增内容结束</span><br><span class="line">  # 下面的内容保持不变</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong>“#” 和后面的东西都不能出现在配置文件中，上面只是为了解释说明。</p>
<p>编辑好文件后，重启 v2ray：<code>systemctl restart v2ray</code>。如果命令失败，或者 <code>netstat -nltp | grep v2ray</code> 输出为空，说明配置文件有错误，请仔细检查，改好后再重启。</p>
<p>\2. 设置防火墙放行新增的端口。CentOS 系统命令是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=54321/tcp # 注意：54321要改成你的端口号</span><br><span class="line">firewall-cmd --permanent --add-port=54321/udp # 注意：54321要改成你的端口号</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>

<p>Ubuntu 系统命令是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ufw allow 54321/tcp # 注意：54321要改成你的端口</span><br><span class="line">ufw allow 54321/udp # 注意：54321要改成你的端口</span><br></pre></td></tr></tbody></table></figure>

<p>接下来用新的端口、id 和 alterId 配置客户端，其余信息保持不变。</p>
<h2 id="带伪装多用户配置"><a href="#带伪装多用户配置" class="headerlink" title="带伪装多用户配置"></a>带伪装多用户配置</h2><p><strong>同端口不同 id 的配置和普通版操作方法一样</strong>，配置好后重启 v2ray 就行了，这里不再重复。</p>
<p>接下来说说不同端口不同 id 的情形。伪装有了 Nginx 的介入，所以有多种情况，这里只介绍最简单的一种实现方式。</p>
<ol>
<li><p>编辑 <code>/etc/v2ray/config.json</code> 文件，按照 <a href="https://v2xtls.org/v2ray%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/#single_port">普通版同端口不同 id</a> 中的方法添加用户；</p>
</li>
<li><p>编辑 <code>/etc/nginx/conf.d/你的域名.conf</code> 文件，找到 “**listen 443 ssl http2;**” 这一行，在这行下面添加 “listen 新的端口号 ssl http2;” 一行（新的端口号要改成整数，例如 8443，不能是 443）。然后保存文件， <code>nginx -t</code> 检查配置有没有错误，没有错误的话重启 Nginx：<code>systemctl restart nginx</code>；</p>
</li>
<li><p>设置防火墙放行端口，请参考 <a href="https://v2xtls.org/v2ray%E5%A4%9A%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE/#set_firewall">普通版设置防火墙</a> 中的命令。</p>
</li>
</ol>
<p>接下来用新的端口、id 和 alterId 配置客户端，其余信息保持不变。</p>
<p>如果你想添加多个端口或多个用户，重复上面的过程就可以了。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>V2Ray 配置教程</title>
    <url>/posts/39483.html</url>
    <content><![CDATA[<h1 id="V2Ray-配置教程"><a href="#V2Ray-配置教程" class="headerlink" title="V2Ray 配置教程"></a>V2Ray 配置教程</h1><p>V2Ray 是继 Shadowsocks (R) 后又一个体验很棒、功能非常强大的科学上网工具，近年来受到网友的广泛关注和喜爱。敏感时期，基本上只有 <a href="https://tlanyan.pp.ua/v2ray-traffic-mask/">V2ray 伪装</a> 或 <a href="https://tlanyan.pp.ua/trojan-tutorial/">trojan</a> 能提供十分稳的服务，推荐使用。</p>
<p>本教程详细介绍 V2ray 的特点，安装和配置过程，让读者能迅速上手和使用 V2ray。在本文基础上，建议网友继续阅读 <a href="https://tlanyan.pp.ua/v2ray-traffic-mask/">V2ray 高级技巧：流量伪装</a>，以及最新出炉的 <a href="https://tlanyan.pp.ua/introduce-v2ray-vless-protocol/">VLESS 协议和 XTLS 黑科技</a>，体验更稳的上外网方式。v2ray 客户端下载请访问：<a href="https://tlanyan.pp.ua/v2ray-clients-download">V2ray 客户端</a>。</p>
<h2 id="V2Ray-简介"><a href="#V2Ray-简介" class="headerlink" title="V2Ray 简介"></a>V2Ray 简介</h2><p><code>V2Ray</code> 是近几年十分流行的网络工具，其功能强大，用途不限于突破防火墙，但因其能有效翻墙而广为人知。<code>V2Ray</code> 有如下大放异彩的特点：</p>
<ul>
<li>开源。<code>V2Ray</code> 是 <code>Project V</code> 的核心工具，源代码开源；</li>
<li>多协议支持。传输层支持 TCP、mKCP、WebSocket 等，上层协议支持 Socks、Shadowsocks、以及自定义的 <code>VMess</code> 等；</li>
<li>多入口和多出口。<code>V2Ray</code> 可同时支持多个入站和出站协议，每个协议独立工作；</li>
<li>多平台支持。原生支持 Windows、Linux、MacOS 三大常用平台，安卓、iOS 两大移动平台有丰富的第三方工具；</li>
<li>隐蔽性。<code>V2Ray</code> 流量可伪装成网页流量，更难被检测和干扰。</li>
</ul>
<p>与另一个知名的翻墙工具 <code>Shadowsocks(R)</code> 相比，V2ray 和 SSR 区别在于：</p>
<ol>
<li><code>V2Ray</code> 是一个框架 / 平台，而 <code>Shadowsocks(R)</code> 是一个代理工具；</li>
<li><code>V2Ray</code> 功能强大配置复杂，<code>Shadowsocks(R)</code> 简单易用；</li>
<li><code>V2Ray</code> 性能更好，协议支持更完善。</li>
</ol>
<p>一句话总结：<code>V2Ray</code> 更好更强大，但更难上手和用好。</p>
<blockquote>
<p>因 v2ray 原开发者长期不上线，社区为了维护方便创建了 v2fly，v2fly 的官网是 <a href="https://www.v2fly.org/">https://www.v2fly.org</a>。大名鼎鼎的 v2ray 白话文、一键安装脚本等都出自 v2fly。目前 v2ray 项目主要由 v2fly 推动，v2fly 的代码更新也会合并到 v2ray 项目库中，一般可以认为 v2ray 和 v2fly 是同一个组织。</p>
<p>V2ray 发布了新版 VLESS 协议，详情请参考 <a href="https://tlanyan.pp.ua/introduce-v2ray-vless-protocol/">VLESS 协议介绍和使用教程</a></p>
</blockquote>
<h2 id="一、服务器配置"><a href="#一、服务器配置" class="headerlink" title="一、服务器配置"></a>一、服务器配置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>买一台位于境外的服务器。</li>
<li>在本地使用 SSH 连到服务器。</li>
</ul>
<h3 id="安装V2Ray"><a href="#安装V2Ray" class="headerlink" title="安装V2Ray"></a>安装 V2Ray</h3><p>在 CentOS、Ubuntu 等常用 Linux 系统上，直接执行如下命令安装 <code>V2Ray</code>（如果已安装则更新程序）：</p>
<pre><code>bash &lt;(curl -sL https://raw.githubusercontent.com/hijkpw/scripts/master/goV2.sh)
</code></pre>
<p>安装完成后，安装成功后会自动生成的配置文件，配置文件为 <code>/etc/v2ray/config.json</code>。<br>cat 命令可查看内容：<code>cat /etc/v2ray/config.json</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao v2ray]<span class="comment"># cat config.json </span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"inbounds"</span>: [{</span><br><span class="line">    <span class="string">"port"</span>: 12345,</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: {</span><br><span class="line">      <span class="string">"clients"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="string">"id"</span>: <span class="string">"9e3939be-76db-4757-a95e-db5158725eaa"</span>,</span><br><span class="line">          <span class="string">"level"</span>: 1,</span><br><span class="line">          <span class="string">"alterId"</span>: 64</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }],</span><br><span class="line">  <span class="string">"outbounds"</span>: [{</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: {}</span><br><span class="line">  },{</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: {},</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">  }],</span><br><span class="line">  <span class="string">"routing"</span>: {</span><br><span class="line">    <span class="string">"rules"</span>: [</span><br><span class="line">      {</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">        <span class="string">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>配置文件中”inbounds” 下的这几项信息需要留意：<br>port（<code>端口</code>）、clients 中的 id（<code>用户id</code>）和 alterId（<code>额外id</code>），它们将在配置客户端时用到。</p>
<p>配置文件无需任何改动即可正常使用。接下来防火墙放行监听的端口，设置开机启动并运行 <code>V2Ray</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># firewalld放行端口（适用于CentOS7/8）</span></span><br><span class="line">firewall-cmd --permanent --add-port=12345/tcp <span class="comment"># 12345改成你配置文件中的端口号</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># ufw放行端口（适用于ubuntu）</span></span><br><span class="line">ufw allow 12345/tcp <span class="comment"># 12345改成你的端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iptables 放行端口（适用于CentOS 6/7）</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 12345 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行v2ray</span></span><br><span class="line">systemctl start v2ray</span><br></pre></td></tr></tbody></table></figure>

<p><code>ss -ntlp | grep v2ray</code> 命令可以查看 v2ray 是否正在运行。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@paopao v2ray]<span class="comment"># ss -ntlp | grep v2ray</span></span><br><span class="line">LISTEN      0      128       *:12345   *:*     <span class="built_in">users</span>:(("v2ray",pid=<span class="number">9544</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>如果输出如上面的内容，则成功了。<br>如果输出为空，大概率是被 selinux 限制了，解决办法如下：</p>
<p>1. 禁用 selinux：<code>setenforce 0</code>;</p>
<p>2. 重启 v2ray：<code>systemctl restart v2ray</code></p>
<p>到此，服务端应该配置好了。如果服务器商层面还有防火墙（阿里云 / Google/AWS 购买的 vps），请登录网页后台，放行 v2ray 的端口。</p>
<h2 id="二、Windows客户端：V2rayN-配置"><a href="#二、Windows客户端：V2rayN-配置" class="headerlink" title="二、Windows客户端：V2rayN 配置"></a>二、Windows 客户端：V2rayN 配置</h2><p>V2rayN 是一个基于 <a href="https://v2raytech.com/category/v2ray/">V2ray</a> 核心的 Windows 客户端，功能强大且支持多种协议。V2rayN 4.0 版本开始取消 PAC 模式，给许多用户使用上带来困难。鉴于此，本文介绍最新 V2rayN 4.12 正式版的配置教程，让你能顺利切换 PAC 模式和全局模式。</p>
<h3 id="V2rayN-4-12-配置教程"><a href="#V2rayN-4-12-配置教程" class="headerlink" title="V2rayN 4.12 配置教程"></a>V2rayN 4.12 配置教程</h3><p>到这个页面 <a href="https://v2xtls.org/v2ray-windows%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/">V2Ray windows 客户端下载</a> 下载 V2rayN 并解压。V2rayN 是绿色软件，解压后直接能用，不需要安装。</p>
<p>首先。进入解压后的 V2rayN-core 目录，双击”v2rayN” 文件，程序启动后会最小化到右下角的托盘。双击蓝色的 V 字小图标，打开 V2rayN 的主界面：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E4%B8%BB%E7%95%8C%E9%9D%A2.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt="v2rayN主界面"></a></p>
<p>v2rayN 主界面</p>
<p>接下来，<strong>如果用了 VLESS 或者 XTLS 技术，请更换为 Xray 内核</strong>，否则可能无法正常连接到节点！操作为：点击 “设置” -&gt; “参数设置” -&gt; “V2rayN 设置” -&gt; “Core 类型”，选择 “Xray_core”，然后点击确定：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E5%88%87%E6%8D%A2Xray%E5%86%85%E6%A0%B8.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E5%88%87%E6%8D%A2Xray%E5%86%85%E6%A0%B8.png" alt="v2rayN切换Xray内核"></a></p>
<p>v2rayN 切换 Xray 内核</p>
<p>接着添加新的 V2ray 节点：点击界面上方的 “服务器”，按照自己节点类型选择，<strong>注意 VMess 服务器和 VLESS 服务器是不同的</strong>！</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2ray%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2ray%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="v2ray添加新服务器"></a></p>
<p>v2ray 添加新服务器</p>
<p>这里以我们以手动 VLESS 服务器为例进行说明，根据 V2ray 节点信息填写地址、端口、用户 ID 等、流控等信息。VLESS 协议不需要额外 id（alterID），所以不需要填写。反过来说如果你看到要填写额外 ID，说明服务器类型选错了！</p>
<p>底层传输安全那里，建议跳过证书验证为 false，证书过期或者上不了外网再改成 true。SNI 填写伪装域名，也就是保持和伪装域名那里填的一样就可以了：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E6%B7%BB%E5%8A%A0VLESS%E6%9C%8D%E5%8A%A1%E5%99%A8.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E6%B7%BB%E5%8A%A0VLESS%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="v2rayN添加VLESS服务器"></a></p>
<p>v2rayN 添加 VLESS 服务器</p>
<p>配置好后点击确定，主界面出现了节点的简要信息。可以双击节点那一行再次出来上面的配置界面修改配置，也可以点击右键删除、移动该节点：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN%E6%B7%BB%E5%8A%A0%E4%BA%86%E8%8A%82%E7%82%B9%E7%95%8C%E9%9D%A2.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN%E6%B7%BB%E5%8A%A0%E4%BA%86%E8%8A%82%E7%82%B9%E7%95%8C%E9%9D%A2.png" alt="V2rayN添加了节点界面"></a></p>
<p>V2rayN 添加了节点界面</p>
<p>配置好节点后需要设置系统代理才能让浏览器访问外网，操作为：右下角托盘找到 v2rayN 图标，在图标上点击右键，找到 “系统代理” ，点击 “自动配置系统代理”，此时图标会变成红色：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86.png" alt="v2rayN设置系统代理"></a></p>
<p>v2rayN 设置系统代理</p>
<p>默认 v2rayN 是全局代理，也就是不管访问什么网站，都是走节点流量。大部分网友之前用 v2rayN 都是 PAC 模式，v2rayN 4.0 版本开始取消了 PAC，因此需要下面的操作来代替 PAC：</p>
<p>主界面点击 “设置” -&gt; “路由设置” -&gt; “基础功能” -&gt; “一键导入基础规则”，然后点击 “确定”：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN%E8%AE%BE%E7%BD%AEPAC%E6%A8%A1%E5%BC%8F.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN%E8%AE%BE%E7%BD%AEPAC%E6%A8%A1%E5%BC%8F.png" alt="V2rayN设置PAC模式"></a></p>
<p>V2rayN 设置 PAC 模式</p>
<blockquote>
<p>域名策略一般建议选 “IPIfNotMatch” 或者 “ASIS”，也可以按照需求选其他的</p>
</blockquote>
<p>接下来访问百度、淘宝等国外网站都是直连，不会再走代理了。如果想让某个网站走代理而不是直连，那么在上图中 “代理的 Domain 或 IP” 的左边加一行：<code>domain:网站域名</code>，例如添加本站走代理：domain:v2raytech.com，然后点击 “确定”。</p>
<p>想换成所有网站都走代理又该怎么操作呢？方法也很简单：上图中 “直连的 Domain 或 IP”，把左边和右边输入框的行都清空，然后点击 “确定”。</p>
<p>V2ray 节点没挂，你配置又没问题的话，接下来应该能愉快的上外网了。</p>
<blockquote>
<p>如果不想上外网了，右下角托盘找到 v2rayN 图标，在图标上点击右键，找到 “系统代理” ，点击 “清除系统代理”。</p>
</blockquote>
<h3 id="查看-V2rayN-日志"><a href="#查看-V2rayN-日志" class="headerlink" title="查看 V2rayN 日志"></a>查看 V2rayN 日志</h3><p>配置好后不能上外网，请先参考 <a href="https://v2xtls.org/pc%e7%ab%af%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98/">PC 端科学上网常见问题</a>，不能解决再复制 V2rayN 日志错误信息，然后在本教程下面留言，或者到 <a href="https://hijk.club/">网络跳越论坛</a> 或 tg 群组 <a href="https://t.me/hijkclub">https://t.me/hijkclub</a> 交流。</p>
<p>V2rayN 的日志在主界面下面的黑框框里，不能上外网的话一般会输出类似下面的日志：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E6%97%A5%E5%BF%97.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN%E6%97%A5%E5%BF%97.png" alt="v2rayN日志"></a></p>
<p>v2rayN 日志</p>
<h3 id="V2rayN-报病毒"><a href="#V2rayN-报病毒" class="headerlink" title="V2rayN 报病毒"></a>V2rayN 报病毒</h3><p>由于一些原因，V2rayN 在 Windows 上可能会报病毒导致无法正常使用：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/windows%E6%8F%90%E7%A4%BAv2rayN%E7%97%85%E6%AF%92.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/windows%E6%8F%90%E7%A4%BAv2rayN%E7%97%85%E6%AF%92.png" alt="windows提示v2rayN病毒"></a></p>
<p>windows 提示 v2rayN 病毒</p>
<p>如果不放心 V2rayN，可以换其他客户端，比如 <a href="https://v2xtls.org/clash-for-windows%e9%85%8d%e7%bd%aev2ray%e6%95%99%e7%a8%8b/">Clash for Windows</a>，或者试试从官网下载的版本。但一般来说这都是 Windows 的误报，添加到例外即可。操作为：点击右下角托盘的 Windows 安全中心 -&gt; “病毒和威胁防护” -&gt; “保护历史记录” -&gt; “已隔离威胁” -&gt; “操作”，点击 “还原”。如果 V2rayN 界面里还是提示病毒，找到同一个界面，操作点击 “允许”：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2021/03/%E8%BF%98%E5%8E%9F%E7%97%85%E6%AF%92%E6%8F%90%E7%A4%BA.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/%E8%BF%98%E5%8E%9F%E7%97%85%E6%AF%92%E6%8F%90%E7%A4%BA-1024x794.png" alt="还原病毒提示"></a></p>
<p>还原病毒提示</p>
<p>尽管移除了 PAC 模式，但 V2rayN 还是 Windows 上最好用的 V2ray、trojan 客户端之一，非常推荐！</p>
<h2 id="三、安卓客户端：V2rayNG-配置"><a href="#三、安卓客户端：V2rayNG-配置" class="headerlink" title="三、安卓客户端：V2rayNG 配置"></a>三、安卓客户端：V2rayNG 配置</h2><p><strong>v2rayNG</strong> 是安卓平台上一款基于 v2ray 核心的简洁、功能强大的客户端。本文通过图文详细介绍其安装和配置过程，希望对在安卓手机上使用 v2rayNG 进行科学上网的网友有帮助。如果配置完后依然无法上外网，请参考：<a href="https://v2xtls.org/%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98/">科学上网常见问题</a>。</p>
<p>阅读本教程的前提：</p>
<ol>
<li>已有服务端信息，可参考 <a href="https://v2xtls.org/v2ray%e4%b8%80%e9%94%ae%e8%84%9a%e6%9c%ac/">v2ray 一键脚本</a> 或 <a href="https://v2xtls.org/%e8%8e%b7%e5%8f%96%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bf%a1%e6%81%af/">获取科学上网服务端信息</a></li>
<li>下载 v2rayNG，未下载的请到这个页面下载：<a href="https://v2xtls.org/v2ray%e5%ae%89%e5%8d%93%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/">V2Ray 安卓客户端下载</a></li>
</ol>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1. 安装下载的 v2rayNG apk 文件；</p>
<p>2. 打开软件，进入主界面（即配置文件界面）：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E4%B8%BB%E7%95%8C%E9%9D%A2-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E4%B8%BB%E7%95%8C%E9%9D%A2-576x1024-1.png" alt="v2rayNG主界面"></a></p>
<p>v2rayNG 主界面</p>
<p>3. 点右上方的 “+”，可以看到 V2rayNG 支持从二维码、剪切板导入，也可以手动配置 vmess、ss 等，还支持订阅（在自定义配置中）：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8F%9C%E5%8D%95-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8F%9C%E5%8D%95-576x1024-1.png" alt="v2rayNG服务器菜单"></a></p>
<p>v2rayNG 服务器菜单</p>
<p>4. 本教程以手动输入为例，点击 “手动输入 [vmess]”，进入服务器填写界面。别名随意填写，例如 “香港 vps”。地址、端口、用户 id、额外 id 按照服务端的信息填写（不知道这些信息填什么请参考参考 <a href="https://v2xtls.org/%e8%8e%b7%e5%8f%96%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bf%a1%e6%81%af/">获取科学上网服务端信息</a>），这几项非常重要，不要填错！</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE-576x1024-1.png" alt="v2rayNG基础配置"></a></p>
<p>v2rayNG 基础配置</p>
<p>后半部分是高级选项，一般不用填写（加密方式一般选 auto）。</p>
<blockquote>
<p>Just My Socks V2ray 加密方式选 none 或者 auto 上不了网，请改成 chacha20-ietf-poly1305</p>
</blockquote>
<p><strong>如果使用了伪装</strong>，传输协议选 ws，伪装类型保持默认的 none，“功能设置” 下面填入域名、伪装路径，同时底层传输安全选 tls<strong>（不是伪装就不要选！）</strong>：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE-576x1024-1.jpeg" alt="v2rayNG高级配置"></a></p>
<p>v2rayNG 高级配置</p>
<p>5. 点界面右上角的勾保存配置。界面回到主界面，点右下角的 v2rayNG 图标，启动程序。如果出现网络连接请求，点击确定：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82-576x1024-1.jpeg" alt="v2rayNG网络连接请求"></a></p>
<p>v2rayNG 网络连接请求</p>
<p>6. 一些高级设置在左侧菜单的 “设置” 中，建议将域名策略改成”Asis”，勾选 “启用速度显示” 打开 vpn 流量速度显示，其他不懂的就不用管：</p>
<p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE-576x1024-1.jpeg" alt="v2rayNG全局设置"></a></p>
<p>v2rayNG 全局设置</p>
<p>配置好且服务端没有问题的话，打开浏览器应该能正常访问 google、youtube 等网站了。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell 添加 ssh 代理实现远程登录被墙 IP</title>
    <url>/posts/82d0e3ec.html</url>
    <content><![CDATA[<p>如果购买的 VPS 服务器 IP 被墙，此时发现无法通过 Xshell 远程 ssh 登录服务器了，需要在 Xshell 里设置下代理转发，就能正常登录被墙 IP 的服务器了。</p>
<span id="more"></span>

<p>操作过程如图所示：</p>
<p>SSH –&gt; 代理 –&gt; 浏览代理服务器 –&gt; 添加 –&gt; 填写对应信息。</p>
<p>名称随便填，类型是 SOCKS5，主机填 127.0.0.1，如果用 V2Ray，则端口是 10808，如果用的 SS，则端口是 1080。前提保证 V2Ray 或 SS 客户端能正常使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061040613.png" alt="image-20221106104019517"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>亲测好用的 V2Ray 一键配置脚本</title>
    <url>/posts/e2806079.html</url>
    <content><![CDATA[<p>V2Ray 一键配置脚本，亲测非常好用，赶紧收藏一下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>完美救活 VPS 被墙 IP：VLESS+WS+TLS+CDN (Cloudflare)</title>
    <url>/posts/6fed1818.html</url>
    <content><![CDATA[<h3 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h3><ul>
<li>拥有一个域名（如，<a href="http://www.liupaopao.cf)/">www.liupaopao.cf）</a></li>
<li>拥有 Cloudflare 账号</li>
<li>域名通过 Cloudflare 成功解析到被墙 IP（如，198.211.27.21）</li>
</ul>
<span id="more"></span>

<h3 id="配置Cloudflare"><a href="#配置Cloudflare" class="headerlink" title="配置Cloudflare"></a>配置 Cloudflare</h3><ol>
<li>注册登录 Cloudflare，添加站点 <a href="http://www.liupaopao.cf,在dns里添加两个解析记录,ip指向vps被墙ip,此时需要关闭cloudflare代理状态,即小云朵要显示为灰色(所有配置完成后,再打开代理状态,把小云朵点亮)./">www.liupaopao.cf，在 DNS 里添加两个解析记录，IP 指向 VPS 被墙 IP，此时需要关闭 Cloudflare 代理状态，即小云朵要显示为灰色（所有配置完成后，再打开代理状态，把小云朵点亮）。</a></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211060945384.png" alt="image-20221106094553256"></p>
<ol start="2">
<li><p>在 SSL/TLS 里选择加密模式为最后一个：完全（严格）。</p>
</li>
<li><p>在速度–&gt; 优化里，勾选上 JavaScript、CS、HTML：</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211060952645.png" alt="image-20221106095209545"></p>
<ol start="4">
<li>登录注册域名的网站将域名解析服务器地址更换为图中 Cloudflare 服务器地址</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211060954693.png" alt="image-20221106095441599"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211060957716.png" alt="image-20221106095715623"></p>
<h3 id="配置VLESS-WS-TLS"><a href="#配置VLESS-WS-TLS" class="headerlink" title="配置VLESS+WS+TLS"></a>配置 VLESS+WS+TLS</h3><h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wget -P /root -N --no-check-certificate "https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh" &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh</span><br></pre></td></tr></tbody></table></figure>

<h4 id="安装日志"><a href="#安装日志" class="headerlink" title="安装日志"></a>安装日志</h4><p>（安装时前两步可能比较慢，需耐心等待，下载断掉就多尝试几次。尽量保持干净的服务器环境，遇到其他问题建议先重装服务器试试。）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@PAOPAO:~# wget -P /root -N --no-check-certificate "https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh" &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh</span><br><span class="line">--2022-11-04 01:26:21--  https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh</span><br><span class="line">Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 2606:50c0:8000::154, 2606:50c0:8001::154, 2606:50c0:8002::154, ...</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|2606:50c0:8000::154|:443... failed: No route to host.</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|2606:50c0:8001::154|:443... failed: No route to host.</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|2606:50c0:8002::154|:443... failed: No route to host.</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|2606:50c0:8003::154|:443... failed: No route to host.</span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 168118 (164K) [text/plain]</span><br><span class="line">Saving to: ‘/root/install.sh’</span><br><span class="line"></span><br><span class="line">install.sh                        100%[==========================================================&gt;] 164.18K  --.-KB/s    in 0.001s  </span><br><span class="line"></span><br><span class="line">Last-modified header missing -- time-stamps turned off.</span><br><span class="line">2022-11-04 01:26:48 (139 MB/s) - ‘/root/install.sh’ saved [168118/168118]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============================================================== </span><br><span class="line">作者:mack-a </span><br><span class="line">当前版本:v2.6.5 </span><br><span class="line">Github:https://github.com/mack-a/v2ray-agent </span><br><span class="line">描述:八合一共存脚本</span><br><span class="line">============================================================== </span><br><span class="line">                        推广区                       </span><br><span class="line">AFF捐赠：https://github.com/mack-a/v2ray-agent/blob/master/documents/donation_aff.md</span><br><span class="line"> </span><br><span class="line">虚拟币捐赠：0xB08b731653515b083deE362fefFc45d5eb96c35d</span><br><span class="line"> </span><br><span class="line">推广可联系TG：https://t.me/mackaff </span><br><span class="line">============================================================== </span><br><span class="line">1.安装 </span><br><span class="line">2.任意组合安装 </span><br><span class="line">-------------------------工具管理----------------------------- </span><br><span class="line">4.账号管理 </span><br><span class="line">5.更换伪装站 </span><br><span class="line">6.更新证书 </span><br><span class="line">7.更换CDN节点 </span><br><span class="line">8.IPv6分流 </span><br><span class="line">9.WARP分流 </span><br><span class="line">10.流媒体工具 </span><br><span class="line">11.添加新端口 </span><br><span class="line">12.BT下载管理 </span><br><span class="line">13.切换alpn </span><br><span class="line">14.域名黑名单 </span><br><span class="line">-------------------------版本管理----------------------------- </span><br><span class="line">15.core管理 </span><br><span class="line">16.更新脚本 </span><br><span class="line">17.安装BBR、DD脚本 </span><br><span class="line">-------------------------脚本管理----------------------------- </span><br><span class="line">18.查看日志 </span><br><span class="line">19.卸载脚本 </span><br><span class="line">============================================================== </span><br><span class="line">快捷方式创建成功，可执行[vasma]重新打开脚本 </span><br><span class="line">请选择:1</span><br><span class="line"></span><br><span class="line">功能 1/1 : 选择核心安装 </span><br><span class="line"></span><br><span class="line">============================================================== </span><br><span class="line">1.Xray-core </span><br><span class="line">2.v2ray-core </span><br><span class="line">============================================================== </span><br><span class="line">请选择:1</span><br><span class="line"></span><br><span class="line">进度  2/13 : 安装工具 </span><br><span class="line"> ---&gt; 检查、安装更新【新机器会很慢，如长时间无反应，请手动停止后重新执行】 </span><br><span class="line"> ---&gt; 安装curl </span><br><span class="line"> ---&gt; 安装socat </span><br><span class="line"> ---&gt; 安装jq </span><br><span class="line"> ---&gt; 安装binutils </span><br><span class="line"> ---&gt; 安装ping6 </span><br><span class="line"> ---&gt; 安装qrencode </span><br><span class="line"> ---&gt; 安装lsb-release </span><br><span class="line"> ---&gt; 安装nginx </span><br><span class="line">Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install.</span><br><span class="line">Executing: /lib/systemd/systemd-sysv-install enable nginx</span><br><span class="line"> ---&gt; 安装semanage </span><br><span class="line"> ---&gt; 安装acme.sh </span><br><span class="line"></span><br><span class="line">进度  3/13 : 初始化Nginx申请证书配置 </span><br><span class="line"></span><br><span class="line">请输入要配置的域名 例: www.v2ray-agent.com ---&gt; </span><br><span class="line">域名:www.liupaopao.cf</span><br><span class="line"></span><br><span class="line">请输入自定义端口[例: 2083]，自定义端口后只允许使用DNS申请证书，[回车]使用443 </span><br><span class="line">端口:</span><br><span class="line"></span><br><span class="line"> ---&gt; 端口: 443 </span><br><span class="line"> ---&gt; Xray关闭成功 </span><br><span class="line"> ---&gt; Nginx启动成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 检查域名ip中 </span><br><span class="line"> ---&gt; Nginx关闭成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 未检测到当前域名的ip </span><br><span class="line"> ---&gt; 请依次进行下列检查 </span><br><span class="line"> ---&gt;  1.检查域名是否书写正确 </span><br><span class="line"> ---&gt;  2.检查域名dns解析是否正确 </span><br><span class="line"> ---&gt;  3.如解析正确，请等待dns生效，预计三分钟内生效 </span><br><span class="line"> ---&gt;  4.如报Nginx启动问题，请手动启动nginx查看错误，如自己无法处理请提issues </span><br><span class="line"></span><br><span class="line"> ---&gt; 如以上设置都正确，请重新安装纯净系统后再次尝试 </span><br><span class="line"> ---&gt; 请检查防火墙规则是否开放443、80</span><br><span class="line"> </span><br><span class="line">是否通过脚本修改防火墙规则开放443、80端口？[y/n]:y</span><br><span class="line"> ---&gt; Nginx启动成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 检查域名ip中 </span><br><span class="line"> ---&gt; Nginx关闭成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 未检测到当前域名的ip </span><br><span class="line"> ---&gt; 请依次进行下列检查 </span><br><span class="line"> ---&gt;  1.检查域名是否书写正确 </span><br><span class="line"> ---&gt;  2.检查域名dns解析是否正确 </span><br><span class="line"> ---&gt;  3.如解析正确，请等待dns生效，预计三分钟内生效 </span><br><span class="line"> ---&gt;  4.如报Nginx启动问题，请手动启动nginx查看错误，如自己无法处理请提issues </span><br><span class="line"></span><br><span class="line"> ---&gt; 如以上设置都正确，请重新安装纯净系统后再次尝试 </span><br><span class="line"> ---&gt; 请检查防火墙规则是否开放443、80</span><br><span class="line"> </span><br><span class="line">是否通过脚本修改防火墙规则开放443、80端口？[y/n]:y</span><br><span class="line"> ---&gt; Nginx启动成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 检查域名ip中 </span><br><span class="line"> ---&gt; Nginx关闭成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 未检测到当前域名的ip </span><br><span class="line"> ---&gt; 请依次进行下列检查 </span><br><span class="line"> ---&gt;  1.检查域名是否书写正确 </span><br><span class="line"> ---&gt;  2.检查域名dns解析是否正确 </span><br><span class="line"> ---&gt;  3.如解析正确，请等待dns生效，预计三分钟内生效 </span><br><span class="line"> ---&gt;  4.如报Nginx启动问题，请手动启动nginx查看错误，如自己无法处理请提issues </span><br><span class="line"></span><br><span class="line"> ---&gt; 如以上设置都正确，请重新安装纯净系统后再次尝试 </span><br><span class="line"> ---&gt; 请检查防火墙规则是否开放443、80</span><br><span class="line"> </span><br><span class="line">是否通过脚本修改防火墙规则开放443、80端口？[y/n]:y</span><br><span class="line"> ---&gt; Nginx启动成功 </span><br><span class="line"></span><br><span class="line"> ---&gt; 检查域名ip中 </span><br><span class="line"> ---&gt; Nginx关闭成功 </span><br><span class="line"> ---&gt; 当前域名ip为:[198.211.27.21] </span><br><span class="line"></span><br><span class="line">进度  4/13 : 申请TLS证书</span><br><span class="line"> </span><br><span class="line"> ---&gt; 安装TLS证书 </span><br><span class="line"></span><br><span class="line">============================================================== </span><br><span class="line">1.letsencrypt[默认] </span><br><span class="line">2.zerossl </span><br><span class="line">3.buypass[不支持DNS申请] </span><br><span class="line">============================================================== </span><br><span class="line">请选择[回车]使用默认:</span><br><span class="line"></span><br><span class="line">是否使用DNS申请证书[y/n]:</span><br><span class="line"> ---&gt; 生成证书中 </span><br><span class="line"> ---&gt; TLS生成成功 </span><br><span class="line"></span><br><span class="line">进度  5/13 : 生成随机路径 </span><br><span class="line">请输入自定义路径[例: alone]，不需要斜杠，[回车]随机路径 </span><br><span class="line">路径:pp</span><br><span class="line"></span><br><span class="line"> path:pp </span><br><span class="line"></span><br><span class="line">---------------------------- </span><br><span class="line"></span><br><span class="line">进度  6/13 : 安装Xray </span><br><span class="line"> ---&gt; Xray-core版本:v1.6.1 </span><br><span class="line">Xray-linux-64.zip                 100%[==========================================================&gt;]  10.24M  --.-KB/s    in 0.1s    </span><br><span class="line"></span><br><span class="line">进度  7/13 : 配置Xray开机自启 </span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/xray.service → /etc/systemd/system/xray.service.</span><br><span class="line"> ---&gt; 配置Xray开机自启成功 </span><br><span class="line"></span><br><span class="line">进度 8/13 : 添加cloudflare自选CNAME </span><br><span class="line"></span><br><span class="line">============================================================== </span><br><span class="line"># 注意事项 </span><br><span class="line"></span><br><span class="line">教程地址: </span><br><span class="line">https://github.com/mack-a/v2ray-agent/blob/master/documents/optimize_V2Ray.md </span><br><span class="line"></span><br><span class="line">如对Cloudflare优化不了解，请不要使用 </span><br><span class="line"></span><br><span class="line"> 1.移动:104.16.123.96 </span><br><span class="line"> 2.联通:www.cloudflare.com </span><br><span class="line"> 3.电信:www.digitalocean.com </span><br><span class="line">---------------------------- </span><br><span class="line">请选择[回车不使用]:</span><br><span class="line"></span><br><span class="line"> ---&gt; 不使用 </span><br><span class="line"></span><br><span class="line">进度 9/13 : 初始化Xray配置 </span><br><span class="line"></span><br><span class="line">请输入自定义UUID[需合法]，[回车]随机UUID </span><br><span class="line">UUID:</span><br><span class="line"></span><br><span class="line"> 3eb92d90-5a44-4a10-8e8e-af05392586de </span><br><span class="line"></span><br><span class="line">进度 10/13 : 添加定时维护证书 </span><br><span class="line"></span><br><span class="line"> ---&gt; 添加定时维护证书成功 </span><br><span class="line"></span><br><span class="line">进度 11/13 : 添加伪装站点 </span><br><span class="line"> ---&gt; 添加伪装站点成功 </span><br><span class="line"> ---&gt; Xray关闭成功 </span><br><span class="line"> ---&gt; Xray启动成功 </span><br><span class="line"> ---&gt; Nginx启动成功 </span><br><span class="line"></span><br><span class="line">进度 12/13 : 验证服务启动状态 </span><br><span class="line"> ---&gt; 服务启动成功 </span><br><span class="line"></span><br><span class="line">进度 13/13 : 账号 </span><br><span class="line">===================== VLESS TCP TLS/XTLS-direct/XTLS-splice ======================</span><br><span class="line"> </span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_VLESS_XTLS/TLS-direct_TCP </span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------- </span><br><span class="line"> ---&gt; 通用格式(VLESS+TCP+TLS/xtls-rprx-splice) </span><br><span class="line"></span><br><span class="line"> ---&gt; 格式化明文(VLESS+TCP+TLS/xtls-rprx-splice) </span><br><span class="line"></span><br><span class="line"> ---&gt; 二维码 VLESS(VLESS+TCP+TLS/xtls-rprx-splice) </span><br><span class="line"></span><br><span class="line">================================ VLESS WS TLS CDN ================================</span><br><span class="line"></span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_VLESS_WS </span><br><span class="line"></span><br><span class="line">================================ VMess WS TLS CDN ================================</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_vmess_ws </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== VLESS gRPC TLS CDN ===============================</span><br><span class="line"> </span><br><span class="line"> ---&gt;gRPC处于测试阶段，可能对你使用的客户端不兼容，如不能使用请忽略 </span><br><span class="line"></span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_VLESS_gRPC </span><br><span class="line"></span><br><span class="line">==================================  Trojan TLS  ==================================</span><br><span class="line"> </span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_trojan_tcp </span><br><span class="line"></span><br><span class="line">================================  Trojan gRPC TLS  ================================</span><br><span class="line"> </span><br><span class="line"> ---&gt;gRPC处于测试阶段，可能对你使用的客户端不兼容，如不能使用请忽略 </span><br><span class="line"></span><br><span class="line"> ---&gt; 账号:www.liupaopao.cf_trojan_gRPC </span><br></pre></td></tr></tbody></table></figure>

<h4 id="安装截图"><a href="#安装截图" class="headerlink" title="安装截图"></a>安装截图</h4><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025225.png" alt="001"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025384.png" alt="002"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025939.png" alt="003"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025617.png" alt="004"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025608.png" alt="005"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025187.png" alt="006"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025501.png" alt="007"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061025371.png" alt="008"></p>
<h3 id="配置v2rayN客户端"><a href="#配置v2rayN客户端" class="headerlink" title="配置v2rayN客户端"></a>配置 v2rayN 客户端</h3><p>安装成功后，把账号添加到 v2rayN 客户端，就可以正常上网啦！<br>（我试了其他几个账户发现不行，VLESS+WS+TLS+CDN 组合的模式可以正常使用，可能脚本默认安装的组合方式就是这种）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211061013230.png" alt="image-20221106101326137"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 v2ray 代理下无法登录 OneDrive 问题</title>
    <url>/posts/e2bc80af.html</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>系统使用 v2ray 代理后，导致 OneDrive 登录不上，还会报错代理身份验证错误。关闭 v2ray 后，就能正常登录了。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个问题产生的原因是：微软在 Win8 以后的版本引入了 UWP 应用，UWP 应用存在网络安全限制，正常情况下无法访问回环地址，挂了代理后会迫使 UWP 的流量走本地代理，而 UWP 是走不通本地回环地址的所以就导致没网，连接不上。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 v2rayN 客户端打开【设置】–&gt; 【解除 Win10 UWP 应用回环代理限制】–&gt; 勾选上【工作或学校帐户】，然后保存即可成功登录 OneDrive。</p>
<p>clash for Windows 客户端也有相关的配置，找到 UWP Loopback 回环配置，进行对应勾选即可。</p>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>部署带流量伪装的 V2Ray</title>
    <url>/posts/9a606340.html</url>
    <content><![CDATA[<p>每逢国内特殊时期，搭建的翻墙梯子就要经常挂掉，购买的国外 VPS 服务器 IP 经常被封，尝试使用流量伪装的方式搭建 V2Ray 代理，这样应该更稳定一些。</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>申请一个域名</li>
<li>将域名成功解析到服务器 IP</li>
</ul>
<span id="more"></span>

<h3 id="申请Freenom免费域名"><a href="#申请Freenom免费域名" class="headerlink" title="申请Freenom免费域名"></a>申请 Freenom 免费域名</h3><p>Freenom 免费域名申请网站：<a href="https://my.freenom.com/">https://my.freenom.com/</a></p>
<p>由于 Freenom 对国内 IP 进行限制，可能无法申请成功，需要有梯子，开启全局代理模式，就能正常访问 Freenom 申请免费域名了。</p>
<p>为申请的域名添加 IP 解析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211021012901.png" alt="image-20221102101223769"></p>
<p>ping 下域名，查看是否已成功解析到服务器 IP：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@0:~# ping www.liupaopao.tk</span><br><span class="line">PING www.liupaopao.tk (173.82.227.159) 56(84) bytes of data.</span><br><span class="line">64 bytes from 0.007.1hour.com (173.82.227.159): icmp_seq=1 ttl=64 time=0.031 ms</span><br><span class="line">64 bytes from 0.007.1hour.com (173.82.227.159): icmp_seq=2 ttl=64 time=0.048 ms</span><br></pre></td></tr></tbody></table></figure>

<h3 id="v2ray带伪装一键脚本"><a href="#v2ray带伪装一键脚本" class="headerlink" title="v2ray带伪装一键脚本"></a>v2ray 带伪装一键脚本</h3><ul>
<li>v2ray 带伪装一键脚本 Ubuntu 版：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">apt install -y curl</span><br><span class="line">bash &lt;(curl -sL https://raw.githubusercontent.com/daveleung/hijkpw-scripts-mod/main/xray_mod1.sh) </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>v2ray 带伪装一键脚本：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y curl</span><br><span class="line">bash &lt;(curl -sL https://raw.githubusercontent.com/hiifeng/v2ray/main/install_v2ray.sh) </span><br></pre></td></tr></tbody></table></figure>

<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@0:~# bash &lt;(curl -sL https://raw.githubusercontent.com/daveleung/hijkpw-scripts-mod/main/xray_mod1.sh) </span><br><span class="line">4</span><br><span class="line">#############################################################</span><br><span class="line">#                     Xray一键安装脚本                      #</span><br><span class="line"># 作者: 网络跳越(hijk)                                      #</span><br><span class="line"># 网址: https://hijk.art                                    #</span><br><span class="line"># 论坛: https://hijk.club                                   #</span><br><span class="line"># TG群: https://t.me/hijkclub                               #</span><br><span class="line"># Youtube频道: https://youtube.com/channel/UCYTB--VsObzepVJtc9yvUxQ #</span><br><span class="line">#############################################################</span><br><span class="line">  1.   安装Xray-VMESS</span><br><span class="line">  2.   安装Xray-VMESS+mKCP</span><br><span class="line">  3.   安装Xray-VMESS+TCP+TLS</span><br><span class="line">  4.   安装Xray-VMESS+WS+TLS(推荐)</span><br><span class="line">  5.   安装Xray-VLESS+mKCP</span><br><span class="line">  6.   安装Xray-VLESS+TCP+TLS</span><br><span class="line">  7.   安装Xray-VLESS+WS+TLS(可过cdn)</span><br><span class="line">  8.   安装Xray-VLESS+TCP+XTLS(推荐)</span><br><span class="line">  9.   安装trojan(推荐)</span><br><span class="line">  10.  安装trojan+XTLS(推荐)</span><br><span class="line"> -------------</span><br><span class="line">  11.  更新Xray</span><br><span class="line">  12.  卸载Xray</span><br><span class="line"> -------------</span><br><span class="line">  13.  启动Xray</span><br><span class="line">  14.  重启Xray</span><br><span class="line">  15.  停止Xray</span><br><span class="line"> -------------</span><br><span class="line">  16.  查看Xray配置</span><br><span class="line">  17.  查看Xray日志</span><br><span class="line"> -------------</span><br><span class="line">  0.   退出</span><br><span class="line"> 当前状态：未安装</span><br><span class="line"></span><br><span class="line"> 请选择操作[0-17]：</span><br><span class="line"> Xray一键脚本，运行之前请确认如下条件已经具备：</span><br><span class="line">  1. 一个伪装域名</span><br><span class="line">  2. 伪装域名DNS解析指向当前服务器ip（173.82.227.159）</span><br><span class="line">  3. 如果/root目录下有 xray.pem 和 xray.key 证书密钥文件，无需理会条件2</span><br><span class="line"> </span><br><span class="line"> 确认满足按y，按其他退出脚本：y</span><br><span class="line"></span><br><span class="line"> 请输入伪装域名：www.liupaopao.tk</span><br><span class="line"> 伪装域名(host)：www.liupaopao.tk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 请输入Nginx监听端口[100-65535的一个数字，默认443]：419</span><br><span class="line"> Nginx端口：419</span><br><span class="line"></span><br><span class="line"> 请输入伪装路径，以/开头(不懂请直接回车)：/pp</span><br><span class="line"> ws路径：/pp</span><br><span class="line"></span><br><span class="line"> 请选择伪装站类型:</span><br><span class="line">   1) 静态网站(位于/usr/share/nginx/html)</span><br><span class="line">   2) 小说站(随机选择)</span><br><span class="line">   3) 美女站(https://imeizi.me)</span><br><span class="line">   4) 高清壁纸站(https://bing.imeizi.me)</span><br><span class="line">   5) 自定义反代站点(需以http或者https开头)</span><br><span class="line">  请选择伪装网站类型[默认:高清壁纸站]2</span><br><span class="line"> 伪装网站：http://www.tjwl.com/</span><br><span class="line"></span><br><span class="line">  是否允许搜索引擎爬取网站？[默认：不允许]</span><br><span class="line">    y)允许，会有更多ip请求网站，但会消耗一些流量，vps流量充足情况下推荐使用</span><br><span class="line">    n)不允许，爬虫不会访问网站，访问ip比较单一，但能节省vps流量</span><br><span class="line">  请选择：[y/n]n</span><br><span class="line"> 允许搜索引擎：n</span><br><span class="line"></span><br><span class="line"> 是否安装BBR(默认安装)?[y/n]:y</span><br><span class="line"> 安装BBR：y</span><br><span class="line">Hit:1 http://archive.ubuntu.com/ubuntu jammy InRelease</span><br><span class="line">Get:2 http://archive.ubuntu.com/ubuntu jammy-updates InRelease [114 kB]</span><br><span class="line">Get:3 http://archive.ubuntu.com/ubuntu jammy-backports InRelease [99.8 kB]</span><br><span class="line">Get:4 http://archive.ubuntu.com/ubuntu jammy-security InRelease [110 kB]</span><br><span class="line">Fetched 324 kB in 2s (206 kB/s)  </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">…………</span><br></pre></td></tr></tbody></table></figure>

<h3 id="部署成功显示"><a href="#部署成功显示" class="headerlink" title="部署成功显示"></a>部署成功显示</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">BBR模块已启用</span><br><span class="line"> Xray启动成功</span><br><span class="line"></span><br><span class="line"> Xray运行状态：已安装 Xray正在运行, Nginx正在运行</span><br><span class="line"> Xray配置文件:  /usr/local/etc/xray/config.json</span><br><span class="line"> Xray配置信息：</span><br><span class="line">   协议:  VMess</span><br><span class="line">   IP(address):  173.82.227.159</span><br><span class="line">   端口(port)：419</span><br><span class="line">   id(uuid)：xxxxxx-xxxxxx-xxxxxx-xxxxxx</span><br><span class="line">   额外id(alterid)： 0</span><br><span class="line">   加密方式(security)： none</span><br><span class="line">   传输协议(network)： ws</span><br><span class="line">   伪装类型(type)：none</span><br><span class="line">   伪装域名/主机名(host)/SNI/peer名称：www.liupaopao.tk</span><br><span class="line">   路径(path)：/pp</span><br><span class="line">   底层安全传输(tls)：TLS</span><br><span class="line"></span><br><span class="line">   vmess链接: vmess://eyAidiI6IjIiLCAicHMiOiIiLCAiYWRkIjoiMTczLjgyLjIyNy4xNTkiLCAicG9ydCI6IjQxOSIiIwIiwgIm5ldCI6IndzIiwgInR5cGUiOiJub25lIiwgImhvc3QiOiJ3d3cubGl1cGFvcGFvLnRrIiwgInBhdGgiOiIvcHAiLCAidGxzIjoidGxzIiB9</span><br></pre></td></tr></tbody></table></figure>

<p>打开浏览器输入伪装域名 <a href="http://www.liupaopao.tk,能正常打开伪装站,说明服务端在正常运行;输入域名加伪装路径www.liupaopao.tk/pp%EF%BC%8C%E5%87%BA%E7%8E%B0%E2%80%9Dbad">www.liupaopao.tk，能正常打开伪装站，说明服务端在正常运行；输入域名加伪装路径 www.liupaopao.tk/pp，出现”bad</a> request”，则说明服务端已经完全没问题。</p>
<p>伪装域名配置成功后，也可以进行 ssh 登录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ssh root@www.liupaopao.tk</span><br></pre></td></tr></tbody></table></figure>


<h3 id="配置v2rayN客户端"><a href="#配置v2rayN客户端" class="headerlink" title="配置v2rayN客户端"></a>配置 v2rayN 客户端</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202211021021840.png" alt="image-20221102102128684"></p>
<p>这里 IP 地址 address 直接填上伪装域名 <a href="http://www.liupaopao.tk也行./">www.liupaopao.tk 也行。</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下配置 maven 环境</title>
    <url>/posts/a36906ae.html</url>
    <content><![CDATA[<h2 id="下载maven二进制"><a href="#下载maven二进制" class="headerlink" title="下载maven二进制"></a>下载 maven 二进制</h2><p>官网下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>或者直接在 Linux 上通过 wget 下载：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>解压二进制后 <code>tar -xvf apache-maven-3.8.6-bin.tar.gz</code>，打开文件 <code>vi ~/.bashrc</code>，添加下面三行配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">export M2_HOME=/root/apache-maven-3.8.6</span><br><span class="line">export M2=$M2_HOME/bin</span><br><span class="line">export PATH=$M2:$PATH</span><br></pre></td></tr></tbody></table></figure>

<p>最后更新下：<code>source ~/.bashrc</code></p>
<p>通过 <code>mvn --version</code> 命令测试：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@PAOPAO:~# mvn --version</span><br><span class="line">Apache Maven 3.8.6 (84538c9988a25aec085021c365c560670ad80f63)</span><br><span class="line">Maven home: /root/apache-maven-3.8.6</span><br><span class="line">Java version: 1.8.0_342, vendor: Private Build, runtime: /usr/lib/jvm/java-8-openjdk-amd64/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: "linux", version: "5.4.0-29-generic", arch: "amd64", family: "unix"</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 构建类型：Debug、Release、RelWithDebInfo 和 MinSizeRel</title>
    <url>/posts/a3ea1ba2.html</url>
    <content><![CDATA[<p>cmake 构建工具中 <code>CMAKE_BUILD_TYPE</code> 变量支持下面四种构建类型：</p>
<ul>
<li><code>Debug</code>：调试版本，没有优化，开启断言，最全调试信息。</li>
<li><code>Release</code>：正式版本，最高优化，没有调试信息，关闭断言。</li>
<li><code>RelWithDebInfo</code>：既优化又能调试的版本，关闭断言。</li>
<li><code>MinSizeRel</code>：最小体积版本，目的在于优化体积而不是优化速度。</li>
</ul>
<span id="more"></span>

<h3 id="两种设置方法"><a href="#两种设置方法" class="headerlink" title="两种设置方法"></a>两种设置方法</h3><ul>
<li>在命令行中设置：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cmake  -DCMAKE_BUILD_TYPE=Debug/Release/...</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在 CMakeLists.txt 里设置：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SET(CMAKE_BUILD_TYPE "Debug/Release/...”)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p> 注意：选项需要加上双引号才能生效。</p>
</blockquote>
<p>不同类型具有各自默认编译选项，也可自定义项目源码中的编译选项，下面是源码 <code>dyninst/cmake/optimization.cmake</code> 文件里对编译选项的描述：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS_DEBUG "-Og -g3")</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG "-Og -g3")</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS_RELEASE "-O2 ${LTO_FLAGS}")</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE "-O2 ${LTO_FLAGS}")</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS_RELWITHDEBINFO "-O2 -g3 ${LTO_FLAGS}")</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g3 ${LTO_FLAGS}")</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS_MINSIZEREL "-Os ${LTO_FLAGS}")</span><br><span class="line">set(CMAKE_CXX_FLAGS_MINSIZEREL "-Os ${LTO_FLAGS}")</span><br></pre></td></tr></tbody></table></figure>

<p>从上面配置可以看出，不同构建类型对 <code>-O</code>、<code>-g</code> 选项使用的等级不同，也可以自定义修改选项等级。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 添加编译选项：头文件和库文件路径</title>
    <url>/posts/25f4fe28.html</url>
    <content><![CDATA[<p>cmake 配置时，添加编译时需要用到的头文件和库文件路径，直接在 CMakeLists.txt 里面添加两行命令即可：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">include_directories("/path/to/include")</span><br><span class="line">LINK_DIRECTORIES("/path/to/lib")</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 和 g++ 的区别和联系</title>
    <url>/posts/1e93b3bd.html</url>
    <content><![CDATA[<p>Linux 系统下开发 C/C++ 程序时，会用到 GCC (GNU Compiler Collection，GNU 编译工具集合)，其包含了编译器、连接器等工具。GCC 工具集里，编译时会用到 gcc 和 g++ 两个工具，两者之间既有区别，又有联系，下面简单总结一下。</p>
<span id="more"></span>

<h2 id="gcc和g-的区别"><a href="#gcc和g-的区别" class="headerlink" title="gcc和g++的区别"></a>gcc 和 g++ 的区别</h2><ul>
<li><p>gcc 和 g++ 含义不同：<br>gcc（小写形式）通常表示 GNU C 语言编译器，g++ 表示 GNU C++ 语言编译器。<br>在编译 C/C++ 程序时，gcc 会调用 C 编译器，g++ 会调用 C++ 编译器。</p>
</li>
<li><p>对<code>.c</code> 和<code>.cpp</code> 文件处理方式不同：<br>gcc 会把<code>.c</code> 文件当作 C 程序，把<code>.cpp</code> 文件当作 C++ 程序。<br>g++ 会把<code>.c</code> 和<code>.cpp</code> 文件都当成 C++ 程序处理。</p>
</li>
<li><p>链接方式不同：<br>gcc 不会链接 C++ 库（如 STL 标准库）。<br>g++ 会自动链接 C++ 库。</p>
</li>
<li><p>预处理时的宏不同：<br>g++ 会自动添加一些预处理的宏（如__cplusplus），但是 gcc 不会。</p>
</li>
</ul>
<h2 id="gcc和g-使用建议"><a href="#gcc和g-使用建议" class="headerlink" title="gcc和g++使用建议"></a>gcc 和 g++ 使用建议</h2><ul>
<li><p>gcc 和 g++ 都可以用来编译 C 和 C++ 代码。</p>
</li>
<li><p>如果开发纯 C 语言的程序，建议使用 gcc。如果开发 C/C++ 程序，而且还会用到 C++ 标准库，建议使用 g++。</p>
</li>
<li><p>由于 C 和 C++ 语法上的区别和兼容性，g++ 成功编译的程序，gcc 可能会报错；gcc 报错的程序，改用 g++ 可能编译成功。</p>
</li>
</ul>
<h2 id="gcc和g-安装方式"><a href="#gcc和g-安装方式" class="headerlink" title="gcc和g++安装方式"></a>gcc 和 g++ 安装方式</h2><h3 id="apt-安装"><a href="#apt-安装" class="headerlink" title="apt 安装"></a>apt 安装</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install gcc g++</span><br></pre></td></tr></tbody></table></figure>

<h3 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></tbody></table></figure>

<p>最后，可以通过 <code>gcc -v</code> 和 <code>g++ -v</code> 命令验证是否安装成功。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 编译选项汇总</title>
    <url>/posts/ec6fe1fe.html</url>
    <content><![CDATA[<p>-shared； Create a shared library /* 创建共享库时需要添加的编译选项 */<br>因为共享库的代码都是位置无关的，所以通常还需要添加编译选项 - fPIC。</p>
<h2 id="pic和-fPIC选项"><a href="#pic和-fPIC选项" class="headerlink" title="-pic和-fPIC选项"></a><code>-pic</code> 和 <code>-fPIC</code> 选项</h2><p><strong>PIC (position-independent code)</strong></p>
<p><code>-pic</code> 和 <code>-fPIC</code> 都是编译时的选项，用于生成位置无关的代码 (Position-Independent-Code)。这两个选项都是可以使代码在加载到内存时使用相对地址，所有对固定地址的访问都通过全局偏移表 (GOT) 来实现。</p>
<p><code>-pic</code> 和 <code>-fPIC</code> 区别在于：</p>
<ul>
<li><code>-fpic</code> 对 GOT 表的大小有限制。如果链接的可执行文件 GOT 表 size 超过了架构设定的 maximum size，链接器就会报错，这时候 <code>-fpic</code> 就不适用了。</li>
<li><code>-fPIC</code> 对 GOT 表大小无限制，所以如果在不确定的情况下，建议使用 <code>-fPIC</code>。</li>
</ul>
<p>PIC 实现原理：</p>
<p>（1）GOT：在动态库的数据段增加 GOT（Global Offset Table），该表的每一项是符号到地址的绝对映射。由于代码段到数据段的偏移是固定的，因此可以在编译时确定代码段中的某个符号到 GOT 特定项之间的偏移。这样，代码段中的符号偏移就可以在编译时确定了，在加载时也无需修改代码段的内容，只需要填写位于数据段的 GOT 的所有项的符号的绝对地址就完成了。因为数据段本来就是进程间不共享，每个进程独立的一份，因此 GOT 的设计完全解决了以上两个问题，从而达到两个目的：1，代码段可以在多进程间共享；2，代码段是只读的。</p>
<p>（2）PLT：PLT 是 Program Linkage Table 的缩写，即程序链接表，PLT 的出现是为了延时定位的目的。一个动态库中的函数往往要远多于全局变量，并且被调用的函数往往少于定义的函数。GOT 中包含了该动态库中的所有的全局变量的映射，并且在连接器加载时解析所有的全局变量的地址。如果用同样的方式去处理函数调用符号，则开销会非常大。因此在代码段设计了一个 PLT 表，每一项其实是个代码段，用于执行如下逻辑：首次访问时，解析参数和向 GOT 填写函数地址，后续访问直接访问 GOT 中的函数地址。如此达到了延时定位的目的。</p>
<p>因此，一个 PIC 的动态库中，对全局变量使用 GOT 来映射，对函数调用使用 PLT+GOT 来映射，从而达到共享库代码段复用，代码段安全访问的目的。而这些就是 PIC 的意义。</p>
<p>GCC 官方手册解释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-fpic</span><br><span class="line">Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that -fpic does not work; in that case, recompile with -fPIC instead. (These maximums are 8k on the SPARC, 28k on AArch64 and 32k on the m68k and RS/6000. The x86 has no such limit.)</span><br><span class="line"></span><br><span class="line">Position-independent code requires special support, and therefore works only on certain machines. For the x86, GCC supports PIC for System V but not for the Sun 386i. Code generated for the IBM RS/6000 is always position-independent.</span><br><span class="line"></span><br><span class="line">When this flag is set, the macros __pic__ and __PIC__ are defined to 1.</span><br><span class="line"></span><br><span class="line">-fPIC</span><br><span class="line">If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</span><br><span class="line"></span><br><span class="line">Position-independent code requires special support, and therefore works only on certain machines.</span><br><span class="line"></span><br><span class="line">When this flag is set, the macros __pic__ and __PIC__ are defined to 2.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="fpie和-fPIE选项"><a href="#fpie和-fPIE选项" class="headerlink" title="-fpie和-fPIE选项"></a><code>-fpie</code> 和 <code>-fPIE</code> 选项</h2><p><strong>PIE (position-independent executable)</strong></p>
<p><code>-fpie</code> 和 <code>-fPIE</code> 选项与 <code>-pic</code> 和 <code>-fPIC</code> 是类似的，唯一区别是加上 <code>-fpie</code> 和 <code>-fPIE</code> 这两个选项后编译生成的位置无关代码只能被用于链接成可执行文件。</p>
<p>即：<code>-fPIC</code> 用于生成动态库，<code>-fPIE</code> 用于生成可执行文件。</p>
<p><strong>若想通过 gcc 编译出位置无关的可执行程序，必须同时使用 <code>-fPIE</code> 和 <code>-pie</code> 选项。其中，<code>-fPIE</code> 选项用于编译器，使用该选项从.c 编译出来的.o 文件将是位置无关的目标文件；而 <code>-pie</code> 选项则用于链接器，使用该选项后，链接器能够把 <code>-fPIE</code> 选项下编译出来的.o 文件进一步链接成位置无关的可执行程序。</strong></p>
<p>GCC 官方手册解释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-fpie</span><br><span class="line">-fPIE</span><br><span class="line">These options are similar to -fpic and -fPIC, but the generated position-independent code can be only linked into executables. Usually these options are used to compile code that will be linked using the -pie GCC option.</span><br><span class="line"></span><br><span class="line">-fpie and -fPIE both define the macros __pie__ and __PIE__. The macros have the value 1 for -fpie and 2 for -fPIE.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="pie和-no-pie选项"><a href="#pie和-no-pie选项" class="headerlink" title="-pie和-no-pie选项"></a><code>-pie</code> 和 <code>-no-pie</code> 选项</h2><p><code>-pie</code> 和 <code>-no-pie</code> 属于链接选项，</p>
<ul>
<li><code>-pie</code> 表示生成动态链接的位置无关的可执行文件，前提是编译阶段使用了 <code>-fpie</code> 和 <code>-fPIE</code> 选项。</li>
<li><code>-no-pie</code> 表示不生成，和 <code>-pie</code> 意思相反。</li>
</ul>
<p>GCC 官方手册解释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-pie</span><br><span class="line">Produce a dynamically linked position independent executable on targets that support it. For predictable results, you must also specify the same set of options used for compilation (-fpie, -fPIE, or model suboptions) when you specify this linker option.</span><br><span class="line"></span><br><span class="line">-no-pie</span><br><span class="line">Don’t produce a dynamically linked position independent executable.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="pthread选项"><a href="#pthread选项" class="headerlink" title="-pthread选项"></a><code>-pthread</code> 选项</h2><p><code>-pthread</code> 表示链接 POSIX 线程库。有些架构下，此选项还会为预处理器设置 flags，所以该选项会同时起作用于编译和链接阶段。</p>
<p>GCC 官方手册解释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-pthread</span><br><span class="line">Link with the POSIX threads library. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets. On some targets this option also sets flags for the preprocessor, so it should be used consistently for both compilation and linking.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="w-W-Wall关闭编译警告"><a href="#w-W-Wall关闭编译警告" class="headerlink" title="-w/-W/-Wall关闭编译警告"></a><code>-w/-W/-Wall</code> 关闭编译警告</h2><p><code>-w</code>：关闭编译时所有的警告 warning，使用该选项后，编译界面非常清爽。</p>
<p><code>-Wall</code>：编译时显示所有警告 warning。</p>
<p><code>-W</code>：编译时显示编译器认为会导致报错的警告。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>glibc 竟然也是一个可执行文件</title>
    <url>/posts/7862bee9.html</url>
    <content><![CDATA[<p>查看系统下 glibc 版本号时，发现了一个有趣的事情，就是 glibc 竟然可以当作可执行文件进行<code>./</code> 运行。虽然运行起来后，只是打印了一下版本号就退出了。抱着从张银奎老师那里学到的 “格物” 态度，通过 gdb 调试一下，查看究竟。</p>
<span id="more"></span>

<h2 id="有趣现象"><a href="#有趣现象" class="headerlink" title="有趣现象"></a>有趣现象</h2><p>随意查看一个可执行文件，找到链接的 glibc 库的路径。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ ldd a.out </span><br><span class="line">	linux-vdso.so.1 (0x00007ffd65393000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2c14cd5000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f2c14eeb000)</span><br></pre></td></tr></tbody></table></figure>

<p>然后直接运行 <code>/libc.so.6</code>，没有报错，而是打印了下 glibc 版本信息便自动退出了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31.</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 9.4.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC ABSOLUTE</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br><span class="line">lhx@ubuntu:~$ </span><br></pre></td></tr></tbody></table></figure>
<h2 id="gdb调试探索过程"><a href="#gdb调试探索过程" class="headerlink" title="gdb调试探索过程"></a>gdb 调试探索过程</h2><p>接下来，打算用 gdb 调试下，分析下这个有趣的现象。</p>
<h3 id="定位入口函数"><a href="#定位入口函数" class="headerlink" title="定位入口函数"></a>定位入口函数</h3><p>安装好 glibc 调试符号后，开始调试，发现在 main 函数设断点无法识别，推测入口函数可能不是 main。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ gdb /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug...</span><br><span class="line">(gdb) b main</span><br><span class="line">Function "main" not defined.</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>

<p>然后通过猜测模糊搜索下关于 main 关键字的函数，发现 version.c 文件里<code>__libc_main(void)</code> 函数比较接近，还可以结合源码来定位入口函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) info function main*</span><br><span class="line">All functions matching regular expression <span class="string">"main*"</span>:</span><br><span class="line"></span><br><span class="line">File ../csu/libc-start.c:</span><br><span class="line"><span class="number">129</span>:	<span class="type">int</span> __libc_start_main(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **), <span class="type">int</span>, <span class="type">char</span> **, <span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **), <span class="type">void</span> (*)(<span class="type">void</span>), <span class="type">void</span> (*)(<span class="type">void</span>), <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">File bindtextdom.c:</span><br><span class="line"><span class="number">327</span>:	<span class="type">char</span> *__bind_textdomain_codeset(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"><span class="number">318</span>:	<span class="type">char</span> *__bindtextdomain(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">File finddomain.c:</span><br><span class="line"><span class="number">58</span>:	<span class="class"><span class="keyword">struct</span> <span class="title">loaded_l10nfile</span> *_<span class="title">nl_find_domain</span>(<span class="title">const</span> <span class="title">char</span> *, <span class="title">char</span> *, <span class="title">const</span> <span class="title">char</span> *, <span class="keyword">struct</span> <span class="title">binding</span> *);</span></span><br><span class="line"><span class="number">189</span>:	<span class="type">void</span> _nl_finddomain_subfreeres(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">File genops.c:</span><br><span class="line"><span class="number">127</span>:	<span class="type">void</span> _IO_switch_to_main_get_area(FILE *);</span><br><span class="line"></span><br><span class="line">File getdomain.c:</span><br><span class="line"><span class="number">32</span>:	<span class="type">int</span> __GI_getdomainname(<span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">File getdomainname_chk.c:</span><br><span class="line"><span class="number">22</span>:	<span class="type">int</span> __getdomainname_chk(<span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">File getnameinfo.c:</span><br><span class="line"><span class="number">87</span>:	<span class="type">static</span> <span class="type">char</span> *<span class="title function_">nrl_domainname</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File loadmsgcat.c:</span><br><span class="line"><span class="number">752</span>:	<span class="type">void</span> _nl_load_domain(<span class="keyword">struct</span> loaded_l10nfile *, <span class="keyword">struct</span> binding *);</span><br><span class="line"><span class="number">1288</span>:	<span class="type">void</span> _nl_unload_domain(<span class="keyword">struct</span> loaded_domain *);</span><br><span class="line"></span><br><span class="line">File res_hconf.c:</span><br><span class="line"><span class="number">536</span>:	<span class="type">void</span> _res_hconf_trim_domain(<span class="type">char</span> *);</span><br><span class="line"><span class="number">561</span>:	<span class="type">void</span> _res_hconf_trim_domains(<span class="keyword">struct</span> hostent *);</span><br><span class="line"><span class="number">103</span>:	<span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">arg_trimdomain_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line">File textdomain.c:</span><br><span class="line"><span class="number">64</span>:	<span class="type">char</span> *__textdomain(<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">File version.c:</span><br><span class="line"><span class="number">69</span>:	<span class="type">void</span> __libc_main(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">File wgenops.c:</span><br><span class="line"><span class="number">55</span>:	<span class="type">void</span> __GI__IO_switch_to_main_wget_area(FILE *);</span><br><span class="line">(gdb)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="显示源码"><a href="#显示源码" class="headerlink" title="显示源码"></a>显示源码</h3><p>把断点设到<code>__libc_main</code> 后，发现程序停下来了，但是找不到源码信息。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) b __libc_main</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x241c0</span>: file version.c, line <span class="number">70.</span></span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /usr/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> </span><br><span class="line">warning: Probes-based dynamic linker interface failed.</span><br><span class="line">Reverting to original interface.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, __libc_main () at version.c:<span class="number">70</span></span><br><span class="line"><span class="number">70</span>	version.c: 没有那个文件或目录.</span><br><span class="line">(gdb)</span><br></pre></td></tr></tbody></table></figure>

<p>然后手动设置下源码搜索路径：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) directory ~/glibc/glibc<span class="number">-2.31</span>/csu/</span><br><span class="line">Source directories searched: /home/lhx/glibc/glibc<span class="number">-2.31</span>/csu:$cdir:$cwd</span><br><span class="line">(gdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">65</span>	   Running the library as a program will get here.  */</span><br><span class="line"><span class="number">66</span>	</span><br><span class="line"><span class="number">67</span>	<span class="keyword">extern</span> <span class="type">void</span> __libc_main (<span class="type">void</span>) __attribute__ ((<span class="keyword">noreturn</span>));</span><br><span class="line"><span class="number">68</span>	<span class="type">void</span></span><br><span class="line"><span class="number">69</span>	__libc_main (<span class="type">void</span>)</span><br><span class="line"><span class="number">70</span>	{</span><br><span class="line"><span class="number">71</span>	  __libc_print_version ();</span><br><span class="line"><span class="number">72</span>	  _exit (<span class="number">0</span>);</span><br><span class="line"><span class="number">73</span>	}</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>
<h3 id="找到根源"><a href="#找到根源" class="headerlink" title="找到根源"></a>找到根源</h3><p>接着单步调试，并进入函数一探究竟。发现版本信息正是被保存在 <code>banner</code> 数组里面。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line"><span class="number">71</span>	  __libc_print_version ();</span><br><span class="line">(gdb) s</span><br><span class="line">__libc_print_version () at version.c:<span class="number">45</span></span><br><span class="line"><span class="number">45</span>	  __write (STDOUT_FILENO, banner, <span class="keyword">sizeof</span> banner - <span class="number">1</span>);</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  __libc_print_version () at version.c:<span class="number">45</span></span><br><span class="line">#<span class="number">1</span>  __libc_main () at version.c:<span class="number">71</span></span><br><span class="line">(gdb) p banner </span><br><span class="line">$<span class="number">1</span> = <span class="string">"GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31.\nCopyright (C) 2020 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO wa"</span>...</span><br><span class="line">(gdb) <span class="built_in">set</span> print elements unlimited </span><br><span class="line">(gdb) p banner </span><br><span class="line">$<span class="number">2</span> = <span class="string">"GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31.\nCopyright (C) 2020 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version 9.4.0.\nlibc ABIs: UNIQUE IFUNC ABSOLUTE\nFor bug reporting instructions, please see:\n&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.\n"</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后通过 gdb 直接进去查看下源码，发现 <code>banner</code> 是一个固定写死的字符数组：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305212102259.gif" alt="GIF 2023-5-21 20-59-13"></p>
<p>最后执行完版本打印函数<code>__libc_print_version</code>，glibc 就直接<code> _exit</code> 退出了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305212105547.png" alt="image-20230521210544482"></p>
]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>gmp、mpfr、mpc、isl 依赖库源码安装方法</title>
    <url>/posts/4b20b341.html</url>
    <content><![CDATA[<p>编译安装 gcc 的时候需要提前安装 gmp、mpfr、mpc、isl 这些依赖库，由于这些库有确定的依赖关系，所以下载好源码后，要按照依赖关系进行分别编译。</p>
<p>（有时候编译其他软件，也需要这些依赖库，若系统下没有这些库，也可以按照下述方法编译安装）。</p>
<h2 id="编译顺序"><a href="#编译顺序" class="headerlink" title="编译顺序"></a>编译顺序</h2><ol>
<li><p>先编译 gmp</p>
</li>
<li><p>再编译 mpfr</p>
</li>
<li><p>最后编译 mpc</p>
</li>
<li><p>编译完 gmp 后就可以编译 isl</p>
</li>
</ol>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>gmp –&gt; isl</p>
<p>gmp –&gt; mpfr –&gt; mpc</p>
<h2 id="统一的编译方法"><a href="#统一的编译方法" class="headerlink" title="统一的编译方法"></a>统一的编译方法</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd gmp-x.x.x</span><br><span class="line">mkdir build &amp;&amp; mkdir install</span><br><span class="line">cd build</span><br><span class="line">../gmp-x.x.x/configure --prefix=/path/to/install</span><br><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title>x86 环境下交叉编译 binutils</title>
    <url>/posts/9dc9e90f.html</url>
    <content><![CDATA[<h1 id="下载binutils源码"><a href="#下载binutils源码" class="headerlink" title="下载binutils源码"></a>下载 binutils 源码</h1><p>binutils-2.31.tar.gz：<a href="https://ftp.gnu.org/gnu/binutils/binutils-2.31.tar.gz">https://ftp.gnu.org/gnu/binutils/binutils-2.31.tar.gz</a></p>
<h1 id="交叉编译：aarch64-to-ppc"><a href="#交叉编译：aarch64-to-ppc" class="headerlink" title="交叉编译：aarch64-to-ppc"></a>交叉编译：aarch64-to-ppc</h1><ul>
<li>编译环境：x86</li>
<li> 运行环境：aarch64</li>
<li> 可执行文件架构：ppc<span id="more"></span>
编译脚本：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../binutils-2.31/configure --prefix=/home/lhx/binutils/install --target=powerpc-linux-gnu --host=aarch64-linux-gnu</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="交叉编译：x86-to-ppc"><a href="#交叉编译：x86-to-ppc" class="headerlink" title="交叉编译：x86-to-ppc"></a>交叉编译：x86-to-ppc</h1><ul>
<li>编译环境：x86</li>
<li> 运行环境：x86</li>
<li> 可执行文件架构：ppc</li>
</ul>
<p>编译脚本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../binutils-2.31/configure --prefix=/home/lhx/binutils/install --target=powerpc-linux-gnu --host=x86_64-linux-gnu</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="成功安装后的目录结构"><a href="#成功安装后的目录结构" class="headerlink" title="成功安装后的目录结构"></a>成功安装后的目录结构</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/binutils$ tree -L 2 binutils-x86-ppc</span><br><span class="line">binutils-x86-ppc</span><br><span class="line">├── bin</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-addr2line</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-ar</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-as</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-c++filt</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-elfedit</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-embedspu</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-gprof</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-ld</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-ld.bfd</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-nm</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-objcopy</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-objdump</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-ranlib</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-readelf</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-size</span><br><span class="line">│&nbsp;&nbsp; ├── powerpc-linux-gnu-strings</span><br><span class="line">│&nbsp;&nbsp; └── powerpc-linux-gnu-strip</span><br><span class="line">├── powerpc-linux-gnu</span><br><span class="line">│&nbsp;&nbsp; ├── bin</span><br><span class="line">│&nbsp;&nbsp; └── lib</span><br><span class="line">└── share</span><br><span class="line">    ├── info</span><br><span class="line">    ├── locale</span><br><span class="line">    └── man</span><br><span class="line"></span><br><span class="line">8 directories, 17 files</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>PowerPC</tag>
        <tag>aarch64</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>在 x86_64 和 aarch64 架构下实现源码编译 gcc830</title>
    <url>/posts/54221052.html</url>
    <content><![CDATA[<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>提前下载源码 gcc-8.3.0.tar.gz</li>
<li> 提前下载 gmp、mpfr、mpc、isl 依赖库</li>
</ul>
<span id="more"></span>

<h3 id="解压源码"><a href="#解压源码" class="headerlink" title="解压源码"></a>解压源码</h3><p>解压 gcc-8.3.0.tar.gz</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf gcc-8.3.0.tar.gz</span><br></pre></td></tr></tbody></table></figure>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ul>
<li>方法一：<br>打开 <code>contrib/download_prerequisites</code> 文件，看到依赖列表：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gmp='gmp-6.1.0.tar.bz2'</span><br><span class="line">mpfr='mpfr-3.1.4.tar.bz2'</span><br><span class="line">mpc='mpc-1.0.3.tar.gz'</span><br><span class="line">isl='isl-0.18.tar.bz2'</span><br><span class="line"></span><br><span class="line">base_url='ftp://gcc.gnu.org/pub/gcc/infrastructure/'</span><br></pre></td></tr></tbody></table></figure>
<p>里面的网址打不开了，新的网址为：<code>https://gcc.gnu.org/pub/gcc/infrastructure/</code>，然后手动把对应版本的依赖下载好，不需要解压，直接把压缩包移动到 gcc-8.3.0 源码下。</p>
<p>然后，运行脚本，检查下依赖是否满足：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/gcc/gcc-8.3.0$ ./contrib/download_prerequisites</span><br><span class="line">gmp-6.1.0.tar.bz2: 成功</span><br><span class="line">mpfr-3.1.4.tar.bz2: 成功</span><br><span class="line">mpc-1.0.3.tar.gz: 成功</span><br><span class="line">isl-0.18.tar.bz2: 成功</span><br><span class="line">All prerequisites downloaded successfully.</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>方法二：<br>解压 gmp、mpfr、mpc、isl 这些库的源码包 tar.gz 到 gcc-8.3.0 目录下，并把这些库的名字中的版本号去掉，这样编译 gcc 的时候，就能识别到这些库的源码目录，并联合编译这些库。不然编译 gcc 的时候可能报错找不到这些库。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd gcc-8.3.0</span><br><span class="line">tar -xjf gmp-6.1.0.tarbz2</span><br><span class="line">mv gmp-6.1.0 gmp</span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure>
<h3 id="编译安装gcc"><a href="#编译安装gcc" class="headerlink" title="编译安装gcc"></a>编译安装 gcc</h3><ul>
<li>编译选项一：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../gcc-8.3.0/configure -enable-checking=release -enable-language=c,c++ -disable-multilib --prefix=path/to/gcc830/install</span><br><span class="line">make -j64 &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure></li>
<li>编译选项二：<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../gcc-8.3.0/configure --prefix=/home/lhx/gcc830/install --enable-shared --enable-threads=posix --enable-languages=c,c++,fortran --disable-multilib</span><br><span class="line">make -j64 &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="配置gcc环境"><a href="#配置gcc环境" class="headerlink" title="配置gcc环境"></a>配置 gcc 环境</h3><p>在<code>.bash_profile</code> 文件添加下面的环境变量：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># export gcc-8.3.0</span><br><span class="line">export PATH=path/to/gcc830/install/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=path/to/gcc830/install/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export MANPATH=path/to/gcc830/install/gcc/share/man:$MANPATH</span><br></pre></td></tr></tbody></table></figure>
<p>然后输入命令 <code>source .bash_profile</code> 更新后生效，此时通过 <code>which gcc</code> 命令可以查看到已使用自己编译的 gcc 版本。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Ubuntu-64 位环境下编译 32 位程序</title>
    <url>/posts/35593d27.html</url>
    <content><![CDATA[<p>如果 gcc 编译时直接用 <code>-m32</code> 选项，则会由于找不到一些库而报错：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ gcc -g -m32 hello.c -o hello</span><br><span class="line">In file included from hello.c:1:</span><br><span class="line">/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录</span><br><span class="line">   27 | #include &lt;bits/libc-header-start.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></tbody></table></figure>

<p>需要提前安装好 32 位程序所需要的依赖环境：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential module-assistant  </span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib  </span><br></pre></td></tr></tbody></table></figure>

<p>然后再用 <code>-m32</code> 选项编译程序即可：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -g -m32 hello.c -o hello</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=7b812a0a70b42698b421cc3e4b2db23c26d48a14, for GNU/Linux 3.2.0, with debug_info, not stripped</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂链接器 1：链接器定义和符号决议</title>
    <url>/posts/600f79ea.html</url>
    <content><![CDATA[<h2 id="什么是链接器-Linker"><a href="#什么是链接器-Linker" class="headerlink" title="什么是链接器 (Linker)"></a>什么是链接器 (Linker)</h2><p>维基百科的定义为：</p>
<blockquote>
<p><code>链接器</code> （英语：Linker），是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库，链接为一个可执行文件。</p>
</blockquote>
<blockquote>
<p>在 Unix-like 系统上常用的链接器是 GNU ld。目标文件是包括机器码和链接器可用信息的程序模块。简单的讲，链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。大多数现代操作系统都提供动态链接和静态链接两种形式。</p>
</blockquote>
<p>为便于理解，可将链接器的定义分解成如下三点：</p>
<ul>
<li>首先是链接器的本质，链接器本质上也是一个程序，和我们经常使用的普通程序没什么不同。</li>
<li>接器的输入是编译器编译好的目标文件（object file）。</li>
<li>链接器的输出，链接器在将目标文件打包处理后，生成或者可执行文件，或者库，或者目标文件。</li>
</ul>
<p>从这个定义中能够看出，链接器的作用有点类似于我们经常使用的压缩软 WinRAR (Linux 下是 tar)，压缩软件将一堆文件打包压缩成一个压缩文件，而链接器和压缩软件的区别在于链接器是将多个目标文件打包成一个文件而不进行压缩。</p>
<h2 id="符号决议-Symbol-Resolution"><a href="#符号决议-Symbol-Resolution" class="headerlink" title="符号决议 (Symbol Resolution)"></a>符号决议 (Symbol Resolution)</h2><p>所有的应用程序都是链接器将所需要的一个个简单的目标文件汇集起来形成的，可以将这个过程想象成拼图游戏，每个拼块就是一个简单的目标文件：</p>
<img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729223235.jpg" alt="拼图" style="zoom: 33%;">

<p>1、拼图游戏当中的每个拼块都依赖于其它拼块提供的拼接口，这就好比我们写的程序模块依赖于其它模块提供的编程接口，比如我们在 list.c 中实现了一种特定的链表数据结构，其它模块需要使用这种链表，这就是模块间的依赖。而链接器其中一项任务就是要确保提供给链接器进行链接的目标文件集合之间依赖是成立的（也就是说，不会出现在被依赖的模块中链接器找不到需要的接口），这就是要讲到的<code>符号决议</code> (Symbol Resolution)。</p>
<p>2、我们在拼图游戏当中通常都是将一整幅图按组成部位一部分一部分拼接好，然后将这些比较完整的大的组成部分拼接成最后一整幅图。这就好比链接器会首先将程序每个模块当中目标文件集合链接成库，然后再将各个库进行链接最终形成可执行程序。这就是可执行程序的生成过程。</p>
<p>3，链接器还有一项任务是无法用这个拼图游戏来类比的，但是这项重要的任务对程序员不可见，作为程序员几乎不会在这个过程遇到问题，这项任务就是<code>重定位</code>。</p>
<h3 id="链接器的工作过程"><a href="#链接器的工作过程" class="headerlink" title="链接器的工作过程"></a>链接器的工作过程</h3><p>通过拼图这个游戏的类比，我们给出链接器的工作过程：</p>
<ol>
<li>首先，链接器对给定的目标文件或库的集合进行符号决议以确保模块间的依赖是正确的。</li>
<li>其次，链接器将给定的目标文件集合进行拼接打包成需要的库或最终可执行文件。</li>
<li>最后，链接器对链接好的库或可执行文件进行重定位。</li>
</ol>
<p>接下来详细的讲解下每一个过程。首先讲解链接器的符号决议过程。在这个过程当中，链接器需要做的工作就是确保所有目标文件中的符号引用都有唯一的定义。要想理解这句话我们首先来看看一个典型的 c 文件里都有些什么。</p>
<h3 id="c源文件中都有什么"><a href="#c源文件中都有什么" class="headerlink" title="c源文件中都有什么"></a>c 源文件中都有什么</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220137.png" alt="c程序示例图"></p>
<p>如图所示是一个典型的 c 源文件，该文件中的变量可以划分为两类：</p>
<ul>
<li><p>全局变量：比如 x_global_uninit，x_global_init，fn_c。只要程序没有结束运行，全局变量都可以随时使用。注意，用 static 修饰的全局变量比如 y_global_uninit，其生命周期也等同于程序的运行周期，只是这种全局变量只能在所被定义的文件当中使用，对其它文件不可见。</p>
</li>
<li><p>局部变量：比如 y_local_uninit，y_local_init，局部局部变量的生命周期和全局变量不同，局部变量变量只能在相应的函数内部使用，当函数调用完成后该函数中的局部变量也就无法使用了。因为局部变量只存在于函数运行时的栈帧当中，函数调用完成后相应的栈帧被自动回收 (该内容涉及到程序运行时的内存模型)。</p>
</li>
</ul>
<h3 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h3><p>编译器的任务就是把人类可以理解的代码转换成机器可以执行的机器指令，源文件编译后形成对应的目标文件。源文件被编译后生成的目标文件中本质上只有两部分：</p>
<ul>
<li><p>代码部分：你可能会想，一个源文件中不都是代码吗，这里的代码指的是计算机可以执行的机器指令，也就是源文件中定义的所有函数。比如上图中定义的函数 fn_b 以及 fn_c。</p>
</li>
<li><p>数据部分：源文件中定义的全局变量。如果是已经初始化后的全局变量，该全局变量的值也存在于数据部分。</p>
</li>
</ul>
<p>到目前为止，可以把一个目标文件简单的理解为由两部分组成，代码部分中保存的是 CPU 可以执行的机器指令，这些机器指令来自程序员所定义的函数，编译器将这些定义的函数翻译成机器指令并存放在目标文件的代码部分。数据部分存放的是机器指令所操作的数据。因此目前，可以简单的将目标文件理解为一个只有两部分的文件，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220213.png" alt="目标文件组成示意图"></p>
<p>你可能会好奇函数中定义的局部变量为什么没有放到目标文件的数据段当中，这是因为局部变量是函数私有的，局部变量只能在该函数内部使用而全局变量时没有这个限制的，所以函数私有的局部变量被放在了代码段中，作为机器指令的操作数。</p>
<p>编译器在编译过程中遇到外部定义的全局变量或函数时，只要编译器能找到相应的变量声明就会在心里默念 “all is well， all is well (一切顺利)“，从这里可以看出编译器的要求还是很低的，至于所使用变量的定义编译器是不会费力去四处搜索，而是愉快的继续接下来的编译。注意，这里再次强调一下，编译器在遇到外部定义的全局变量或者函数时只要能在当前文件找到其声明，编译器就认为编译正确。而寻找使用变量定义的这项任务就被留给了链接器。链接器的其中一项任务就是要确定所使用的变量要有其唯一的定义。虽然编译器给链接器留了一项任务，但为了让链接器工作的轻松一点编译器还是多做了一点工作的，这部分工作就是符号表 (Symbol table)。</p>
<h3 id="什么是符号表-Symbol-table"><a href="#什么是符号表-Symbol-table" class="headerlink" title="什么是符号表 (Symbol table)"></a>什么是符号表 (Symbol table)</h3><p>之前提到，虽然编译器很不厚道的给链接器留了一项任务，但是编译器为了链接器工作的轻松一点还是做了一点事情，这就是<code>符号表</code>。那符号表中保存的是什么呢，符号表中保存的信息有两部分：</p>
<ul>
<li>该目标文件中引用的全局变量以及函数</li>
<li>该目标文件中定义的全局变量以及函数</li>
</ul>
<p>以上图中的代码为例，编译器在编译过程中每次遇到一个全局变量或者函数名都会在符号表中添加一项，最终编译器会统计出如下所示的一张符号表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220247.png" alt="符号表示意图"></p>
<ul>
<li>z_global 以及 fn_a 是未定义的，因为在当前文件中，这两个变量仅仅是声明，编译器并没有找到其定义。剩余的变量编译器都可以在当前文件中找到其定义。</li>
<li>fn_b 以及 fn_c 为当前文件定义的函数，因为在代码段。</li>
<li>剩余的符号都是全局变量，因此放在了数据段。</li>
</ul>
<p>有同学可能会问，为什么全局变量 y_global_uninit ，y_global_init 以及函数 fn_b 不可被其它目标文件引用，这是因为这些变量用 static 修饰过了，在 C 语言中经 static 修饰过的函数的函数以及变量都是当前文件私有的，对外部不可见，这里一定要注意。所以 static 这个关键字的用法就是，如果你认为一个变量只应该被当前文件使用而不暴露给外部，那么你就可以使用 <code>static关键字</code>修饰一下。 </p>
<p>本质上整个符号表只是想表达两件事：</p>
<ul>
<li>我能提供给其它文件使用的符号</li>
<li>我需要其它文件提供给我使用的符号</li>
</ul>
<p>这里还有一个问题就是，编译器将统计的这张符号表放在哪里了呢？</p>
<h3 id="符号表存放在哪里"><a href="#符号表存放在哪里" class="headerlink" title="符号表存放在哪里"></a>符号表存放在哪里</h3><p>在目标文件里有什么这一小节中，我们将一个目标文件简单的划分了两段，数据段和代码段，现在我们要向目标文件中再添加一段，而符号表也被编译器很贴心的放在目标文件中，因此一个目标文件可以理解为如图所示的三段，而符号表中的内容就是上一节当中编译器统计的表格。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220335.png" alt="image-20210729220335315"></p>
<p>有了符号表，链接器就可以进行符号决议了。</p>
<h3 id="符号决议的过程"><a href="#符号决议的过程" class="headerlink" title="符号决议的过程"></a>符号决议的过程</h3><p>在上一节符号表中，我们知道符号表给链接器提供了两种信息，一个是当前目标文件可以提供给其它目标文件使用的符号，另一个其它目标文件需要提供给当前目标文件使用的符号。有了这些信息链接器就可以进行符号决议了。如图所示，假设链接器需要链接三个目标文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220420.png" alt="链接三个目标文件示意图"></p>
<p>链接器会依次扫描每一个给定的目标文件，同时链接器还维护了两个集合，一个是已定义符号集合 D，另一个是未定义符合集合 U，下面是链接器进行符合决议的过程：</p>
<p>1，对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合 D 中。</p>
<p>2，对于当前目标文件，查找其符号表，将每一个当前目标文件引用的符号与已定义符号集合 D 进行对比，如果该符号不在集合 D 中则将其添加到未定义符合集合 U 中。</p>
<p>3，当所有文件都扫描完成后，如果为定义符号集合 U 不为空，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止。</p>
<p>上面的过程看似复杂，其实用一句话概括就是只要每个目标文件所引用变量都能在其它目标文件中找到唯一的定义，整个链接过程就是正确的。</p>
<p>如果你觉得上面的解释比较晦涩的话，你也可以将链接符号决议这个过程想象成如下的游戏：</p>
<p>新学期开学后，幼儿园的小朋友们都带了礼物要和其它的小朋友们分享，同时每个小朋友也有自己的心愿单，每个小朋友都可以依照自己的心愿单去其它的小朋友那里拿礼物，整个过程结束后，每个小朋友都能拿到自己想要的礼物。</p>
<p>在这个游戏当中，小朋友就好比目标文件，每个小朋友自己带的礼物就好比每个目标文件的已定义符号集合，心愿单就好比每个目标文件中未定义符号的集合。</p>
<h3 id="举例说明-undefined-reference"><a href="#举例说明-undefined-reference" class="headerlink" title="举例说明 undefined reference"></a>举例说明 undefined reference</h3><p>假设我们写了一个 math.c 的数字计算程序，其中定义了一个 add 函数，该函数在 main.c 中被引用到，那么很简单，我们只需要在 main.c 中 include 写好的 math.h 头文件就可以使用 add 函数了，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729221716.png" alt="引用示意图"></p>
<p>但是由于粗心大意，一不小心把 math.c 中的 add 函数给注释掉了，当你在写完 main.c、打算很潇洒的编译一下时，出现了很经典的 undefined reference to <code>add(int, int)</code> 错误，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729221746.png" alt="引用报错示意图"></p>
<p>这个错误其实是这样产生的：</p>
<ol>
<li>链接器发现了你写的代码 math.o 中引用了外部定义的 add 函数 (不要忘了，这是通过检查目标文件 math.o 中的符号表得到的信息)，所以链接器开始查找 add 函数到底是在哪里定义的。</li>
<li>链接器转而去目标文件 math.o 的目标文件符号表中查找，没有找到 add 函数的定义。</li>
<li>链接器转而去其它目标文件符号表中查找，同样没有找到 add 函数的定义。</li>
<li>链接器在查找了所有目标文件的符号表后都没有找到 add 函数，因此链接器停止工作并报出错误 undefined reference to `add (int, int)’，如上图所示。</li>
</ol>
<p>因此如果你很清楚链接器符号决议这个过程的话就会进行如下排查：</p>
<ol>
<li>main.c 中对 add 函数的函数名有没有写正确。</li>
<li>链接命令中有没有包含 math.o，如果没有添加上该目标文件。</li>
<li>如果链接命令没有问题，查看 math.c 中定义的 add 函数定义是否有问题。</li>
<li>如果是 C 和 C++ 混合编程时，确保相应的位置添加了 extern “C”。</li>
</ol>
<p>一般情况下经过这几个步骤的排查基本能够解决问题。</p>
<p>所以当你再次看到 undefined reference 这样的错误的是时候，你就应该可以很从容的去解决这类问题了。</p>
<blockquote>
<p>参考资料来自于公众号《码农的荒岛求生》，此处整理仅供个人学习。</p>
</blockquote>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂链接器 2：库与可执行文件的生成</title>
    <url>/posts/7173be3f.html</url>
    <content><![CDATA[<p>链接器可以操作的最小单元为目标文件，也就是说无论是静态库、动态库、可执行文件，都是基于目标文件构建出来的。目标文件就好比乐高积木中最小的零部件。</p>
<p>给定目标文件以及链接选项，链接器可以生成两种库，分别是静态库以及动态库，如图所示，给定同样的目标文件，链接器可以生成两种不同类型的库，接下来我们分别介绍。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730085852.png" alt="库生成示意图"></p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>假设这样一个应用场景，基础设计团队设计了好多实用并且功能强大的工具函数，业务团队需要用到里面的各种函数。每次新添加其中一个函数，业务团队都要去找相应的实现文件并修改链接选项。使用静态库就可以解决这个问题。静态库在 Windows 下是以.lib 为后缀的文件，Linux 下是以.a 为后缀的文件。</p>
<p>为解决上述问题，基础设计团队可以提前将工具函数集合打包编译链接成为静态库提供给业务团队使用，业务团队在使用时只要链接该静态库就可以了，每次新使用一个工具函数的时候，只要该函数在此静态库中就无需进行任何修改。</p>
<p>你可以简单的将静态库理解为由一堆目标文件打包而成， 使用者只需要使用其中的函数而无需关注该函数来自哪个目标文件（找到函数实现所在的目标文件是链接器来完成的，从这里也可以看出，不是所有静态库中的目标文件都会用到，而是用到哪个链接器就链接哪个）。静态库极大方便了对其它团队所写代码的使用。</p>
<h2 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态库是链接器通过静态链接将其和其它目标文件合并生成可执行文件的，如下图一所示，而静态库只不过是将多个目标文件进行了打包，在链接时只取静态库中所用到的目标文件，因此，你可以将静态链接想象成如下图 2 所示的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090423.png" alt="image-20210730090423254"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090432.png" alt="image-20210730090431921"></p>
<p>静态库是使用库的最简单的方法，如果你想使用别人的代码，找到这些代码的静态库并简单的和你的程序链接就可以了。静态链接生成的可执行文件在运行时不依赖任何其它代码，要理解这句话，我们需要知道静态链接下，可执行文件是如何生成的。</p>
<h2 id="静态链接下可执行文件的生成"><a href="#静态链接下可执行文件的生成" class="headerlink" title="静态链接下可执行文件的生成"></a>静态链接下可执行文件的生成</h2><p>在上一节中我们知道，可以将静态链接简单的理解为链接器将使用到的目标文件集合进行拼装，拼装之后就生成了可执行文件，同时我们在目标文件里有什么这一节中知道，目标文件分成了三段，代码段，数据段，符号表，那么在静态链接下可执行文件的生成过程如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090553.png" alt="image-20210730090553480"></p>
<p>从上图中我们可以看到可执行文件的特点：</p>
<ul>
<li>可执行文件和目标文件一样，也是由代码段和数据段组成。</li>
<li>每个目标文件中的数据段都合并到了可执行文件的数据段，每个目标文件当中的代码段都合并到了可执行文件的代码段。</li>
<li>目标文件当中的符号表并没有合并到可执行文件当中，因为可执行文件不需要这些字段。</li>
</ul>
<p>可执行文件和目标文件没有什么本质的不同，可执行文件区别于目标文件的地方在于，可执行文件有一个入口函数，这个函数也就是我们在 C 语言当中定义的 main 函数，main 函数在执行过程中会用到所有可执行文件当中的代码和数据。而这个 main 函数是被谁调用执行的呢，答案就是操作系统 (Operating System)，这也是后面文章当中要重点介绍的内容。</p>
<p>现在你应该对可执行文件有一个比较形象的认知了吧。你可以把可执行文件生成的过程想象成装订一本书，一本书中通常有好多章节，这些章节是你自己写的，且一本书不可避免的要引用其它著作。静态链接这个过程就好比不但要装订你自己写的文章，而且也把你引用的其它人的著作也直接装订进了你的书里，这里不考虑版权问题 :)，这些工作完成后，只需要按一下订书器，一本书就制作完成啦。</p>
<p>在这个比喻中，你写的各个章节就好比你写的代码，引用的其它人的著作就好比使用其它人的静态库，装订成一本书就好比可执行文件的生成。</p>
<p>静态链接是使用库的最简单最直观的形式， 从静态链接生成可执行文件的过程中可以看到，静态链接会将用到的目标文件直接合并到可执行文件当中，想象一下，如果有这样的一种静态库，几乎所有的程序都要使用到，也就是说，生成的所有可执行文件当中都有一份一模一样的代码和数据，这将是对硬盘和内存的极大浪费，假设一个静态库为 2M，那么 500 个可执行文件就有 1G 的数据是重复的。如何解决这个问题呢，答案就是使用动态库。</p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>在前三小节中我们了解了静态库、静态链接以及使用静态链接下可执行文件是如何生成的。接下来我们讲解一下动态库，那么什么是动态库？</p>
<p><code>动态库(Dynamic Library)</code>，又叫<code>共享库(Shared Library)</code>，动态链接库等，在 Windows 下就是我们常见的大名鼎鼎的 DLL 文件了，Windows 系统下大量使用了动态库。在 Linux 下动态库是以.so 为后缀的文件，同时以 lib 为前缀，比如进行数字计算的动态库 Math，编译链接后产生的动态库就叫做 libMath.so。从名字中我们知道动态库也是库，本质上动态库同样包含我们已经熟悉的代码段、数据段、符号表。只不过动态库的使用方式以及使用时间和静态库不太一样。</p>
<p>在前面几个小节中我们知道，使用静态库时，静态库的代码段和数据段都会直接打包 copy 到可执行文件当中，使用静态库无疑会增大可执行文件的大小，同时如果程序都需要某种类型的静态库，比如 libc，使用静态链接的话，每个可执行文件当中都会有一份同样的 libc 代码和数据的拷贝，如图所示，动态库的出现解决了此类问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090957.png" alt="image-20210730090956928"></p>
<p>动态库允许使用该库的可执行文件仅仅包含对动态库的引用而无需将该库拷贝到可执行文件当中。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息即可，为了方便理解，你可以将可执行文件当中保存的必要信息仅仅理解为需要记录动态库的名字就可以了，如图所示，同静态库相比，动态库的使用减少了可执行文件的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730091106.png" alt="image-20210730091106648"></p>
<p>从上面这张图中可以看出，动态库的使用解决了静态链接当中可执行文件过大的问题。我们在前几节中将静态链接生成可执行文件的过程比作了装订一本书，静态链接将引用的其它人的著作也装订到了书里，而动态链接可以想象成作者仅仅在引用的地方写了一句话，比如引用了《码农的荒岛求生》，那么作者就在引用的地方写上 “此处参考《码农的荒岛求生》”，那么读者在读到这里的时候会自己去找到码农的荒岛求生这本书并查找相应的内容，其实这个过程就是动态链接的基本思想了。</p>
<p>到这里我们就可以回答之前提到过的问题了，helloworld 程序中的 printf 函数到底是在哪里定义的，答案就是该函数是在 libc.so 当中定义的，Linux 下编译链接生成可执行文件时会默认动态链接 libc.so (Windows 下也是同样的道理)，使用 ldd 命令就会发现每个可执行文件都依赖 libc.so。因此虽然你从没有看到过 printf 的定义也可以正确的使用这个函数。</p>
<h2 id="动态链接。"><a href="#动态链接。" class="headerlink" title="动态链接。"></a>动态链接。</h2><p>我们知道静态库在编译链接期间就被打包 copy 到了可执行文件，也就是说静态库其实是在编译期间 (Compile time) 链接使用的，那么动态库又是在什么时候才链接使用的呢，动态链接可以在两种情况下被链接使用，分别是 load-time dynamic linking (加载时动态链接) 以及 run-time dynamic linking (运行时动态链接)，接下来我们分别讲解一下。</p>
<ul>
<li>load-time dynamic linking (加载时动态链接)</li>
</ul>
<p>首先可能有的同学会问，什么是 load-time 呢，load_time 翻译过来也就是加载时，那么什么又是加载呢？</p>
<p>我们大家都玩过游戏，当我们打开游戏的时候经常会跳出来一句话：“加载中，请稍后。。。” 和这里的加载意思差不多。这里的加载指的是程序的加载，而所谓程序的加载就是把可执行文件从磁盘搬到内存的过程，因为程序最终都是在内存中被执行的。至于这个过程的详解内容我会在接下来的文章《加载器与可执行文件》一文中给大家详细讲解。在这里我们只需要简单的把加载理解为程序从磁盘复制到内存的过程，加载时动态链接就出现在这个过程。</p>
<p>当把可执行文件复制到内存后，且在程序开始运行之前，操作系统会查找可执行文件依赖的动态库信息 (主要是动态库的名字以及存放路径)，找到该动态库后就将该动态库从磁盘搬到内存，并进行符号决议，如果这个过程没有问题，那么一切准备工作就绪，程序就可以开始执行了，如果找不到相应的动态库或者符号决议失败，那么会有相应的错误信息报告为用户，程序运行失败。比如 Windows 下比较常见的启动错误问题，就是因为没有找到依赖的动态库。Linux 下同样会有类似信息提示用户程序启动失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101021.png" alt="image-20210730101021256"></p>
<p>到这里，同学们应该对加载时动态链接应该有一个比较清晰的了解了。从总体上看，加载时动态链接可以分为两个阶段：阶段一，将动态库信息写入可执行文件；阶段二，加载可执行文件时依据动态库信息进行动态链接。</p>
<p><em>阶段一，将动态库信息写入可执行文件</em></p>
<p>在编译链接生成可执行文件时，需要将使用的动态库加入到链接选项当中，比如在 Linux 下引用 libMath.so，就需要将 libMath.so 加入到链接选项当中（比如 libMath.so 放到了 /usr/lib 下，那么使用命令 gcc … -lMath -L/user/lib … 进行编译链接），所以使用这种方式生成的可执行文件中保存了依赖的动态库信息，在 Linux 可使用一个简单的命令 ldd 来查看。</p>
<p><em>阶段二：加载可执行文件时依据动态库信息进行动态链接</em></p>
<p>由于在阶段一生成的可执行文件中保存了动态库信息，当可执行文件加载完成后，就可以依据此信息进行中动态库的查找以及符号决议了。</p>
<p>通过这个过程也可以清楚的看到静态库和动态库的区别，使用动态库的可执行文件当中仅仅保留相应信息，动态库的链接过程被推迟到了程序启动加载时。</p>
<p>为加深你对加载时动态链接这个过程的理解，我们用一个类比来结束本小节，沿用前几节读书的例子，我们正在读的书中引用了《码农的荒岛求生》以及其它著作，那么加载时动态链接就好比，读者开始准备读这本书的时候（还没有真正的读）就把所有该书当中引用的资料著作都找齐放到一旁准备查看，当我们真正看到引用其它文献的地方时就可以直接在一旁找到该著作啦。在这个类比当中，开始读书前的准备工作就好比加载时动态链接。</p>
<p>接下来我们讲解第二种动态链接，run-time dynamic linking (运行时动态链接) 。</p>
<ul>
<li>run-time dynamic linking (运行时动态链接)</li>
</ul>
<p>上一小节中我们看到如果我们想使用加载时动态链接，那么在编译链接生成可执行文件阶段时需要告诉编译器所依赖的动态库信息，而 run-time dynamic linking 运行时动态链接则不需要在编译链接时提供动态库信息，也就是说，在可执行文件被启动运行之前，可执行文件对所依赖的动态库信息一无所知，只有当程序运行到需要调用动态库所提供的代码时才会启动动态链接过程。</p>
<p>我们在上一节中介绍了 load-time，也就是程序加载时，那么程序加载完成后就开始程序执行了，那么所谓 run-time (运行时) 指的就是从程序开始被 CPU 执行到程序执行完成退出的这段时间。</p>
<p>所以运行时动态链接这种方式对于 “动态链接” 阐释的更加淋漓尽致，因为可执行文件在启动运行之前都不知道需要依赖哪些动态库，只在运行时根据代码的需要再进行动态链接。同加载时动态链接相比，运行时动态链接将链接这个过程再次推迟往后推迟，推迟到了程序运行时。</p>
<p>由于在编译链接生成可执行文件的过程中没有提供所依赖的动态库信息，因此这项任务就留给了程序员，在代码当中如果需要使用某个动态库所提供的函数，我们可以使用特定的 API 来运行时加载动态库，在 Windows 下通过 LoadLibrary 或者 LoadLibraryEx，在 Linux 下通过使用 dlopen、dlsym、dlclose 这样一组函数在运行时链接动态库。当这些 API 被调用后，同样是首先去找这些动态库，将其从磁盘 copy 到内存，然后查找程序依赖的函数是否在动态库中定义。这些过程完成后动态库中的代码就可以被正常使用了。</p>
<p>相对于加载时动态链接，运行时动态链接更加灵活，同时将动态链接过程推迟到运行时可以加快程序的启动速度。</p>
<p>为了和加载时动态链接作比对，我们继续使用上一小节当中读书的例子，加载时动态链接就好比在开始准备读一本书之前，将该书中所有引用到的资料文献找齐全，而运行时动态链接则不需要这个过程，运行时动态链接就好比直接拿起一本书开始看，看到有引用的参考文献时再去找该资料，找到后查看该文献然后继续读我们的书。从这个例子当中运行时动态链接更像是我们平时读书时的样子。</p>
<p>至此，两种动态链接的形式我们就都已经清楚了，接下来我们看一下动态链接下生成的可执行文件。</p>
<p>动态链接下可执行文件的生成</p>
<p>在静态链接下，链接器通过将各个目标文件的代码段和数据段合并拷贝到可执行文件，因此静态链接下可执行文件当中包含了所依赖的所有代码和数据，而与之对比的动态链接下可执行文件又是什么样的呢？</p>
<p>其实我们在动态库这一节中已经了解了动态链接下可执行文件的生成，即，在动态链接下，链接器并不是将动态库中的代码和数据拷贝到可执行文件中，而是将动态库的必要信息写入了可执行文件，这样当可执行文件在加载时就可以根据此信息进行动态链接了。为方便理解，我们将该信息仅仅认为是动态库都名字，真实情况当然要更复杂一点，这里我们以 Linux 下可执行文件即 ELF 文件为例（这一系列的文章重点关注最本质的原理思想，所以这里讨论的同样适合 Windows 下的可执行文件即 exe 文件）。</p>
<p>在前几节中我们将可执行文件简单的划分为了两段，数据段和代码段，在这里我们继续丰富可执行文件中的内容，如图所示，在动态链接下，可执行文件当中会新增两段，即 dynamic 段以及 GOT（Global offset table）段，这两段内容就是是我们之前所说的必要信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101148.png" alt="image-20210730101148719"></p>
<p>dynamic 段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息。关于 dynamic 以及 GOT 段的作用限于篇幅就不重点阐述了。如果你对 GOT 段的具体作用很好奇的话，欢迎关注微信公共账号，码农的荒岛求生。</p>
<p>当加载可执行文件时，操作系统根据 dynamic 段中的信息即可找到使用的动态库，从而完成动态链接。</p>
<p>这里需要强调一点，在编译链接过程中，可以同时使用动态库以及静态库。这两种库的使用并不冲突，那么在这种情况下生成的可执行文件中，可执行文件中包含了静态库的数据和代码，以及动态库的必要信息。</p>
<p>至此，关于静态库，静态链接，动态库，动态链接就讲述到这，那么接下来的问题就是静态库和动态库都有什么样的优缺点。</p>
<h2 id="动态库vs静态库"><a href="#动态库vs静态库" class="headerlink" title="动态库vs静态库"></a>动态库 vs 静态库</h2><p>在计算机的历史当中，最开始程序只能静态链接，但是人们很快发现，静态链接生成的可执行文件存在磁盘空间浪费问题，因为对于每个程序都需要依赖的 libc 库，在静态链接下每个可执行文件当中都有一份 libc 代码和数据的拷贝，为解决该问题才提出动态库。</p>
<p>在前几节我们知道，动态链接下可执行文件当中仅仅保留动态库的必要信息，因此解决了静态链接下磁盘浪费问题。动态库的强大之处不仅仅于此，我们知道对于现代计算机系统，比如 PC，通常会运行成百上千个程序（进程），且程序只有被加载到内存中才可以使用，如果使用静态链接那么在内存中就会有成百上千份同样的 libc 代码，这对于宝贵的内存资源同样是极大的浪费，而使用动态链接，内存中只需要有一份 libc 代码，所有的程序（进程）共享这一份代码，因此极大的节省了内存资源，这也是为什么动态库又叫共享库。</p>
<p>动态库还有另外一个强大之处，那就是如果我们修改了动态库的代码，我们只需要重新编译动态库就可以了而无需重新新编译我们自己的程序，因为可执行文件当中仅仅保留了动态库的必要信息，重新编译动态库后这些必要都信息是不会改变的（只要不修改动态库的名字和动态库导出的供可执行文件使用的函数），编译好新的动态库后只需要简单的替换原有动态库，下一次运行程序时就可以使用新的动态库了，因此动态库的这种特性极大的方便了程序升级和 bug 修复。我们平时使用都客户端程序，比如我们常用 QQ，输入法，播放器，都利用了动态库的这一优点，原因就在于方便升级以 bug 修复，只需要更新相应的动态库就可以了。</p>
<p>动态库的优点不止于此，我们知道动态链接可以出现在运行时（run-time dynamic link），动态链接的这种特性可以用于扩展程序能力，那么如何扩展呢？你肯定听说过一样神器，没错，就是插件。你有没有想过插件是怎么实现的？实现插件时，我们只需要实现几个规定好的几个函数，我们的插件就可以运行了，可这是怎么做到的呢，答案就在于运行时动态链接，可以将插件以动态的都方式实现。我们知道使用运行时动态链接无需在编译链接期间告诉链接器所使用的动态库信息，可执行文件对此一无所知，只有当运行时才知道使用什么动态库，以及使用了动态库中哪些函数，但是在编译链接可执行文件时又怎么知道插件中定义了哪些函数呢，因此所有的插件实现函数必须都有一个统一的格式，程序在运行时需要加载所有插件（动态库），然后调用所有插件的入口函数（统一的格式），这样我们写的插件就可以被执行起来了。</p>
<p>动态库都强大优势还体现在多语言编程上。我们知道使用 Python 可以快速进行开发，但 Python 的性能无法同 C/C++ 相比 (因为 Python 是解释型语言，至于什么是解释型语言我会在后面码农的荒岛求生系列文章当中给大家详细讲解)，有没有办法可以兼具 Python 的快速开发能力以及 C/C++ 的高性能呢，答案是可以的，我们可以将 C/C++ 代码编译链接成动态库，这样 python 就可以直接调用动态库中的函数了。不但 Python，Perl 以及 Java 等都可以通过动态库的形式调用 C/C++ 代码。动态库的使用使得同一个项目不同语言混合编程成为可能，而且动态库的使用更大限度的实现了代码复用。</p>
<p>了解了动态库的这么多优点，那么动态库就没有缺点吗，当然是有的。</p>
<p>首先由于动态库是程序加载时或运行是才进行链接的，因此同静态链接相比，使用动态链接的程序在性能上要稍弱于静态链接，这时因为对于加载时动态链接，这无疑会减慢程序都启动速度，而对于运行时链接，当首次调用到动态库的函数时，程序会被暂停，当链接过程结束后才可以继续进行。且动态库中的代码是地址无关代码（Position-Idependent Code，PIC），之所以动态库中的代码是地址无关代码是因为动态库又被成为共享库，所有的程序都可以调用动态库中的代码，因此在使用动态库中的代码时程序要多做一些工作，这里我们不再具体展开讲解到底程序多做了哪些工作，对此感兴趣当同学可以参考 CSAPP（深入理解计算机系统）。这里我们说动态链接的程序性能相比静态链接稍弱，但是这里的性能损失是微乎其微的，同动态库可以带来的好处相比，我们可以完全忽略这里的性能损失，同学们可以放心的使用动态库。</p>
<p>动态库的一个优点其实也是它的缺点，即动态链接下的可执行文件不可以被独立运行（这里讨论的是加载时动态链接，load-time dynamic link），换句话说就是，如果没有提供所依赖的动态库或者所提供的动态库版本和可执行文件所依赖的不兼容，程序是无法启动的。动态库的依赖问题会给程序的安装部署带来麻烦，在 Linux 环境下尤其严重，以笔者曾参与开发维护的一个虚拟桌面系统为例，我们在开发过程中依赖的一些比较有名的第三方库默认不会随着安装包发布，这就会导致用户在较低版本 Linux 中安装时经常会出现程序无法启动的问题，原因就在于我们编译链接使用都动态库和用户 Linux 系统中都动态库不兼容。解决这个问题的方法通常有两种，一个是用户升级系统中都动态库，另一个是我们讲需要都第三方库随安装包一起发布，当然这是在取得许可的情况下。</p>
<p>在了解了动态库的优缺点后，接下来我们来看一下静态库。</p>
<p>静态链接是最古老也是最简单的链接技术。静态链接都最大优点就是使用简单，编译好的可执行文件是完备的，即静态链接下的可执行文件不需要依赖任何其它的库，因为静态链接下，链接器将所有依赖的代码和数据都写入到了最终的可执行文件当中，这就消除了动态链接下的库依赖问题，没有了库都依赖问题就意味着程序都安装部署都得到了极大都简化。请大家不要小看这一点，这对当今那些拥有海量用户的后端系统来说至关重要，比如类似微信这种量级的系统，其后端会部署在成千上万台机器上，这么多的机器其系统的安装部署以及升级会给运维带来极大挑战，而静态链接下的可执行文件由于不依赖任何库，因为部署非常方便，仅仅用一个新的可执行文件进行覆盖就可以了，因此极大的简化了系统部署以及升级。笔者之前所在的某电商广告后端系统就完全使用静态链接来简化部署升级。</p>
<p>而静态库的缺点相信大家都已经清楚了，那就是静态链接会导致可执行文件过大，且多个程序静态链接同一个静态库的话会导致磁盘浪费的问题。</p>
<p>到这里关于静态库和动态库的讨论就告一段落了，相信大家对于这两种链接类型都有了清晰都认知。接下来让我们稍作休息，开始链接器的下一个重要功能，重定位。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂链接器 3：重定位</title>
    <url>/posts/6748ea9.html</url>
    <content><![CDATA[<p>程序的运行过程就是 CPU 不断的从内存中取出指令然后执行执行的过程，对于函数调用来说比如我们在 C/C++ 语言中调用简单的加法函数 add，其对应的汇编指令可能是这样的:</p>
<blockquote>
<p> <em>call 0x4004fd</em></p>
</blockquote>
<p>其中 0x4004fd 即为函数 add 在内存中的地址，当 CPU 执行这条语句的时候就会跳转到 0x4004fd 这个位置开始执行函数 add 对应的机器指令。</p>
<p>再比如我们在 C 语言中对一个全局变量 g_num 不断加一来进行计数，其对应的汇编指令可能是这样的：</p>
<blockquote>
<p> <em>mov 0x400fda %eax</em></p>
<p> <em>add $0x1 %eax</em></p>
</blockquote>
<p>这里的意思是把内存中 0x400fda 这个地址的数据放到寄存器当中，然后将寄存器中的数据加一，在这里 g_num 这个全局变量的内存地址就是 0x400fda。</p>
<p>好奇的同学可能会问，那这些函数以及数据的内存地址是怎么来的呢？</p>
<p>确定程序运行时的内存地址就是接下来我们要讲解的重点内容，这里先给出答案，可执行文件中代码以及数据的运行时内存地址是链接器指定的，也就是上面示例中 add 的内存地址 0x4004fd 其是链接器指定的。确定程序运行时地址的过程就是这里重定位 (Relocation)。</p>
<p>为什么这个过程叫做重定位呢，之所以叫做重定位是因为确定可执行文件中代码和数据的运行时地址是分为两个阶段的，在第一个阶段中无法确定这些地址，只有在第二个阶段才可以确定，因此就叫做重定位。接下来让我们来看看这两个阶段，合并同类型段以及引用符号的重定位。</p>
<p>编译器的工作</p>
<p>让我们回忆一下前几节的内容，源文件首先被编译器编译生成目标文件，目标文件种有三段内容：数据段、代码段以及符号表，所有的函数定义被放在了代码段，全局变量的定义放在了数据段，对外部变量的引用放到了符号表。</p>
<p>编译器在将源文件编译生成目标文件时可以确定一下两件事：</p>
<ul>
<li>定义在该源文件中函数的内存地址</li>
<li>定义在该源文件中全局变量的内存地址</li>
</ul>
<p>注意这里的内存地址其实只是相对地址，相对于谁的呢，相对于自己的。为什么只是一个相对地址呢？因为在生成一个目标文件时编译器并不知道这个目标文件要和哪些目标文件进行链接生成最后的可执行文件，而链接器是知道要链接哪些目标文件的。因此编译器仅仅生成一个相对地址。</p>
<p>而对于引用类的变量，也就是在当前代码中引用而定义是在其它源文件中的变量，对于这样的变量编译器是无法确定其内存地址的，这不是编译器需要关心的，确定引用类变量的内存地址是链接器的任务，链接器在进行链接时能够确定这类变量的内存地址。因此当编译器在遇到这样的变量时，比如使用了外部定义的函数时，其在目标文件中对应的机器指令可能是这样的:</p>
<blockquote>
<p><em>call 0x000000</em></p>
</blockquote>
<p>也就是说对于编译器不能确定的地址都这设置为空 (0x000000)，同时编译器还会生成一条记录，该记录告诉链接器在进行链接时要修正这条指令中函数的内存地址，这个记录就放在了目标文件的.rel.text 段中。相应的如果是对外部定义的全局变量的使用，则该记录放在了目标文件的.rel.data 段中。即链接器需要在链接过程中根据.rel.data 以及.rel.text 来填好编译器留下的空白位置</p>
<p>(0x000000)。因此在这里我们进一步丰富目标文件中的内容，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101533.png" alt="image-20210730101533085"></p>
<p>生成目标文件后，编译器完成任务，编译器确定了定义在该源文件中函数以及全局变量的相对地址。对于编译器不能确定的引用类变量，编译器在目标文件的.rel.text 以及.rel.data 段中生成相应的记录告诉链接器要修正这些变量的地址。</p>
<p>接下来就是链接器的工作了。</p>
<p>链接器的工作</p>
<p>我们在静态库下可执行文件的生成一节中知道，链接器会将所有的目标文件进行合并，所有目标文件的数据段合并到可执行文件的数据段，所有目标文件的代码段合并到可执行文件的代码段。当所有合并完成后，各个目标文件中的相对地址也就确定了。因此在这个阶段，链接器需要修正目标文件中的相对地址。</p>
<p>在这里我们以合并目标文件中的数据段为例来说明链接器是如何修正目标文件的相对地址的，合并代码段时修正相对位置的原理是一样的。</p>
<p>我们假设链接器需要链接三个目标文件：</p>
<ul>
<li>目标文件一：该文件数据段定义了两个变量 apple 和 banana，apple 的长度为 2 字节，banana 的长度 4 字节，因此目标文件一的数据段长度为 6 字节。从图中也可以看出 apple 的内存地址为 0，也就是相对地址，即 apple 这个变量在目标文件一的地址是 0，banana 的地址为 2。</li>
<li>目标文件二：该文件的数据段比较简单，只定义了一个变量 orange，其长度为 2，因此该目标文件的数据段长度为 2。</li>
<li>目标文件三：该文件的数据段定义了三个变量 grape、mango 以及 limo，其长度分别为 4 字节、2 字节以及 2 字节，因此该目标文件的数据段长度为 8 字节。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101619.png" alt="image-20210730101619806"></p>
<p>链接器在链接三个目标文件时其顺序是依次链接的，链接完成后：</p>
<ul>
<li>目标文件一：该数据段的起始地址为 0，因此该数据段中的变量的最终地址不变。</li>
<li>目标文件二：由于目标文件一的数据段长度为 6，因此链接完成后该数据段的起始地址为 6 (这里的起始地址其实就是偏移 offset)，相应的 orange 的最终内存地址为 0+offset 即 6。</li>
<li>目标文件三：由于前两个数据段的长度为 8，因此该数据段的起始地址为 8 (即 offset 为 8)，因此所有该数据段中的变量其地址都要加上该 offset，即 grape 的最终地址为 8，即 0+offset，mango 的最终地址为 4+offset 即 12，limo 的最终地址为 6+offset 即 14。</li>
</ul>
<p>从这个过程中可以看到，数据段中的相对地址是通过这个公式来修正的，即：</p>
<blockquote>
<p>相对地址 + offset (偏移) = 最终内存地址</p>
</blockquote>
<p>而每个段的偏移只有在链接完成后才能确定，因此对相对地址的修正只能由链接器来完成，编译器无法完成这项任务。</p>
<p>当所有目标文件的同类型段合并完毕后，数据段和代码段中的相对地址都被链接器修正为最终的内存位置，这样所有的变量以及函数都确定了其各自位置。</p>
<p>至此，重定位的第一阶段完成。接下来是重定位的第二阶段，即引用符号的重定位。</p>
<p>相对地址是编译器在编译过程中确定了，在链接器完成后被链接器修正为最终地址，而对于编译器没有确定的所引用的外部函数以及变量的地址，编译器将其记录在了.rel.text 和.rel.data 中。</p>
<p>由于在第一阶段中，所有函数以及数据都有了最终地址，因此重定位的第二阶段就相对简单了。我们知道编译器引用外部变量时将机器指令中的引用地址设置为空 (比如 call 0x000000)，并将该信息记录在了目标文件的.rel.text 以及.rel.data 段中。因此在这个阶段链接器依次扫描所有的.rel.text 以及.rel.data 段并找到相应变量的最终地址 (这些位置都已在第一阶段确定)，并将机器指令中的 0x000000 修正为所引用变量的最终地址就可以了。</p>
<p>到这里链接器的重定位就讲解的这里，作为程序员一般很少会有问题出现在重定位阶段，因此这个阶段对程序员相对透明。请同学们注意一点，这里的分析仅限于目标文件的静态链接。我们知道静态链接下，链接器会将需要的代码和数据都合并到可执行文件当中，因此需要确定代码和数据的最终位置。而对于动态链接库来说情况则有所不同，动态链接库可以同时被多个进程使用，如果动态链接库的机器指令中不可以存在引用变量的最终位置，否则在被多个进程使用时会出现一个进程中使用的数据被其它进程修改。因此动态库下的机器指令都是 PIC 代码，即位置无关代码 (Position-Independent Code)。关于 PIC 的机制原理就不在这里阐述了，对此感兴趣的同学可以关注微信公众号，码农的荒岛求生，我会在那里来讲解。</p>
<p>问题：为什么链接器能确定运行时地址</p>
<p>我们知道只有把可执行文件加载到内存当中程序才可以开始运行。不同的程序会被加载到内存的不同位置。我们从前两节的过程中可以看出，链接器完全没有考虑不同的程序会被加载不同的内存位置被执行。比如对于一个可执行文件我们分别运行两次，如下图所示，因为两个程序数据段变量的地址是一样的，那么程序一的数据会不会被程序二修改呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101648.png" alt="image-20210730101648724"></p>
<p>如果你去试一试的话就会发现显然不会有这种问题的。而当可执行文件加载到内存的时候也不会根据程序加载的起始地址再去修改可执行文件中变量的地址 (这样就启动速度就太慢了)，那么操作系统又是如何能做到基于同一个可执行文件的两个程序能在各自的内存空间中运行而不相互干扰呢，链接器在可执行文件中确定的到底是不是程序最终的运行地址呢，我会在后面的文章当中给出答案，欢迎同学们关注微信公共账号码农的荒岛求生获取更多内容。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂链接器 4：大型项目的构建过程</title>
    <url>/posts/659154a1.html</url>
    <content><![CDATA[<p>在讲解大型项目如何被构建之前，我们首先来讨论一个问题，有句话说的很好，梦想总是要有的，万一实现了呢，那么问题来了，要怎么实现呢，这里就涉及到了如何实现目标，</p>
<p>目标是如何实现的</p>
<p>其实很简单，本质上只有两点：</p>
<ul>
<li>知道最后想要的是什么</li>
<li>为此需要做些什么</li>
</ul>
<p>有时我们的目标可能不是简单的诸如每天跑五公里之类，比如像通过一门考试，学会一项技能这样的系统性工程。这时我们可能一下子不知道要做些什么，那么这就需要进行任务分解了，即这里的规则就是，把一个大的目标分解为一个个小的目标，如果对于其中一个小的目标还是不够具体，那么就继续将小目标进行分解，直到将每个小目标分解为如每天读懂两个章节，做完十个练习题之类很具体可以马上实施的任务为止。到这时，对于如何实现这个大的目标就很清晰了，只需要严格按照计划去实施就好了。比如对于考研，我们就可以列出如下的计划：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102100.png" alt="image-20210730102100140"></p>
<p>在考研这个例子中我们就按照上述规则将目标进行了分解，每个目标都按如下格式列出：</p>
<blockquote>
<p>  * <strong>目标 (target): 依赖什么 *</strong></p>
<p>​        * <strong>要怎么做 *</strong></p>
</blockquote>
<p>如果 “要怎么做” 还不是一个具体的目标就继续分解，直到分解为类似进程这样的目标，因为像进程这样的目标已经有了具体的实现步骤。最后我们将各个已经实现的小目标汇集起来整个大的目标就实现了。</p>
<p>本质上，一个大型项目的构建过程与此类似。</p>
<p>Make</p>
<p>再大的项目最后生成的都是一个可执行文件，只要是可执行文件就需要依赖各种目标文件，动态库，静态库；静态库同样需要依赖其它目标文件，静态库；而动态库可能又依赖其它目标文件，动态库，静态库，知道了这些又该如何构建呢，我们可以利用上面目标划分的方法规划好构建最终的可执行文件需要哪些原材料，这些原材料又是如何获取的。有了这些规划后，我们就可以依次编译出一些小的目标文件，将这些目标文件链接成静态库，动态库以方便使用。然后再一步步连接目标文件以及各种库从而形成更大的库，最后将几个必要库以及目标文件进行链接从而生成最终的可执行文件。</p>
<p>程序员先驱们确实就是使用这种现在看起来非常原始非常古老的方法进行程序编写的，每个目标文件以及库都是自己手动编译链接出来，然后再将它们链接成更大的库，直到最后生成可执行文件。</p>
<p>这种方法看上去非常简单，但是缺点也很明显，那就是非常繁琐，一旦某个源文件进行了改动，所有依赖此文件的库都需要重新编译链接，手工来完成这项工作是极其枯燥且容易出错的。为解决这个问题，天才的程序员们想出了一个小工具，没错就是 make，从此编译链接这个过程就被 make 自动化了，程序员得以从繁琐的编译链接中解放出来，使用 make 时我们只需要编写规则，也就是告诉 make 最终的可执行文件依赖什么，为此需要做些什么，这些规则类似于上面的目标分解，当编写好这些规则后，然后简单的执行一个命令也就是 make 就可以了。如果某个源文件被修改了，也只需要简单的重新执行一下 make 命令，因为整个过程的规则并没有改变，而 make 也会很聪明的只编译链接那些需要更新的目标文件，库，并重新进行可执行文件的生成。对于那些没有改动的源文件，make 不会重新编译它们。</p>
<p>make 中每一条规则与前面的目标划分非常相似，make 的规则是这样的：</p>
<blockquote>
<p>*<strong>target: prerequisites*</strong></p>
<p>​      *<strong>recipe*</strong></p>
</blockquote>
<p>target 也就类似于我们的一个目标；而 prerequisites，即先决条件，也就是依赖什么；recipe，这个就更形象了，即菜谱，也就是上面的要怎么做。make 中的规则保存在了叫做 Makefile 的文件当中 (没错，这个文件的名字就叫做 Makefile)，当运行 make 命令时，make 程序会自动找到当前路径下的 Makefile，然后开始执行里面的规则。</p>
<p>有些同学可能为此感到疑惑，这里的 Makefile 其实就是脚本，而 make 读取这个脚本然后根据里面的内容来执行命令，而对于 make 大家也不要觉得很神奇，make 也是一个普通程序，和我们平时使用的程序没什么区别。确定好了 make 需要执行的脚本的名字，这样在运行 make 命令时就少打了几个单词，假如用户可以自定义 make 的执行脚本名字，比如用户创建了一个脚本叫做 foo，那么执行 make 的时候就需要多打一个单词 “make foo”，所以干脆就直接确定好了脚本的名字就叫 Makefile，这样在运行命令时只需要打一个单词 make 就可以了。</p>
<p>这里举个简单的例子，比如我们写了一个 helloworld 程序，将源文件命名为了 helloworld.c，我们想把该源文件编程成一个叫做 hw 的可执行文件，那么一个最简单的 Makefile 就可以写成这样：</p>
<blockquote>
<p><em>hw: helloworld.o</em></p>
<p>​    <em>gcc helloworld.o -o hw</em></p>
<p><em>helloworld.o : helloworld.c</em></p>
<p>​    <em>gcc -c helloworld.c</em></p>
</blockquote>
<p>在这里最终的可执行文件 hw 依赖目标文件 helloworld.o，那么假设我们现在已经有 helloworld.o 了就可以利用命令 gcc helloworld.o -o hw 生成我们需要的可执行文件了。那么 helloworld.o 又该如何获得呢？我们看第二条规则，helloworld.o 依赖 helloworld.c，因为 helloworld.c 已经写好了，所以可以直接用命令 gcc -c helloworld.c 来生成。这样整个目标就达成了。</p>
<p>本质上现在我们使用的各种集成开发环境 (IDE)，其自动化编译工具背后的原理和 make 是一样的，比如我们在使用 Visual Studio 时从来没有关心过每个文件是如何被编译链接的，这些 IDE 都为我们代劳了。但是在比如 Linux 环境下进行开发时，这个过程依然是需要程序员了解的。</p>
<p>现在让我们来回答本节提出的问题，也就是大型项目是如何被构建的。</p>
<p>构建大型项目</p>
<p>大型项目中通常会有成百上千甚至上万个源文件，这些源文件统一放在了一个文件夹中方便管理。典型的项目如图所示，圆形代表源文件，其它为文件夹。注意这里仅仅为说明问题，各个公司团队都有自己的代码组织以及命名方式，而且真实项目要比该图复杂的多，但是本质上这里的讨论适用于其它情况。</p>
<p>源码组织方式</p>
<p>通常项目的组织方式如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102125.png" alt="image-20210730102125821"></p>
<p>项目源码会被放置在 src 当中，这个例子当中 src 下有两个文件夹，lib 以及 app，lib 用于存放一些工具性的代码，比如这里列举的网络通信以及字符串处理模块，通常 lib 下的代码会被编译成各种库，方便 app 使用。app 中就是各种需要可执行文件 (程序) 的代码了。通常像这里的 lib 以及 app 都会有专门的团队来负责。更大一些的项目，每个 lib 下的子目录比如这里的 net，strings 都会有专门的团队来负责以方便项目的模块化管理。</p>
<p>从这里可以看出一般项目通常会按模块将源文件放入相应的文件夹下进行分类，我们在上一节中简单介绍了 make 的用法，但是那里仅仅需要编译一个源文件 helloworld.c。对于如上图所示的项目，像 make 这一类的编译工具又该如何处理呢？</p>
<p>make 的嵌套执行能力可以解决这个问题。比如对于模块 net，你可以为 net 模块写一个单独的 Makefile，该 Makefile 只用于编译 net 下的源文件，具体的脚本如下所示，只需要简单的两行。</p>
<p><em>network:</em></p>
<p>​    <em>cd net &amp;&amp; make</em></p>
<ul>
<li></li>
<li></li>
</ul>
<p>这句话的意思是告诉 make，要想编译网络模块 (network) 需要进到 net 文件夹并且执行 make 命令，当 make 进入到 net 文件夹开始执行 make 时，net 下的 Makefile 就开始被执行了。通过这样一个简单的命令就可以实现 make 的嵌套执行了。make 的这项特性使得每个模块都可以当做独立项目进行维护。</p>
<p>编译工具的这项功能，方便了项目的模块化管理。使得项目中每个模块都可以有独立的编译脚本，比如使用 make 进行编译的话，那么每个模块中都会有单独的 Makefile，比如在文件夹 net，strings 中都有自己的 Makefile。如上图中蓝色部分，其中白色部分为源文件，更清晰的关于 Makefile 的组织方式如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102155.png" alt="image-20210730102155778"></p>
<p>这些脚本中定义了如何编译该模块，以及编译该模块需要依赖什么。这些模块的父目录也就是 lib 文件夹下同样也有自己的 Makefile，lib 下的 Makefile 会收集各个子模块的编译结果，然后将其链接成各种库。而对于 app 下面的子目录来说，这些子目录中就是各个可执行文件的源码了，比如这里的 wechat 文件下就是可执行程序微信的源码了，微信中可能会用到 lib 下提供的功能，那么对于 wechat 中的 Makefile 来说，只需要简单的加入对 lib 中所需要的库的依赖就可以了。wechat 的父目录 app 中同样也有 Makefile，这里的 Makefile 就相对简单了，只需要依次执行 QQ，wechat 中的 Makefile 就可以了，因此在 src 目录下简单的运行 make 命令，所有 app 比如 QQ 和 wechat 就都被编译出来了。</p>
<p>接下来我们详细的讲解一下这个过程。请注意一点，接下来讲解的 make 执行过程仅仅是可能的一种实现方式，但是这个示例已足够说明项目的构建过程。</p>
<p>make 的执行过程</p>
<p>在上面的示例中 src 下的 Makefile 是整个编译过程的入口，因此我们进入 src 文件夹开始执行 make 命令。</p>
<p>（1）在 src 目录下，make 首先读取 src 下的 Makefile，./src/Makefile 非常简单，该文件仅仅告诉 make 需要去 app 目录下执行 make 命令。</p>
<p>（2）make 来./src/app 目录下，开始读取该目录下的 Makefile，该文件定义了编译出 QQ，微信的规则，make 首先执行编译 QQ 的规则，该规则告诉 make 编译 QQ 则需要到./src/app/QQ 目录并执行 make 命令。</p>
<p>（3）make 来到./src/app/QQ 目录下，开始读取该目录下的 Makefile，该文件定义了编译 QQ 程序 的规则，make 开始执行这些规则，其中一项规则需要依赖网络模块的库，同时该规则告诉了 make 如果想得到该网络库则需要进入到./src/lib 下执行 make 命令。</p>
<p>（4）make 来到./src/lib 目录下，开始读取该目录下的 Makefile，该文件定义了编译出网络库，字符串处理库的规则，make 首先执行编译网络库的规则，该规则告诉 make 如果想得到该网络库则需要进入到./src/lib/net 下执行 make 命令。</p>
<p>（5）make 来到./src/lib/net 目录下，开始读取该目录下的 Makefile，该文件定义了编译网络库的规则，编译网络库不再依赖任何其它库，make 终于可以安心的开始工作不用再跳来跳去了，make 开始执行该目录下的 Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库 (当然也可以是动态库，依赖编译规则)。make 在./src/lib/net 完成任务后跳转回./src/lib，因为 make 会记住自己是从哪个目录跳转到当前目录的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102227.png" alt="image-20210730102227439"></p>
<p>（6）make 再次回到./src/lib 下，因为 make 执行完了网络库的编译规则，因此继续往下执行，也就是字符串库的编译规则，该规则告诉 make 如果想得到字符串库则需要进入到 src/lib/strings 下执行 make 命令。</p>
<p>（7）make 来到./src/lib/strings 目录项，开始读取该目录下的 Makefile，该文件定义了编译字符串库的规则，同样，编译字符串库不需要依赖任何其它库，make 开始执行该目录下的 Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库 (当然也可以是动态库)。make 在./src/lib/strings 下完成任务后跳转回./src/lib，因为 make 就是从这个目录跳转到./src/lib/strings 的。</p>
<p>（8）make 回到./src/lib，如果该目录下的 Makefile 还有其它编译规则，则继续上面的过程，如果没有其它规则，则该目录下的编译任务执行完成，make 返回到./src/app/QQ。</p>
<p>（9）make 回到./src/app/QQ 下继续执行被中断的规则，这时 QQ 所依赖的库都已经编译完成，因此 make 可以直接进行链接了，QQ 程序编译链接完成。make 返回到./src/app。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102246.png" alt="image-20210730102246124"></p>
<p>（10）make 来到./src/app 下继续执行被中断的规则，make 开始执行微信程序的编译规则，这里和 QQ 的编译是一样的，唯一一点即如果微信也需要依赖网络库和字符串库，那么当 make 调转到./src/lib 下会发现这些库已经生成了，因此直接返回。当 make 执行完./src/app 下的编译规则后，QQ 和微信程序就都编译完成了。make 返回到./src 后，发现该目录下的 Makefile 执行完毕，因此 make 程序退出，整个编译过程完成。</p>
<p>如果你对这个过程还不是很清楚的话，我们用一个游戏的类比来加深你对整个过程的理解。</p>
<p>相信很多同学都玩过 RPG (角色扮演) 游戏，比如仙剑奇侠传，阴阳师。你可以把大型项目的编译过程想象成玩 RPG 游戏，这类的游戏通常都会有一个主线，若干支线，通常主线的每一关都需要你去某个支线完成任务，例如拿到宝物之类，当你完成支线任务拿到宝物后，你才能回到主线进入到下一关。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102319.png" alt="image-20210730102319657"></p>
<p>在这里，make 程序就好比玩家，游戏里的任务就好比编译脚本 Makefile，主线任务就好比 app 下的 Makefile，支线任务就好比编译 app 所依赖的库或者目标文件，比如这里的 lib 下的 Makefile。</p>
<p>首先玩家 make 进入主线，也就是 app 下，读取主线需要完成的任务 (app 下的 Makefile)，主线任务告诉玩家 make 通过其中某一关 (比如编译出可执行文件 app1) 依赖一个支线任务，拿到宝物 (app1 所依赖的 lib 下的某个库)，这时玩家 make 开始去支线场景 (进入 lib 文件夹)，然后读取支线任务 (读取 lib 下的 Makefile)，make 开始在 lib 下打怪升级 (开始编译链接 lib 下源文件并生成相应的库)，当 make 完成支线任务拿到宝物 (lib 中编译出来的库) 回到主线任务 (回到 app 下 Makefile 因跳转到 lib 被中断的接下来的编译脚本) 后，才可以继续接下来的通关。</p>
<p>有的同学可能已经发现了，像上面的这种编译实现方式其实是比较混乱的，既然我们 make 给了我们可以将每个模块当做独立项目进行编译的能力，那么对于非应用程序的代码比如这里的 src/lib，我们可以提前编译出来，最后再来编译 src/app 下的代码，这样当依赖某个库时无需再去将该库编译出来。使用上面的编译顺序是为了说明 make 的构建方式是多样的，实际上使用 make 这一类的工具你可以使用任何你想要的编译顺序进行项目构建，本质上写 Makefile 就是写程序，这些程序告诉 make 该如何构建出最后的可执行文件，至于构建程序该以什么样的顺序构建出可执行文件，一切由你做主。这就是 make 这类编译工具的灵活以及强大之处。</p>
<p>还有一点需要注意的就是，真实的项目中会有很多模块是相互独立的，即这些模块互不依赖，为加快编译速度，make 支持并行编译以充分利用多核的处理能力。</p>
<p>关于大型项目的构建到这里就讲解的差不多了，我们可以看到大型项目的构建其实和我们平时完成一个目标是类似的，先有一个大的目标并将其分解为一个个比较容易实现的小目标，当所有的小目标完成后我们的目的也就是实现了。本质上大型项目的构建与此类似。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>查看 gcc 的宏定义</title>
    <url>/posts/12403.html</url>
    <content><![CDATA[<h2 id="1、查看gcc默认的内置宏定义"><a href="#1、查看gcc默认的内置宏定义" class="headerlink" title="1、查看gcc默认的内置宏定义"></a>1、查看 gcc 默认的内置宏定义</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -dM -E - &lt; /dev/null</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -dM -E helloworld.c</span><br></pre></td></tr></tbody></table></figure>

<p> helloworld.c 为用户随意编写的 c 测试用例，随意拿个 c 程序就行。</p>
<p>-E 预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC 忽略任何不需要预处理的输入文件。</p>
<p>-dM 告诉预处理器输出有效的宏定义列表 (预处理结束时仍然有效的宏定义)。该选项需结合 `-E’选项使用。</p>
<h2 id="2、打开用户自行设置的宏定义"><a href="#2、打开用户自行设置的宏定义" class="headerlink" title="2、打开用户自行设置的宏定义"></a>2、打开用户自行设置的宏定义</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -DDEBUG helloworld.c</span><br></pre></td></tr></tbody></table></figure>

<p>helloworld.c 文件中的宏定义 DEBUG 如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    printf("DEBUG is defined ! ");</span><br><span class="line">#else</span><br><span class="line">    printf("DEBUG is not defined ! ");</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>



<h2 id="总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义"><a href="#总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义" class="headerlink" title="总结：gcc内部默认的宏定义+用户自行设置的宏定义=所有的宏定义"></a>总结：gcc 内部默认的宏定义 + 用户自行设置的宏定义 = 所有的宏定义</h2>]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编指令 call、ret、jump 的区别</title>
    <url>/posts/579bc51e.html</url>
    <content><![CDATA[<h2 id="call、ret、jump指令介绍"><a href="#call、ret、jump指令介绍" class="headerlink" title="call、ret、jump指令介绍"></a>call、ret、jump 指令介绍</h2><ul>
<li><p><code>call</code> 用于调用子程序，在调用前会保存返回地址（x86 架构下，段内跳转时只保存 EIP；段间跳转还会保存 CS）。<code>ret</code> 会返回到 <code>call</code> 指令的下一行，也就是跳转前已保存的返回地址。通常在函数调用时，<code>call</code> 和 <code>ret</code> 都是成对出现的。</p>
</li>
<li><p><code>jmp</code> 会直接进行跳转，不会保存返回地址，<code>jmp</code> 之后的指令如果跟了 <code>ret</code>，那就直接退出到上一个 <code>call</code> 指令对应的下一行。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="call和ret使用方法"><a href="#call和ret使用方法" class="headerlink" title="call和ret使用方法"></a>call 和 ret 使用方法</h2><p>call 和 ret 指令用来调用子程序和从子程序返回：</p>
<ul>
<li><p>call 的使用方法：call 子程序入口处地址，该地址可以是标号，也可以存放在寄存器和内存中。</p>
</li>
<li><p>ret 的使用方法：直接在子程序中使用 ret 指令即可，可以没有参数，执行该指令会直接返回至调用子程序的位置处。</p>
</li>
</ul>
<h2 id="之前遇到的一个bug"><a href="#之前遇到的一个bug" class="headerlink" title="之前遇到的一个bug"></a>之前遇到的一个 bug</h2><p>函数 A 调用函数 B，然后在函数 B 里进行协程切换，进入到协程上下文（此时还没有结束函数调用）。在新的协程上下文中，使用 <code>ret $27</code>，gcc 编译能够跳转到 $27 指定的地址处，clang 编译则会忽略 $27 的值，clang 编译器规定 ret 指令编译成 ret $ra，从而导致报错。</p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 gcc 编译报错 - Werror=missing-attributes</title>
    <url>/posts/355d67a9.html</url>
    <content><![CDATA[<p>交叉编译 gcc 工具链时，遇到了 <code>[-Werror=missing-attributes]</code> 报错，这是一个把警告当错误的情况，应该是由于高版本 gcc 编译低版本 gcc 时报的错误。然而修改了 configure 命令，在后面跟上了<code> --disable-werror</code> 选项，并没有用。最终通过设置 <code>CFLAGS</code> 和 <code>CXXFLAGS</code> 才解决了。</p>
<span id="more"></span>

<p>具体如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CFLAGS="-Wno-error=missing-attributes" CXXFLAGS="-Wno-error=missing-auttributes" ../gcc-8.3.0/configure --prefix=/home/lhx/gcc830/install/ --build=x86_64-linux-gnu --host=powerpc-linux-gnu</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>boost 协程中 arm64 和 x86_64 架构汇编实现</title>
    <url>/posts/4059c7aa.html</url>
    <content><![CDATA[<p>boost 协程上下文切换 make_arm64_aapcs_elf_gas.S 和 jump_arm64_aapcs_elf_gas.S 以及 make_x86_64_aapcs_elf_gas.S 和 jump_x86_64_aapcs_elf_gas.S 汇编源码分析</p>
<span id="more"></span>

<p>源码目录：<code>boost-1.58.0\libs\context\src\asm</code></p>
<h2 id="make-arm64-aapcs-elf-gas-S"><a href="#make-arm64-aapcs-elf-gas-S" class="headerlink" title="make_arm64_aapcs_elf_gas.S"></a>make_arm64_aapcs_elf_gas.S</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">            Copyright Edward Nevill 2015</span><br><span class="line">   Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">      (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">          http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">*/</span><br><span class="line">/*******************************************************</span><br><span class="line"> *                                                     *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    d8     |    d9     |    d10    |    d11    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    d12    |    d13    |    d14    |    d15    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x19    |    x20    |    x21    |    x22    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x23    |    x24    |    x25    |    x26    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x27    |    x28    |    FP     |     LR    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  40 |  41 |  42 | 43  |           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |     PC    |   align   |           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *                                                     *</span><br><span class="line"> *******************************************************/</span><br><span class="line"></span><br><span class="line">.cpu    generic+fp+simd</span><br><span class="line">.text</span><br><span class="line">.align  2</span><br><span class="line">.global make_fcontext</span><br><span class="line">.type   make_fcontext, %function</span><br><span class="line">make_fcontext:</span><br><span class="line">    # shift address in x0 (allocated stack) to lower 16 byte boundary</span><br><span class="line">    and x0, x0, ~0xF</span><br><span class="line"></span><br><span class="line">    # reserve space for context-data on context-stack</span><br><span class="line">    sub  x0, x0, #0xb0</span><br><span class="line"></span><br><span class="line">    # third arg of make_fcontext() == address of context-function</span><br><span class="line">    # store address as a PC to jump in</span><br><span class="line">    str  x2, [x0, #0xa0]</span><br><span class="line"></span><br><span class="line">    # save address of finish as return-address for context-function</span><br><span class="line">    # will be entered after context-function returns (LR register)</span><br><span class="line">    adr  x1, finish</span><br><span class="line">    str  x1, [x0, #0x98]</span><br><span class="line"></span><br><span class="line">    ret  x30 // return pointer to context-data (x0)</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    # exit code is zero</span><br><span class="line">    mov  x0, #0</span><br><span class="line">    # exit application</span><br><span class="line">    bl  _exit</span><br><span class="line"></span><br><span class="line">.size   make_fcontext,.-make_fcontext</span><br><span class="line"># Mark that we don't need executable stack.</span><br><span class="line">.section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>



<h2 id="jump-arm64-aapcs-elf-gas-S"><a href="#jump-arm64-aapcs-elf-gas-S" class="headerlink" title="jump_arm64_aapcs_elf_gas.S"></a>jump_arm64_aapcs_elf_gas.S</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">            Copyright Edward Nevill 2015</span><br><span class="line">   Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">      (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">          http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">*/</span><br><span class="line">/*******************************************************</span><br><span class="line"> *                                                     *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x0 | 0x4 | 0x8 | 0xc | 0x10| 0x14| 0x18| 0x1c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    d8     |    d9     |    d10    |    d11    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  8  |  9  |  10 |  11 |  12 |  13 |  14 |  15 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x20| 0x24| 0x28| 0x2c| 0x30| 0x34| 0x38| 0x3c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    d12    |    d13    |    d14    |    d15    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  16 |  17 |  18 |  19 |  20 |  21 |  22 |  23 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x40| 0x44| 0x48| 0x4c| 0x50| 0x54| 0x58| 0x5c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x19    |    x20    |    x21    |    x22    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  24 |  25 |  26 |  27 |  28 |  29 |  30 |  31 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x60| 0x64| 0x68| 0x6c| 0x70| 0x74| 0x78| 0x7c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x23    |    x24    |    x25    |    x26    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  32 |  33 |  34 |  35 |  36 |  37 |  38 |  39 |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0x80| 0x84| 0x88| 0x8c| 0x90| 0x94| 0x98| 0x9c|  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |    x27    |    x28    |    FP     |     LR    |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |  40 |  41 |  42 | 43  |           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  | 0xa0| 0xa4| 0xa8| 0xac|           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *  |     PC    |   align   |           |           |  *</span><br><span class="line"> *  -------------------------------------------------  *</span><br><span class="line"> *                                                     *</span><br><span class="line"> *******************************************************/</span><br><span class="line"></span><br><span class="line">.cpu    generic+fp+simd</span><br><span class="line">.text</span><br><span class="line">.align  2</span><br><span class="line">.global jump_fcontext</span><br><span class="line">.type   jump_fcontext, %function</span><br><span class="line">jump_fcontext:</span><br><span class="line">    # prepare stack for GP + FPU</span><br><span class="line">    sub  sp, sp, #0xb0</span><br><span class="line"></span><br><span class="line"># Because gcc may save integer registers in fp registers across a</span><br><span class="line"># function call we cannot skip saving the fp registers.</span><br><span class="line">#</span><br><span class="line"># Do not reinstate this test unless you fully understand what you</span><br><span class="line"># are doing.</span><br><span class="line">#</span><br><span class="line">#    # test if fpu env should be preserved</span><br><span class="line">#    cmp  w3, #0</span><br><span class="line">#    b.eq  1f</span><br><span class="line"></span><br><span class="line">    # save d8 - d15</span><br><span class="line">    stp  d8,  d9,  [sp, #0x00]</span><br><span class="line">    stp  d10, d11, [sp, #0x10]</span><br><span class="line">    stp  d12, d13, [sp, #0x20]</span><br><span class="line">    stp  d14, d15, [sp, #0x30]</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">    # save x19-x30</span><br><span class="line">    stp  x19, x20, [sp, #0x40]</span><br><span class="line">    stp  x21, x22, [sp, #0x50]</span><br><span class="line">    stp  x23, x24, [sp, #0x60]</span><br><span class="line">    stp  x25, x26, [sp, #0x70]</span><br><span class="line">    stp  x27, x28, [sp, #0x80]</span><br><span class="line">    stp  x29, x30, [sp, #0x90]</span><br><span class="line"></span><br><span class="line">    # save LR as PC</span><br><span class="line">    str  x30, [sp, #0xa0]</span><br><span class="line"></span><br><span class="line">    # store RSP (pointing to context-data) in first argument (x0).</span><br><span class="line">    # STR cannot have sp as a target register</span><br><span class="line">    mov  x4, sp</span><br><span class="line">    str  x4, [x0]</span><br><span class="line"></span><br><span class="line">    # restore RSP (pointing to context-data) from A2 (x1)</span><br><span class="line">    mov  sp, x1</span><br><span class="line"></span><br><span class="line">#    # test if fpu env should be preserved</span><br><span class="line">#    cmp  w3, #0</span><br><span class="line">#    b.eq  2f</span><br><span class="line"></span><br><span class="line">    # load d8 - d15</span><br><span class="line">    ldp  d8,  d9,  [sp, #0x00]</span><br><span class="line">    ldp  d10, d11, [sp, #0x10]</span><br><span class="line">    ldp  d12, d13, [sp, #0x20]</span><br><span class="line">    ldp  d14, d15, [sp, #0x30]</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">    # load x19-x30</span><br><span class="line">    ldp  x19, x20, [sp, #0x40]</span><br><span class="line">    ldp  x21, x22, [sp, #0x50]</span><br><span class="line">    ldp  x23, x24, [sp, #0x60]</span><br><span class="line">    ldp  x25, x26, [sp, #0x70]</span><br><span class="line">    ldp  x27, x28, [sp, #0x80]</span><br><span class="line">    ldp  x29, x30, [sp, #0x90]</span><br><span class="line"></span><br><span class="line">    # use third arg as return value after jump</span><br><span class="line">    # and as first arg in context function</span><br><span class="line">    mov  x0, x2</span><br><span class="line"></span><br><span class="line">    # load pc</span><br><span class="line">    ldr  x4, [sp, #0xa0]</span><br><span class="line"></span><br><span class="line">    # restore stack from GP + FPU</span><br><span class="line">    add  sp, sp, #0xb0</span><br><span class="line"></span><br><span class="line">    ret x4</span><br><span class="line">.size   jump_fcontext,.-jump_fcontext</span><br><span class="line"># Mark that we don't need executable stack.</span><br><span class="line">.section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>

<h2 id="make-x86-64-sysv-elf-gas-S"><a href="#make-x86-64-sysv-elf-gas-S" class="headerlink" title="make_x86_64_sysv_elf_gas.S"></a>make_x86_64_sysv_elf_gas.S</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">            Copyright Oliver Kowalke 2009.</span><br><span class="line">   Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">      (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">            http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/****************************************************************************************</span><br><span class="line"> *                                                                                      *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |        R15        |        RBX        |         RBP        |        RIP        |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    16   |   17    |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x40  |   0x44  |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |        EXIT       |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *                                                                                      *</span><br><span class="line"> ****************************************************************************************/</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl make_fcontext</span><br><span class="line">.type make_fcontext,@function</span><br><span class="line">.align 16</span><br><span class="line">make_fcontext:</span><br><span class="line">    /* first arg of make_fcontext() == top of context-stack */</span><br><span class="line">    movq  %rdi, %rax</span><br><span class="line"></span><br><span class="line">    /* shift address in RAX to lower 16 byte boundary */</span><br><span class="line">    andq  $-16, %rax</span><br><span class="line"></span><br><span class="line">    /* reserve space for context-data on context-stack */</span><br><span class="line">    /* size for fc_mxcsr .. RIP + return-address for context-function */</span><br><span class="line">    /* on context-function entry: (RSP -0x8) % 16 == 0 */</span><br><span class="line">    leaq  -0x48(%rax), %rax</span><br><span class="line"></span><br><span class="line">    /* third arg of make_fcontext() == address of context-function */</span><br><span class="line">    movq  %rdx, 0x38(%rax)</span><br><span class="line"></span><br><span class="line">    /* save MMX control- and status-word */</span><br><span class="line">    stmxcsr  (%rax)</span><br><span class="line">    /* save x87 control-word */</span><br><span class="line">    fnstcw   0x4(%rax)</span><br><span class="line"></span><br><span class="line">    /* compute abs address of label finish */</span><br><span class="line">    leaq  finish(%rip), %rcx</span><br><span class="line">    /* save address of finish as return-address for context-function */</span><br><span class="line">    /* will be entered after context-function returns */</span><br><span class="line">    movq  %rcx, 0x40(%rax)</span><br><span class="line"></span><br><span class="line">    ret /* return pointer to context-data */</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    /* exit code is zero */</span><br><span class="line">    xorq  %rdi, %rdi</span><br><span class="line">    /* exit application */</span><br><span class="line">    call  _exit@PLT</span><br><span class="line">    hlt</span><br><span class="line">.size make_fcontext,.-make_fcontext</span><br><span class="line"></span><br><span class="line">/* Mark that we don't need executable stack. */</span><br><span class="line">.section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>


<h2 id="jump-x86-64-sysv-elf-gas-S"><a href="#jump-x86-64-sysv-elf-gas-S" class="headerlink" title="jump_x86_64_sysv_elf_gas.S"></a>jump_x86_64_sysv_elf_gas.S</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">            Copyright Oliver Kowalke 2009.</span><br><span class="line">   Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">      (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">            http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/****************************************************************************************</span><br><span class="line"> *                                                                                      *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |        R15        |        RBX        |         RBP        |        RIP        |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |    16   |   17    |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |   0x40  |   0x44  |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *  |        EXIT       |                                                            |  *</span><br><span class="line"> *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> *                                                                                      *</span><br><span class="line"> ****************************************************************************************/</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl jump_fcontext</span><br><span class="line">.type jump_fcontext,@function</span><br><span class="line">.align 16</span><br><span class="line">jump_fcontext:</span><br><span class="line">    pushq  %rbp  /* save RBP */</span><br><span class="line">    pushq  %rbx  /* save RBX */</span><br><span class="line">    pushq  %r15  /* save R15 */</span><br><span class="line">    pushq  %r14  /* save R14 */</span><br><span class="line">    pushq  %r13  /* save R13 */</span><br><span class="line">    pushq  %r12  /* save R12 */</span><br><span class="line"></span><br><span class="line">    /* prepare stack for FPU */</span><br><span class="line">    leaq  -0x8(%rsp), %rsp</span><br><span class="line"></span><br><span class="line">    /* test for flag preserve_fpu */</span><br><span class="line">    cmp  $0, %rcx</span><br><span class="line">    je  1f</span><br><span class="line"></span><br><span class="line">    /* save MMX control- and status-word */</span><br><span class="line">    stmxcsr  (%rsp)</span><br><span class="line">    /* save x87 control-word */</span><br><span class="line">    fnstcw   0x4(%rsp)</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">    /* store RSP (pointing to context-data) in RDI */</span><br><span class="line">    movq  %rsp, (%rdi)</span><br><span class="line"></span><br><span class="line">    /* restore RSP (pointing to context-data) from RSI */</span><br><span class="line">    movq  %rsi, %rsp</span><br><span class="line"></span><br><span class="line">    /* test for flag preserve_fpu */</span><br><span class="line">    cmp  $0, %rcx</span><br><span class="line">    je  2f</span><br><span class="line"></span><br><span class="line">    /* restore MMX control- and status-word */</span><br><span class="line">    ldmxcsr  (%rsp)</span><br><span class="line">    /* restore x87 control-word */</span><br><span class="line">    fldcw  0x4(%rsp)</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">    /* prepare stack for FPU */</span><br><span class="line">    leaq  0x8(%rsp), %rsp</span><br><span class="line"></span><br><span class="line">    popq  %r12  /* restrore R12 */</span><br><span class="line">    popq  %r13  /* restrore R13 */</span><br><span class="line">    popq  %r14  /* restrore R14 */</span><br><span class="line">    popq  %r15  /* restrore R15 */</span><br><span class="line">    popq  %rbx  /* restrore RBX */</span><br><span class="line">    popq  %rbp  /* restrore RBP */</span><br><span class="line"></span><br><span class="line">    /* restore return-address */</span><br><span class="line">    popq  %r8</span><br><span class="line"></span><br><span class="line">    /* use third arg as return-value after jump */</span><br><span class="line">    movq  %rdx, %rax</span><br><span class="line">    /* use third arg as first arg in context function */</span><br><span class="line">    movq  %rdx, %rdi</span><br><span class="line"></span><br><span class="line">    /* indirect jump to context */</span><br><span class="line">    jmp  *%r8</span><br><span class="line">.size jump_fcontext,.-jump_fcontext</span><br><span class="line"></span><br><span class="line">/* Mark that we don't need executable stack.  */</span><br><span class="line">.section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>

<h2 id="x86-64架构上下文切换"><a href="#x86-64架构上下文切换" class="headerlink" title="x86_64架构上下文切换"></a>x86_64 架构上下文切换</h2><p>实现协程最核心的部分就是栈切换了，其他的和非阻塞 io 的编程方式没什么区别。</p>
<p>栈切换，libc 中有一个实现，swapcontext，但是已经被标准移除了，未来是否可用不得而知，自己实现需要写汇编代码，这是一个很困难的任务，因为既要熟悉不同 cpu 指令集又要熟悉不同平台的标准，好在从 boost library 的协程实现中找到了已经写好了的栈切换汇编代码，利用这些汇编代码可以在 c 语言中实现栈切换。</p>
<p>这段代码是在 s_task 协程库中发现的，s_task 很好，还可以和 libuv 结合，如果没有特殊要求，可以直接使用了，但是如果想根据自己工作中的业务逻辑做定制，还是需要掌握原理，并且不清楚原理，可能不能用最恰当的方式使用，实现最好的设计，出了问题也不知道该怎么查和用什么办法查。</p>
<p>附上 s_task 和 boost library 的地址，感兴趣的可以去研究一下。</p>
<p><a href="https://github.com/xhawk18/s_task">https://github.com/xhawk18/s_task</a></p>
<p><a href="https://github.com/boostorg/context">https://github.com/boostorg/context</a></p>
<p>栈切换代码在源码的 asm 目录中，实际上在 c 语言中对应两个函数，</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">typedef void* fcontext_t;</span><br><span class="line">typedef struct {</span><br><span class="line">    fcontext_t  fctx;</span><br><span class="line">    void* data;</span><br><span class="line">} transfer_t;</span><br><span class="line"></span><br><span class="line">extern transfer_t jump_fcontext( fcontext_t const to, void * vp);</span><br><span class="line">extern fcontext_t make_fcontext( void * sp, size_t size, void (* fn)( transfer_t) );</span><br></pre></td></tr></tbody></table></figure>

<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212231034473.gif" alt="复制代码"></a></p>
<p>这两个函数是什么意思，怎么用，看了 s_task 中的代码，但是开始的时候还是没看懂，于是想从汇编的角度入手，最终通过 x86_64 的汇编代码 (make_x86_64_sysv_elf_gas.S jump_x86_64_sysv_elf_gas.S) 弄清楚了这两个函数的用法，结论在本文最末尾，如果只想看结果，可以跳到最后面。</p>
<p>直接看代码注释吧。</p>
<p>make_x86_64_sysv_elf_gas.S</p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212231034473.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  1 /*</span><br><span class="line">  2             Copyright Oliver Kowalke 2009.</span><br><span class="line">  3    Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">  4       (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">  5             http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">  6 */</span><br><span class="line">  7 </span><br><span class="line">  8 // 栈空间图，栈顶在低地址，注意和jump_x86_64_sysv_elf_gas.S对比着看，里面代表的是内存(栈，运行现场)中的数据</span><br><span class="line">  9 // 不代表寄存器，途中标的寄存器的意思是这些寄存器在保存现场的时候会保存到对应的内存地址中</span><br><span class="line"> 10 /****************************************************************************************</span><br><span class="line"> 11  *                                                                                      *</span><br><span class="line"> 12  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 13  *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *</span><br><span class="line"> 14  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 15  *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *</span><br><span class="line"> 16  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 17  *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *</span><br><span class="line"> 18  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 19  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 20  *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *</span><br><span class="line"> 21  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 22  *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *</span><br><span class="line"> 23  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 24  *  |        R15        |        RBX        |         RBP        |        RIP        |  *</span><br><span class="line"> 25  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 26  *                                                                                      *</span><br><span class="line"> 27  ****************************************************************************************/</span><br><span class="line"> 28 </span><br><span class="line"> 29 .file "make_x86_64_sysv_elf_gas.S"</span><br><span class="line"> 30 .text</span><br><span class="line"> 31 .globl make_fcontext</span><br><span class="line"> 32 .type make_fcontext,@function</span><br><span class="line"> 33 .align 16</span><br><span class="line"> 34 make_fcontext:</span><br><span class="line"> 35 // make_fcontext的第一个参数保存到rax中，rax现在开始代表了这个运行环境的栈顶，</span><br><span class="line"> 36 // rax也是本函数的返回值，</span><br><span class="line"> 37     /* first arg of make_fcontext() == top of context-stack */</span><br><span class="line"> 38     movq  %rdi, %rax</span><br><span class="line"> 39 </span><br><span class="line"> 40 // 16对齐, 规定的</span><br><span class="line"> 41     /* shift address in RAX to lower 16 byte boundary */</span><br><span class="line"> 42     andq  $-16, %rax</span><br><span class="line"> 43 </span><br><span class="line"> 44 // -0x40就是将栈顶指针(栈顶寄存器，这里不是rsp，是rax，rsp是当前运行环境使用的)移动到图中的0位置，即分配栈空间</span><br><span class="line"> 45 // 递减栈是向下分配的</span><br><span class="line"> 46     /* reserve space for context-data on context-stack */</span><br><span class="line"> 47     /* on context-function entry: (RSP -0x8) % 16 == 0 */</span><br><span class="line"> 48     leaq  -0x40(%rax), %rax</span><br><span class="line"> 49 </span><br><span class="line"> 50 // size那个参数这里没有使用，第三个参数是fn，要执行的函数</span><br><span class="line"> 51 // 这里把fn的地址放到了0x28的位置，恢复到寄存器就是rbx</span><br><span class="line"> 52     /* third arg of make_fcontext() == address of context-function */</span><br><span class="line"> 53     /* stored in RBX */</span><br><span class="line"> 54     movq  %rdx, 0x28(%rax)</span><br><span class="line"> 55 </span><br><span class="line"> 56 // 这两个寄存器不清楚</span><br><span class="line"> 57     /* save MMX control- and status-word */</span><br><span class="line"> 58     stmxcsr  (%rax)</span><br><span class="line"> 59     /* save x87 control-word */</span><br><span class="line"> 60     fnstcw   0x4(%rax)</span><br><span class="line"> 61 </span><br><span class="line"> 62 // 从英文注释看，实现的是将trampoline的地址保存在0x38的位置，即rip保存的地方，返回之后接着运行的地址</span><br><span class="line"> 63 // 所以这个地方实际上是设置了跳转过来之后执行的指令的位置，jump_fcontext认为自己跳到了</span><br><span class="line"> 64 // 一个暂停过的地方，即保存过现场的地方，恢复现场继续执行，而这里是首次运行，所以要模拟这种场景</span><br><span class="line"> 65 // 也就是说启动一个任务之后会先运行trampoline那里。</span><br><span class="line"> 66     /* compute abs address of label trampoline */</span><br><span class="line"> 67     leaq  trampoline(%rip), %rcx</span><br><span class="line"> 68     /* save address of trampoline as return-address for context-function */</span><br><span class="line"> 69     /* will be entered after calling jump_fcontext() first time */</span><br><span class="line"> 70     movq  %rcx, 0x38(%rax)</span><br><span class="line"> 71 </span><br><span class="line"> 72 // 这里是把finish处的地址放到0x30中， 是一个技巧，见trampoline处</span><br><span class="line"> 73     /* compute abs address of label finish */</span><br><span class="line"> 74     leaq  finish(%rip), %rcx</span><br><span class="line"> 75     /* save address of finish as return-address for context-function */</span><br><span class="line"> 76     /* will be entered after context-function returns */</span><br><span class="line"> 77     movq  %rcx, 0x30(%rax)</span><br><span class="line"> 78 </span><br><span class="line"> 79 // make_fcontext函数返回</span><br><span class="line"> 80     ret /* return pointer to context-data */</span><br><span class="line"> 81 </span><br><span class="line"> 82 trampoline:</span><br><span class="line"> 83     /* store return address on stack */</span><br><span class="line"> 84     /* fix stack alignment */</span><br><span class="line"> 85     // 从jump_x86_64_sysv_elf_gas.S中可以看出，跳到这里之前已经从栈空间中恢复了rbp，也就是说</span><br><span class="line"> 86     // 现在rbp保存的是finish的地址，因为rbp是从0x30恢复的，0x30前面已经保存了finish的地址</span><br><span class="line"> 87     // 现在的栈顶rsp呢，是在图中0x40的位置，见jump_x86_64_sysv_elf_gas.S中的  leaq  0x40(%rsp), %rsp</span><br><span class="line"> 88     // 现在push rbp是把fish的地址push到了0x38的位置，也就是本应该保存返回地址rip的地方，</span><br><span class="line"> 89     // 也就是说fn运行结束返回到make_fcontext的finish处继续运行，就好像是make_fcontext调用</span><br><span class="line"> 90     // 的fn一样，当然只是好像而已。可见fn返回了整个进程就退出了，这是make_fcontext指定的。</span><br><span class="line"> 91     push %rbp</span><br><span class="line"> 92 </span><br><span class="line"> 93     // rbx是设置的fn的地址，跳到fn运行，首次运行fn任务才会走到这里，中间暂停了</span><br><span class="line"> 94     // 是恢复从暂停的地方的下一个指令开始执行。</span><br><span class="line"> 95     /* jump to context-function */</span><br><span class="line"> 96     jmp *%rbx</span><br><span class="line"> 97 </span><br><span class="line"> 98 finish:</span><br><span class="line"> 99 // 这里的代码就是退出进程了</span><br><span class="line">100     /* exit code is zero */</span><br><span class="line">101     xorq  %rdi, %rdi</span><br><span class="line">102     /* exit application */</span><br><span class="line">103     call  _exit@PLT</span><br><span class="line">104     hlt</span><br><span class="line">105 .size make_fcontext,.-make_fcontext</span><br><span class="line">106 </span><br><span class="line">107 /* Mark that we don't need executable stack. */</span><br><span class="line">108 .section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>


<p>jump_x86_64_sysv_elf_gas.S</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  1 /*</span><br><span class="line">  2             Copyright Oliver Kowalke 2009.</span><br><span class="line">  3    Distributed under the Boost Software License, Version 1.0.</span><br><span class="line">  4       (See accompanying file LICENSE_1_0.txt or copy at</span><br><span class="line">  5             http://www.boost.org/LICENSE_1_0.txt)</span><br><span class="line">  6 */</span><br><span class="line">  7 </span><br><span class="line">  8 // 栈空间图，栈顶在低地址，注意和make_x86_64_sysv_elf_gas.S对比着看，里面代表的是内存(栈，运行现场)中的数据</span><br><span class="line">  9 // 不代表寄存器，途中标的寄存器的意思是这些寄存器在保存现场的时候会保存到对应的内存地址中</span><br><span class="line"> 10 /****************************************************************************************</span><br><span class="line"> 11  *                                                                                      *</span><br><span class="line"> 12  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 13  *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *</span><br><span class="line"> 14  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 15  *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *</span><br><span class="line"> 16  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 17  *  | fc_mxcsr|fc_x87_cw|        R12        |         R13        |        R14        |  *</span><br><span class="line"> 18  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 19  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 20  *  |    8    |    9    |   10    |   11    |    12    |    13   |    14   |    15   |  *</span><br><span class="line"> 21  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 22  *  |   0x20  |   0x24  |   0x28  |  0x2c   |   0x30   |   0x34  |   0x38  |   0x3c  |  *</span><br><span class="line"> 23  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 24  *  |        R15        |        RBX        |         RBP        |        RIP        |  *</span><br><span class="line"> 25  *  ----------------------------------------------------------------------------------  *</span><br><span class="line"> 26  *                                                                                      *</span><br><span class="line"> 27  ****************************************************************************************/</span><br><span class="line"> 28 </span><br><span class="line"> 29 .file "jump_x86_64_sysv_elf_gas.S"</span><br><span class="line"> 30 .text</span><br><span class="line"> 31 .globl jump_fcontext</span><br><span class="line"> 32 .type jump_fcontext,@function</span><br><span class="line"> 33 .align 16</span><br><span class="line"> 34 jump_fcontext:</span><br><span class="line"> 35 // 保存当前的运行现场，caller-saved registers调用者保存，这里只保存callee-saved registers</span><br><span class="line"> 36     leaq  -0x38(%rsp), %rsp /* prepare stack */</span><br><span class="line"> 37 </span><br><span class="line"> 38 #if !defined(BOOST_USE_TSX)</span><br><span class="line"> 39     stmxcsr  (%rsp)     /* save MMX control- and status-word */</span><br><span class="line"> 40     fnstcw   0x4(%rsp)  /* save x87 control-word */</span><br><span class="line"> 41 #endif</span><br><span class="line"> 42 </span><br><span class="line"> 43     movq  %r12, 0x8(%rsp)  /* save R12 */</span><br><span class="line"> 44     movq  %r13, 0x10(%rsp)  /* save R13 */</span><br><span class="line"> 45     movq  %r14, 0x18(%rsp)  /* save R14 */</span><br><span class="line"> 46     movq  %r15, 0x20(%rsp)  /* save R15 */</span><br><span class="line"> 47     movq  %rbx, 0x28(%rsp)  /* save RBX */</span><br><span class="line"> 48     movq  %rbp, 0x30(%rsp)  /* save RBP */</span><br><span class="line"> 49     // 这里为什么没有使用0x38位置的8个字节，因为这里面存的是返回地址，即本函数返回的时候</span><br><span class="line"> 50     // 要继续运行的指令的地址，在调用jump_fcontext的时候已经保存了，所以这里不用保存</span><br><span class="line"> 51     // 看make_fcontext可以看到，那里使用了0x38，因为那个fcontext不是通过调用jump_fcontext</span><br><span class="line"> 52     // 生成的，而是人为制造的。</span><br><span class="line"> 53     //</span><br><span class="line"> 54 // 保存现场完毕</span><br><span class="line"> 55 </span><br><span class="line"> 56 // 函数的调用者会在被调用函数退出的时候读取rax作为返回值</span><br><span class="line"> 57 // transfer_t需要两个寄存器保存，另一个是rdx</span><br><span class="line"> 58 // 但注意这里的返回值不是本次jump_fcontext调用的返回值，</span><br><span class="line"> 59 // 而是另一个栈空间的jump_fcontext，本次调用是不返回的，</span><br><span class="line"> 60 // 实际上所有的jump_fcontext都是不返回的，都是别的地方</span><br><span class="line"> 61 // 跳过去，看起来好像是它返回</span><br><span class="line"> 62 //</span><br><span class="line"> 63 // 函数调用就好比是一维世界，从哪里进，再从哪里出，而jump_fcontext好比是二维的世界，</span><br><span class="line"> 64 // 从“天上”跑了，再从“天上”掉下来。</span><br><span class="line"> 65     /* store RSP (pointing to context-data) in RAX */</span><br><span class="line"> 66     movq  %rsp, %rax</span><br><span class="line"> 67 </span><br><span class="line"> 68 // 把jump_fcontext第一个参数给rsp，第一个参数即运行上下文，别的地方</span><br><span class="line"> 69 // 保存现场或make_fcontext生成的栈顶地址，这里放到</span><br><span class="line"> 70 // rsp中，即完成了栈空间的切换，下条命令开始就是在另一个</span><br><span class="line"> 71 // 栈空间运行了，已经跳走完成， 跳之前做了什么呢，保存现场</span><br><span class="line"> 72 // 并且把现场放到rax中，跳过去之后的返回值会返回跳之前的现场</span><br><span class="line"> 73     /* restore RSP (pointing to context-data) from RDI */</span><br><span class="line"> 74     movq  %rdi, %rsp</span><br><span class="line"> 75 </span><br><span class="line"> 76 // 这里开始是一个新的栈空间了，也就是一个新的任务</span><br><span class="line"> 77 // 分两种情况，</span><br><span class="line"> 78 // 1. 如果是恢复一个任务的运行，那么rsp是它调用jump_fcontext切换走</span><br><span class="line"> 79 //    的时候的现场,现在开始恢复，这时0x38位置是返回地址，也就是这个</span><br><span class="line"> 80 //    任务在上一次调用jump_fcontext(暂停，切换到其他任务)的时候保存</span><br><span class="line"> 81 //    的调用jump_fcontext后面的那个指令对应的地址，即从暂停的位置</span><br><span class="line"> 82 //    继续执行。</span><br><span class="line"> 83 // 2. 如果是新制造出来的任务，0x38保存的是make_fcontext中的trampoline</span><br><span class="line"> 84 //    也就是会跳到那里执行。</span><br><span class="line"> 85 //</span><br><span class="line"> 86 //  目前只是放到了r8中，还没有开始执行，后面的过程是继续恢复现场。</span><br><span class="line"> 87     movq  0x38(%rsp), %r8  /* restore return-address */</span><br><span class="line"> 88 </span><br><span class="line"> 89 #if !defined(BOOST_USE_TSX)</span><br><span class="line"> 90     ldmxcsr  (%rsp)     /* restore MMX control- and status-word */</span><br><span class="line"> 91     fldcw    0x4(%rsp)  /* restore x87 control-word */</span><br><span class="line"> 92 #endif</span><br><span class="line"> 93 </span><br><span class="line"> 94 // 保存和恢复的过程是对称的，正是栈的特点</span><br><span class="line"> 95     movq  0x8(%rsp), %r12  /* restore R12 */</span><br><span class="line"> 96     movq  0x10(%rsp), %r13  /* restore R13 */</span><br><span class="line"> 97     movq  0x18(%rsp), %r14  /* restore R14 */</span><br><span class="line"> 98     movq  0x20(%rsp), %r15  /* restore R15 */</span><br><span class="line"> 99     movq  0x28(%rsp), %rbx  /* restore RBX */</span><br><span class="line">100     movq  0x30(%rsp), %rbp  /* restore RBP */</span><br><span class="line">101 </span><br><span class="line">102 // 恢复另一个任务保存现场之前的rsp(栈顶)</span><br><span class="line">103     leaq  0x40(%rsp), %rsp /* prepare stack */</span><br><span class="line">104 </span><br><span class="line">105 // 这里面有条件编译，似乎是和32位和64位相关，这里按照上面的分支来分析</span><br><span class="line">106     /* return transfer_t from jump */</span><br><span class="line">107 #if !defined(_ILP32)</span><br><span class="line">108     /* RAX == fctx, RDX == data */</span><br><span class="line">109     // rsi是jump_fcontext的第二个参数vp，这里赋值给rdx，rax rdx</span><br><span class="line">110     // 里面存储的是返回值transfer_t的内容，rax是前面我们保存现场</span><br><span class="line">111     // 获得的，也就是说是切换之前的现场，rdx呢，也是切换之前传的，</span><br><span class="line">112     // 也就是说切换之后返回的内容都是切换之前的信息。</span><br><span class="line">113     // 一般网上查到的都是说rax是返回值，但是这里返回结构体，里面</span><br><span class="line">114     // 是两个8字节，到底是怎么传递的很少有地方说，我也是网上查到的</span><br><span class="line">115     // 这种情况是用两个寄存器保存的，rdx也会用来保存返回值，有一个文档可以参考</span><br><span class="line">116     // System V Application Binary Interface AMD64 Architecture Processor Supplement</span><br><span class="line">117     movq  %rsi, %rdx</span><br><span class="line">118 #else</span><br><span class="line">119     /* RAX == data:fctx */</span><br><span class="line">120     salq  $32, %rsi</span><br><span class="line">121     orq   %rsi, %rax</span><br><span class="line">122 #endif</span><br><span class="line">123     /* pass transfer_t as first arg in context function */</span><br><span class="line">124 #if !defined(_ILP32)</span><br><span class="line">125     /* RDI == fctx, RSI == data */</span><br><span class="line">126 #else</span><br><span class="line">127     /* RDI == data:fctx */</span><br><span class="line">128 #endif</span><br><span class="line">129 </span><br><span class="line">130     // rdi是函数调用的第一个参数，rsi是第二个参数</span><br><span class="line">131     // 这里把rax放到rdi中，是为了把切换之前保存的现场作为第一个参数传给要执行的函数</span><br><span class="line">132     // 这是给第一次运行准备的，fn的参数transfer_t的两个成员，一个是rdi，一个是rsi</span><br><span class="line">133     // rsi就是切换之前调用的(即本次调用)那个jump_fcontext传递的第二个参数vp</span><br><span class="line">134     //</span><br><span class="line">135     // 如果不是第一次调用呢，会不会有影响，不会，rdi是caller-saved register，调用者</span><br><span class="line">136     // 负责保存，如果即将切换到的那个任务的对应的函数需要rdi的值，它会自己保存的，</span><br><span class="line">137     // 从jump_fcontext出来之后它会自己恢复，对它来讲就是调用了jump_fcontext这个函数，</span><br><span class="line">138     // 然后过了一段时间返回了，中间的过程完全不知情。 天上走了，又从天上回来。</span><br><span class="line">139     movq  %rax, %rdi</span><br><span class="line">140 </span><br><span class="line">141 //  前面提到了将返回地址放到r8中，现在跳过去开始执行了</span><br><span class="line">142     /* indirect jump to context */</span><br><span class="line">143     jmp  *%r8</span><br><span class="line">144 .size jump_fcontext,.-jump_fcontext</span><br><span class="line">145 </span><br><span class="line">146 /* Mark that we don't need executable stack.  */</span><br><span class="line">147 .section .note.GNU-stack,"",%progbits</span><br></pre></td></tr></tbody></table></figure>


<p>简单测试一下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> 1 #include &lt;stdio.h&gt;</span><br><span class="line"> 2 </span><br><span class="line"> 3 char stack0[10240];//一个printf会占用1千多字节的栈空间!!!!!</span><br><span class="line"> 4 char stack1[10240];</span><br><span class="line"> 5 </span><br><span class="line"> 6 typedef void* fcontext_t;</span><br><span class="line"> 7 typedef struct {</span><br><span class="line"> 8     fcontext_t  fctx;</span><br><span class="line"> 9     void* data;</span><br><span class="line">10 } transfer_t;</span><br><span class="line">11 </span><br><span class="line">12 extern transfer_t jump_fcontext(fcontext_t const to, void * vp);</span><br><span class="line">13 extern fcontext_t make_fcontext(void * sp, size_t size, void (* fn)( transfer_t));</span><br><span class="line">14 </span><br><span class="line">15 fcontext_t fcmain, fc0, fc1;</span><br><span class="line">16 </span><br><span class="line">17 void fn0(transfer_t t){</span><br><span class="line">18     printf("%s %d\n", __func__, __LINE__);</span><br><span class="line">19 </span><br><span class="line">20     fcontext_t *p = t.data;</span><br><span class="line">21     *p = t.fctx;</span><br><span class="line">22 </span><br><span class="line">23     // 切换fn1</span><br><span class="line">24     transfer_t ret = jump_fcontext(fc1, &amp;fc0);</span><br><span class="line">25     p = ret.data;</span><br><span class="line">26     *p = ret.fctx;</span><br><span class="line">27     printf("%s %d\n", __func__, __LINE__);</span><br><span class="line">28     // 切换main</span><br><span class="line">29     jump_fcontext(fcmain, &amp;fc0);</span><br><span class="line">30     printf("never back\n");</span><br><span class="line">31 }</span><br><span class="line">32 </span><br><span class="line">33 void fn1(transfer_t t){</span><br><span class="line">34     printf("%p\n", t.fctx);</span><br><span class="line">35     printf("%s %d\n", __func__, __LINE__);</span><br><span class="line">36     fcontext_t *p = t.data;</span><br><span class="line">37     *p = t.fctx;</span><br><span class="line">38     // 切换fn0</span><br><span class="line">39     jump_fcontext(fc0, &amp;fc1);</span><br><span class="line">40     printf("never back\n");</span><br><span class="line">41 }</span><br><span class="line">42 </span><br><span class="line">43 int main(int argc, char **argv) {</span><br><span class="line">44 </span><br><span class="line">45     fc0 = make_fcontext(stack0 + sizeof stack0, sizeof stack0, fn0);</span><br><span class="line">46     fc1 = make_fcontext(stack1 + sizeof stack1, sizeof stack1, fn1);</span><br><span class="line">47 </span><br><span class="line">48     printf("%s %d\n", __func__, __LINE__);</span><br><span class="line">49     // 切换fn0</span><br><span class="line">50     jump_fcontext(fc0, &amp;fcmain);</span><br><span class="line">51     printf("%s %d\n", __func__, __LINE__);</span><br><span class="line">52 </span><br><span class="line">53     return 0;</span><br><span class="line">54 }</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> % gcc -O t.c asm/make_gas.S asm/jump_gas.S</span><br><span class="line"> % ./a.out</span><br><span class="line">main 48</span><br><span class="line">fn0 18</span><br><span class="line">0x5591d8183800</span><br><span class="line">fn1 35</span><br><span class="line">fn0 27</span><br><span class="line">main 51</span><br></pre></td></tr></tbody></table></figure>

<p>结论：</p>
<p>make_fcontext 中的 sp 是栈顶指针，size 是栈空间的大小，虽然 cpu 可能支持两种方向，但目前我还没有听过栈方向递增的系统，如果是递减栈，应该把栈顶指针设置成最高地址，比如申请了一段内存作为函数栈，大小 1024，地址在 void *p 中，那么应该这样用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">make_fcontext(p+1024, 1024, fn);</span><br></pre></td></tr></tbody></table></figure>

<p>fn 是协程任务启动的时候运行的函数，和线程创建的时候指定的函数类似。make_fcontext 的返回值就是一个运行 (栈空间) 上下文，它将被用于 jump_context 中的 to 参数，这样可以启动这个任务。启动任务之后调用 fn，fn 是 jump_context 中调用的，函数参数传递的实际上是两部分，第一部分，fcontext_t 类型，是栈切换之前的运行上下文，第二个参数是</p>
<p>jump_fcontext 中传递的 vp 参数。jump_fcontext 的返回值也分为两部分，第一部分是栈切换之前的运行上下文，第二部分是传递的参数 vp（<strong>这个 vp 不是本任务 jump_fcontext 调用的 vp</strong>，而是其他任务切换到本任务的时候调用 jump_fcontext 传递的 vp），这是因为 jump_fcontext 不是普通的函数，普通的函数在一个栈空间上执行，而 jump_fcontext 是跨越栈空间的，函数调用前，要保存现场，然后再恢复，jump_fcontext 也要保存现场，但是恢复并不是在这个函数<strong>调用</strong>中恢复的，这个调用已经一去不复返了，只负责跳走，不负责回来，甚至可能永远也回不来了，与其说它回来了，不如说是别的地方跳过来了，jump_fcontext “返回” 的就是跳过来的那个人的信息，它的运行上下文 (保存着它的运行现场，cpu 寄存器，栈空间)，还有它调用 jump_fcontext 跳过来时传递的参数 vp。</p>
<p>一个任务只要执行，它的运行上下文就是在变化的，也就是说只要一个任务一运行，那么保存它的运行上下文的变量 (fcontext_t) 就失效了，也就是每运行一次就要更新一次，什么时候更新呢，就是本次运行暂停的时候更新，也就是调用 jump_fcontext 跳到其他地方的时候，也就是说目标任务要更新本任务的运行上下文变量，目标任务激活的时候表现为从它的 jump_fcontext 返回 (<strong>实际上不是它返回，而是本务跳到那去执行</strong>)，返回值中的 fcontext_t 就是跳之前的运行上下文，也就是本任务的最新的运行上下文，为了更新本任务的运行上下文变量，需要把本任务的运行上下文变量的地址传递给目标任务，这需要借助 jump_fcontext 的 vp 参数，它也会出现在目标任务返回的 transfer_t 中，这就是参数 vp 和返回值 transfer_t 的作用吧，当然借助 vp 还可以传递更多需要交互的信息。</p>
<p>每一个普通任务都是通过 make_fcontext 创造出来的，但主任务 (main 函数) 不是，主任务切换到了其他任务执行，如果想切换回主任务，就必须获取主任务的运行上下文，fn 函数本来只需要自己运行的数据就够了，而它的参数 transfer_t 还带一个 fcontext，就是干这件事用的，它是最新的切换之前的运行上下文，谁启动的它，就更新谁，一个任务切换到一个曾经运行过的任务的时候一定是跳到 jump_fcontext 的下条指令，可以通过” 返回” 的 transfer_t 来实现更新，但是对于新任务，不会从 jump_fcontext 继续执行，不会得到” 返回” 的 transfer_t，就需要利用参数传递的 transfer_t 更新。</p>
<p>主任务启动 -&gt; task0 -&gt; jump_fcontext , task0 恢复执行，这时候返回的 transfer_t 不一定是主任务的运行上下文，因为它是切换 task0 任务，使 task0 再次运行的那个任务的运行上下文，那个任务未必是主任务，主任务只是第一次启动 task0 的时候的任务，并不一定是后续激活 task0 的任务。</p>
<p>如果 fn 函数运行完成，没有通过 jump_fcontext 切换任务，直接返回，那么结果是整个进程都退出了，因为它返回之后是返回到了 make_fcontext 的一段代码中，那段代码的操作是退出进程。从 gdb 里用 bt 可以看到，一个任务的调用者是 make_fcontext，而不是启动它或再次激活它的时候对应的函数，这是因为 make_fcontext 里面设置这个函数的时候同时设置好了它的返回地址，所以如果不想退出进程，一个任务完成的时候需要跳到其他任务，然后释放保存本任务的栈空间资源，需要注意的是释放是要在别的地方释放 (s_task 库中有一个 join 任务的地方)，而不能在跳转之前释放，因为跳转的时候要保存当前运行上下文到当前的栈空间，如果释放了再跳转会造成非法地址的错误。</p>
]]></content>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>boost 协程库 coroutine 介绍</title>
    <url>/posts/e2f31abc.html</url>
    <content><![CDATA[<h2 id="coroutine协程库简介"><a href="#coroutine协程库简介" class="headerlink" title="coroutine协程库简介"></a>coroutine 协程库简介</h2><p>协程有时候被称为轻量级线程，它由程序员进行调度（切换），而不像线程那样需要内核参与，同时也避免内核进行线程切换的开销。因为协程切换保留的是当前上下文环境，也就是函数调用栈和当前的寄存器，而线程切换需要陷入内核态，改变线程对象状态。</p>
<p>go 把协程作为基础设施提供语言级的支持，cpp 没有提供语言级的支持，而是通过准标准库 boost coroutine2 库（boost coroutine 已经废弃，建议使用 boost coroutine2）为 cpp 提供的协程支持。</p>
<p>协程分为对称协程（symmetric）和非对称协程（asymmetric），对称协程需要显式指定将控制权 yeild 给谁，非对称协程可以隐式的转移控制权给它的调用者，boost coroutine2 实现的是非对称协程。</p>
<span id="more"></span>

<h2 id="push-type-和-pull-type"><a href="#push-type-和-pull-type" class="headerlink" title="push_type 和 pull_type"></a>push_type 和 pull_type</h2><p>boost.corountine2 中的协程增加了 push_type 和 pull_type 用于提供协程数据的流转，约束了数据的从 push_type 流入，从 pull_type 流出。</p>
<p>当协程对象被创建之后就直接运行，直到 sink (1) 的时候暂停返回到 main 中，main 中使用 source.get () 获取数据，继续使用 source () 调用协程对象，协程从 sink (1) 之后继续运行执行完毕，返回 main，main 也执行完毕。</p>
<h3 id="pull的例子"><a href="#pull的例子" class="headerlink" title="pull的例子"></a>pull 的例子</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/coroutine2/all.hpp&gt;</span><br><span class="line"></span><br><span class="line">void foo(boost::coroutines2::coroutine&lt;int&gt;::push_type &amp; sink)</span><br><span class="line">{</span><br><span class="line">    std::cout &lt;&lt; "start coroutine\n";</span><br><span class="line">    sink(1);</span><br><span class="line">    std::cout &lt;&lt; "finish coroutine\n";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    boost::coroutines2::coroutine&lt;int&gt;::pull_type source(foo);</span><br><span class="line">    std::cout &lt;&lt; source.get() &lt;&lt; std::endl;</span><br><span class="line">    //std::cout &lt;&lt; source() &lt;&lt; std::endl;</span><br><span class="line">    source();</span><br><span class="line">    std::cout &lt;&lt; "finish\n";</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/boost$ g++ -o demo3 demo3.cpp -lboost_coroutine -lboost_context -L/home/lhx/boost/boost167/install/lib -I/home/lhx/boost/boost167/install/include</span><br><span class="line">lhx@ubuntu:~/boost$ ./demo3 </span><br><span class="line">start coroutine</span><br><span class="line">1</span><br><span class="line">finish coroutine</span><br><span class="line">finish</span><br></pre></td></tr></tbody></table></figure>

<h3 id="push的例子"><a href="#push的例子" class="headerlink" title="push的例子"></a>push 的例子</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/coroutine2/all.hpp&gt;</span><br><span class="line"></span><br><span class="line">void foo(boost::coroutines2::coroutine&lt;int&gt;::pull_type&amp; sink)</span><br><span class="line">{</span><br><span class="line">    std::cout &lt;&lt; "start coroutine\n";</span><br><span class="line">    //sink();</span><br><span class="line">    int a = sink().get();</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; "finish coroutine\n";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    boost::coroutines2::coroutine&lt;int&gt;::push_type source(foo);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; "finish\n";</span><br><span class="line">    source(0);</span><br><span class="line">    source(5);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/boost$ g++ -o demo4 demo4.cpp -lboost_coroutine -lboost_context -L/home/lhx/boost/boost167/install/lib -I/home/lhx/boost/boost167/install/include</span><br><span class="line">lhx@ubuntu:~/boost$ ./demo4 </span><br><span class="line">finish</span><br><span class="line">start coroutine</span><br><span class="line">5</span><br><span class="line">finish coroutine</span><br></pre></td></tr></tbody></table></figure>

<h3 id="其他版本的例子"><a href="#其他版本的例子" class="headerlink" title="其他版本的例子"></a>其他版本的例子</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/coroutine2/all.hpp&gt;</span><br><span class="line"></span><br><span class="line">void foo(boost::coroutines2::coroutine&lt;void&gt;::push_type &amp; sink){</span><br><span class="line">    std::cout &lt;&lt; "a ";</span><br><span class="line">    sink();</span><br><span class="line">    std::cout &lt;&lt; "b ";</span><br><span class="line">    sink();</span><br><span class="line">    std::cout &lt;&lt; "c ";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    boost::coroutines2::coroutine&lt;void&gt;::pull_type source(foo);</span><br><span class="line">    std::cout &lt;&lt; "1 ";</span><br><span class="line">    source();</span><br><span class="line">    std::cout &lt;&lt; "2 ";</span><br><span class="line">    source();</span><br><span class="line">    std::cout &lt;&lt; "3 " &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/boost$ g++ -o demo1 demo1.cpp -lboost_coroutine -lboost_context -L/home/lhx/boost/boost167/install/lib -I/home/lhx/boost/boost167/install/include</span><br><span class="line">lhx@ubuntu:~/boost$ ./demo1</span><br><span class="line">a 1 b 2 c 3</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/coroutine2/all.hpp&gt;</span><br><span class="line"></span><br><span class="line">void foo(boost::coroutines2::coroutine&lt;void&gt;::pull_type &amp; sink1){</span><br><span class="line">    std::cout &lt;&lt; "a ";</span><br><span class="line">    sink1();</span><br><span class="line">    std::cout &lt;&lt; "b ";</span><br><span class="line">    sink1();</span><br><span class="line">    std::cout &lt;&lt; "c ";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">    boost::coroutines2::coroutine&lt;void&gt;::push_type source(foo);</span><br><span class="line">    std::cout &lt;&lt; "1 ";</span><br><span class="line">    source();</span><br><span class="line">    std::cout &lt;&lt; "2 ";</span><br><span class="line">    source();</span><br><span class="line">    std::cout &lt;&lt; "3 " &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/boost$ g++ -o demo2 demo2.cpp -lboost_coroutine -lboost_context -L/home/lhx/boost/boost167/install/lib -I/home/lhx/boost/boost167/install/include</span><br><span class="line">lhx@ubuntu:~/boost$ ./demo2</span><br><span class="line">1 a 2 b 3 </span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>boost 协程接口变化</title>
    <url>/posts/cf8666f9.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>boost-1.61 版本之后协程库 context 的接口改变了，汇编代码里的参数、返回值和语义都发生了改变，另外还增加了新的接口和汇编实现 ontop_fcontext。</p>
<span id="more"></span>

<h2 id="旧版本接口"><a href="#旧版本接口" class="headerlink" title="旧版本接口"></a>旧版本接口</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost {</span><br><span class="line"><span class="keyword">namespace</span> context {</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 执行环境上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">void</span>*   <span class="type">fcontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 初始化执行环境上下文</span></span><br><span class="line"><span class="comment"> * @param sp 栈空间地址</span></span><br><span class="line"><span class="comment"> * @param size 栈空间的大小</span></span><br><span class="line"><span class="comment"> * @param fn 入口函数</span></span><br><span class="line"><span class="comment"> * @return 返回初始化完成后的执行环境上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOST_CONTEXT_DECL</span></span><br><span class="line"><span class="function"> <span class="type">fcontext_t</span> BOOST_CONTEXT_CALLDECL <span class="title">make_fcontext</span><span class="params">( <span class="type">void</span> * sp, std::<span class="type">size_t</span> size, <span class="type">void</span> (* fn)( <span class="type">intptr_t</span>) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 跳转到目标上下文</span></span><br><span class="line"><span class="comment"> * @param ofc 当前的上下文会保存到ofc中</span></span><br><span class="line"><span class="comment"> * @param nfc 跳转到的目标上下文</span></span><br><span class="line"><span class="comment"> * @param vp 如果是第一次跳转，作为函数参数传入，如果是调回到jump_fcontext，这个是返回值</span></span><br><span class="line"><span class="comment"> * @param preserve_fpu 是否复制FPU（浮点数寄存器）数据</span></span><br><span class="line"><span class="comment"> * @return 如果调回时的透传参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOST_CONTEXT_DECL</span></span><br><span class="line"><span class="function">    <span class="type">intptr_t</span> BOOST_CONTEXT_CALLDECL <span class="title">jump_fcontext</span><span class="params">( <span class="type">fcontext_t</span> * ofc, <span class="type">fcontext_t</span> nfc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">intptr_t</span> vp, <span class="type">bool</span> preserve_fpu = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">}}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="新版本接口"><a href="#新版本接口" class="headerlink" title="新版本接口"></a>新版本接口</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost {</span><br><span class="line"><span class="keyword">namespace</span> context {</span><br><span class="line"><span class="keyword">namespace</span> detail {</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 执行环境上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>*   <span class="type">fcontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 事件参数包装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">transfer_t</span> {</span><br><span class="line">    <span class="type">fcontext_t</span>  fctx; <span class="comment">/** 相关的的执行环境上下文-不同的API里含义不一样 **/</span></span><br><span class="line">    <span class="type">void</span>    *   data; <span class="comment">/** 自定义数据 **/</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 初始化执行环境上下文</span></span><br><span class="line"><span class="comment"> * @param sp 栈空间地址</span></span><br><span class="line"><span class="comment"> * @param size 栈空间的大小</span></span><br><span class="line"><span class="comment"> * @param fn 入口函数</span></span><br><span class="line"><span class="comment"> * @return 返回初始化完成后的执行环境上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOST_CONTEXT_DECL</span></span><br><span class="line"><span class="function"><span class="type">fcontext_t</span> BOOST_CONTEXT_CALLDECL <span class="title">make_fcontext</span><span class="params">( <span class="type">void</span> * sp, std::<span class="type">size_t</span> size, <span class="type">void</span> (* fn)( <span class="type">transfer_t</span>) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 跳转到目标上下文</span></span><br><span class="line"><span class="comment"> * @param to 当前的上下文会保存到ofc中</span></span><br><span class="line"><span class="comment"> * @param vp 跳转到的目标上下文的附加参数，会设置为transfer_t里的data成员</span></span><br><span class="line"><span class="comment"> * @return 跳转来源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOST_CONTEXT_DECL</span></span><br><span class="line"><span class="function"><span class="type">transfer_t</span> BOOST_CONTEXT_CALLDECL <span class="title">jump_fcontext</span><span class="params">( <span class="type">fcontext_t</span> <span class="type">const</span> to, <span class="type">void</span> * vp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @biref 顶层跳转</span></span><br><span class="line"><span class="comment"> * @param to 当前的上下文会保存到ofc中</span></span><br><span class="line"><span class="comment"> * @param vp 跳转到的目标上下文的附加参数，会设置为transfer_t里的data成员</span></span><br><span class="line"><span class="comment"> * @param fn 入口函数，参数是跳转来源</span></span><br><span class="line"><span class="comment"> * @return 跳转来源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// based on an idea of Giovanni Derreta</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">BOOST_CONTEXT_DECL</span></span><br><span class="line"><span class="function"><span class="type">transfer_t</span> BOOST_CONTEXT_CALLDECL <span class="title">ontop_fcontext</span><span class="params">( <span class="type">fcontext_t</span> <span class="type">const</span> to, <span class="type">void</span> * vp, <span class="type">transfer_t</span> (* fn)( <span class="type">transfer_t</span>) )</span></span>;</span><br><span class="line"></span><br><span class="line">}}}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="修改总结"><a href="#修改总结" class="headerlink" title="修改总结"></a>修改总结</h2><p>命名空间从 boost 变成了 boost::detail</p>
<p>首先重要的是多一个 transfer_t，这个里面的有两个对象，第一个 fctx 是来源的执行上下文，第二个 data 是各种接口传入的自定义的指针 (上面接口里的 vp)。 来源的上下文指的是从什么位置跳转过来的。无论在回调参数还是各项返回值中都是这个含义。</p>
<p>对于 make_fcontext 这个接口，原先的入口函数是 void (* fn)( intptr_t)，参数是透传自定义指针。现在是 void (* fn)( transfer_t)，里面包含了来源执行栈的上下文和透传的自定义指针。</p>
<p>对于 jump_fcontext 这个接口，原先需要传入把当前执行上下文保存到哪里，跳转目标的新的上下文，自定义数据和是否复制 FPU。 现在的版本不再需要指定是否需要复制 FPU 了，同时也去除了自动保存当前上下文的功能，并且改成了跳到新的上下文后，新的上下文可以知道自己是从哪跳转过来的。</p>
<p>另外，这次的 boost.context 新增了一个比较有意思的接口，transfer_t ontop_fcontext (fcontext_t const to, void * vp, transfer_t ( fn)( transfer_t) )。 这个接口的功能是在跳转目标 (to 指向的上下文) 上模拟函数调用，并且返回值作为 jump_fcontext * 的返回值，相当于可以给执行上下文接口打 hook。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1. 当前处于执行上下文-fctx1</span></span><br><span class="line"><span class="type">transfer_t</span> jump_res = <span class="built_in">jump_fcontext</span>(fctx2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Step 2. 当前处于执行上下文-fctx2</span></span><br><span class="line"><span class="comment">// 跳入ontop_callback函数</span></span><br><span class="line"><span class="built_in">ontop_fcontext</span>(fctx1, <span class="number">0x01</span>, ontop_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">transfer_t</span> <span class="title">ontop_callback</span><span class="params">( <span class="type">transfer_t</span> from)</span> </span>{</span><br><span class="line">    <span class="comment">// 这时候 from.fctx == fctx2, from.data == 0x01</span></span><br><span class="line">    <span class="comment">// Step 3. 可以改变这些数据</span></span><br><span class="line">    from.data = <span class="number">0x02</span>;</span><br><span class="line">    <span class="keyword">return</span> from;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候返回Step 1的</span></span><br><span class="line"><span class="type">transfer_t</span> jump_res = <span class="built_in">jump_fcontext</span>(fctx2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// Step 4. 这时候，jump_res.fctx == fctx2, from.data == 0x02</span></span><br><span class="line"><span class="comment">// continue other ...</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>brpc 中 bthread 协程切换测试用例</title>
    <url>/posts/f7a57140.html</url>
    <content><![CDATA[<p>bthread 中借用 boost 实现协程间的切换，下面的 x86_64 测试用例简单的将嵌汇编和 C++ 代码融合到了一起，测试下协程切换栈的过程。aarch64 测试用例只需要把嵌汇编代码换了就行，都是原封不动的抄的 boost 里协程实现的 make_fcontext 和 jump_fcontext 两个 S 文件。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *<span class="type">bthread_fcontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="type">bthread_fcontext_t</span> <span class="title">bthread_make_fcontext</span><span class="params">(<span class="type">void</span> *sp, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">void</span> (*fn)(<span class="type">intptr_t</span>))</span></span>;</span><br><span class="line">__asm(</span><br><span class="line">    <span class="string">".text\n"</span></span><br><span class="line">    <span class="string">".globl bthread_make_fcontext\n"</span></span><br><span class="line">    <span class="string">".type bthread_make_fcontext,@function\n"</span></span><br><span class="line">    <span class="string">".align 16\n"</span></span><br><span class="line">    <span class="string">"bthread_make_fcontext:\n"</span></span><br><span class="line">    <span class="string">"    movq  %rdi, %rax\n"</span></span><br><span class="line">    <span class="string">"    andq  $-16, %rax\n"</span></span><br><span class="line">    <span class="string">"    leaq  -0x48(%rax), %rax\n"</span></span><br><span class="line">    <span class="string">"    movq  %rdx, 0x38(%rax)\n"</span></span><br><span class="line">    <span class="string">"    stmxcsr  (%rax)\n"</span></span><br><span class="line">    <span class="string">"    fnstcw   0x4(%rax)\n"</span></span><br><span class="line">    <span class="string">"    leaq  finish(%rip), %rcx\n"</span></span><br><span class="line">    <span class="string">"    movq  %rcx, 0x40(%rax)\n"</span></span><br><span class="line">    <span class="string">"    ret \n"</span></span><br><span class="line">    <span class="string">"finish:\n"</span></span><br><span class="line">    <span class="string">"    xorq  %rdi, %rdi\n"</span></span><br><span class="line">    <span class="string">"    call  _exit@PLT\n"</span></span><br><span class="line">    <span class="string">"    hlt\n"</span></span><br><span class="line">    <span class="string">".size bthread_make_fcontext,.-bthread_make_fcontext\n"</span></span><br><span class="line">    <span class="string">".section .note.GNU-stack,\"\",%progbits\n"</span></span><br><span class="line">    <span class="string">".previous\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="type">intptr_t</span> <span class="title">bthread_jump_fcontext</span><span class="params">(<span class="type">bthread_fcontext_t</span> *ofc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">bthread_fcontext_t</span> nfc, <span class="type">intptr_t</span> vp)</span></span>;</span><br><span class="line">__asm(</span><br><span class="line">    <span class="string">".text\n"</span></span><br><span class="line">    <span class="string">".globl bthread_jump_fcontext\n"</span></span><br><span class="line">    <span class="string">".type bthread_jump_fcontext,@function\n"</span></span><br><span class="line">    <span class="string">".align 16\n"</span></span><br><span class="line">    <span class="string">"bthread_jump_fcontext:\n"</span></span><br><span class="line">    <span class="string">"    pushq  %rbp  \n"</span></span><br><span class="line">    <span class="string">"    pushq  %rbx  \n"</span></span><br><span class="line">    <span class="string">"    pushq  %r15  \n"</span></span><br><span class="line">    <span class="string">"    pushq  %r14  \n"</span></span><br><span class="line">    <span class="string">"    pushq  %r13  \n"</span></span><br><span class="line">    <span class="string">"    pushq  %r12  \n"</span></span><br><span class="line">    <span class="string">"    leaq  -0x8(%rsp), %rsp\n"</span></span><br><span class="line">    <span class="string">"    movq  %rsp, (%rdi)\n"</span></span><br><span class="line">    <span class="string">"    movq  %rsi, %rsp\n"</span></span><br><span class="line">    <span class="string">"    leaq  0x8(%rsp), %rsp\n"</span></span><br><span class="line">    <span class="string">"    popq  %r12  \n"</span></span><br><span class="line">    <span class="string">"    popq  %r13  \n"</span></span><br><span class="line">    <span class="string">"    popq  %r14  \n"</span></span><br><span class="line">    <span class="string">"    popq  %r15  \n"</span></span><br><span class="line">    <span class="string">"    popq  %rbx  \n"</span></span><br><span class="line">    <span class="string">"    popq  %rbp  \n"</span></span><br><span class="line">    <span class="string">"    popq  %r8\n"</span></span><br><span class="line">    <span class="string">"    movq  %rdx, %rax\n"</span></span><br><span class="line">    <span class="string">"    movq  %rdx, %rdi\n"</span></span><br><span class="line">    <span class="string">"    jmp  *%r8\n"</span></span><br><span class="line">    <span class="string">".size bthread_jump_fcontext,.-bthread_jump_fcontext\n"</span></span><br><span class="line">    <span class="string">".section .note.GNU-stack,\"\",%progbits\n"</span></span><br><span class="line">    <span class="string">".previous\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bthread_fcontext_t</span> fcm;</span><br><span class="line"><span class="type">bthread_fcontext_t</span> fc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="type">pair_t</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">intptr_t</span> param)</span> </span>{</span><br><span class="line">  <span class="type">pair_t</span> *p = (<span class="type">pair_t</span> *)param;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"In Routine: fcm %p fc %p\n"</span>, fcm, fc);</span><br><span class="line"></span><br><span class="line">  p = (<span class="type">pair_t</span> *)<span class="built_in">bthread_jump_fcontext</span>(&amp;fc, fcm,</span><br><span class="line">                                      (<span class="type">intptr_t</span>)(p-&gt;first + p-&gt;second));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"In Routine Again: fcm %p fc %p\n"</span>, fcm, fc);</span><br><span class="line">  <span class="built_in">bthread_jump_fcontext</span>(&amp;fc, fcm, (<span class="type">intptr_t</span>)(p-&gt;first + p-&gt;second));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  fcm = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">(<span class="number">8192</span>)</span></span>;</span><br><span class="line">  <span class="type">void</span> *sp = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">pair_t</span> <span class="title">p</span><span class="params">(std::make_pair(<span class="number">2</span>, <span class="number">7</span>))</span></span>;</span><br><span class="line">  fc = <span class="built_in">bthread_make_fcontext</span>((<span class="type">char</span> *)sp + size, size, f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Start Routine: fcm %p fc %p\n"</span>, fcm, fc);</span><br><span class="line">  <span class="type">int</span> res = (<span class="type">int</span>)<span class="built_in">bthread_jump_fcontext</span>(&amp;fcm, fc, (<span class="type">intptr_t</span>)&amp;p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Back to Main: %d + %d = %d\n"</span>, p.first, p.second, res);</span><br><span class="line"></span><br><span class="line">  p = std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Resume Routine: fcm %p fc %p\n"</span>, fcm, fc);</span><br><span class="line">  res = (<span class="type">int</span>)<span class="built_in">bthread_jump_fcontext</span>(&amp;fcm, fc, (<span class="type">intptr_t</span>)&amp;p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Back to Main Again: %d + %d = %d\n"</span>, p.first, p.second, res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test$ g++ -g brpc_bthread_test.cpp </span><br><span class="line">lhx@ubuntu:~/test$ ./a.out </span><br><span class="line">Start Routine: fcm (nil) fc 0x5654fcb19e68</span><br><span class="line">In Routine: fcm 0x7ffe13ee5570 fc 0x5654fcb19e68</span><br><span class="line">Back to Main: 2 + 7 = 9</span><br><span class="line">Resume Routine: fcm 0x7ffe13ee5570 fc 0x5654fcb19e40</span><br><span class="line">In Routine Again: fcm 0x7ffe13ee5570 fc 0x5654fcb19e40</span><br><span class="line">Back to Main Again: 5 + 6 = 11</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>brpc 中 bthread 源码分析</title>
    <url>/posts/bbe5e1c1.html</url>
    <content><![CDATA[<p>brpc 引入 m:n 的线程模型，固定的内核线程调度运行大量的 bthread 以避免内核线程上下文切换带来的开销。bthread 类似协程，即用户态线程，bthread 的切换不会陷入内核，不会进行一系列内存同步等耗时操作，因此 bthread 的切换在 100-200ns，相比内核线程的微秒级别有着数量级的提升。</p>
<span id="more"></span>

<h2 id="brpc的精华全在bthread"><a href="#brpc的精华全在bthread" class="headerlink" title="brpc的精华全在bthread"></a>brpc 的精华全在 bthread</h2><p>有人说 brpc 的精华全在 bthread 上了，bthread 可以理解为 “协程”。pthread 大家都不陌生，是 POSIX 标准中定义的一套线程模型。在 Linux 系统上，其实没有真正的线程，其采用的是 LWP（轻量级进程）实现的线程。而 bthread 是 brpc 实现的一套 “协程”，当然这并不是传统意义上的协程。就像 1 个进程可以开辟 N 个线程一样。传统意义上的协程是一个线程中开辟多个协程，也就是通常意义的 N:1 协程。而 bthread 是 M:N 的 “协程”，每个 bthread 之间的平等的，所谓的 M:N 是指协程可以在线程间迁移。Go 语言的 goroutine 也是 M:N 的。</p>
<p><code>incubator-brpc/src/bthread/stack_inl.h</code>:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jump_stack</span><span class="params">(ContextualStack* from, ContextualStack* to)</span> </span>{</span><br><span class="line">    <span class="built_in">bthread_jump_fcontext</span>(&amp;from-&gt;context, to-&gt;context, <span class="number">0</span><span class="comment">/*not skip remained*/</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>incubator-brpc/src/bthread/context.h</code>:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">bthread_fcontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">intptr_t</span> BTHREAD_CONTEXT_CALL_CONVENTION</span></span><br><span class="line"><span class="function"><span class="title">bthread_jump_fcontext</span><span class="params">(<span class="type">bthread_fcontext_t</span> * ofc, <span class="type">bthread_fcontext_t</span> nfc,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">intptr_t</span> vp, <span class="type">bool</span> preserve_fpu = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bthread_fcontext_t</span> BTHREAD_CONTEXT_CALL_CONVENTION</span></span><br><span class="line"><span class="function"><span class="title">bthread_make_fcontext</span><span class="params">(<span class="type">void</span>* sp, <span class="type">size_t</span> size, <span class="type">void</span> (* fn)( <span class="type">intptr_t</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>bthread_jump_fcontext () 其实是汇编函数，在 bthread/context.cpp 中，功能就是进行栈上下文的切换（跳转）。与之配套的还有一个 bthread_make_fcontext ()，负责创建 bthread 的栈上下文。这两个函数是实现栈上下文切换的核心。它们的代码其实并非 brpc 的原创，而是出自开源项目 <a href="https://github.com/twlostow/libcontext">libcontext</a>。libcontext 是 boost::context 的简化实现。libcontext - a slightly more portable version of boost::context。</p>
<p>首先看下协程栈的结构，如下，context 指向协程栈顶，stacktype 表示栈的类型 (大小)，storage 为栈空间。<br>栈分配时会通过 mmap 匿名映射一段空间，然后将高地址位赋值给 bottom。</p>
<p><code>incubator-brpc/src/bthread/stack.h</code>:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContextualStack</span> {</span><br><span class="line">    <span class="type">bthread_fcontext_t</span> context;</span><br><span class="line">    StackType stacktype;</span><br><span class="line">    StackStorage storage;</span><br><span class="line">};</span><br><span class="line">……</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackStorage</span> {</span><br><span class="line">     <span class="type">int</span> stacksize;</span><br><span class="line">     <span class="type">int</span> guardsize;</span><br><span class="line">    <span class="type">void</span>* bottom;</span><br><span class="line">    <span class="type">unsigned</span> valgrind_stack_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clears all members.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zeroize</span><span class="params">()</span> </span>{</span><br><span class="line">        stacksize = <span class="number">0</span>;</span><br><span class="line">        guardsize = <span class="number">0</span>;</span><br><span class="line">        bottom = <span class="literal">NULL</span>;</span><br><span class="line">        valgrind_stack_id = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">……</span><br><span class="line"><span class="comment">// Jump from stack `from' to stack `to'. `from' must be the stack of callsite</span></span><br><span class="line"><span class="comment">// (to save contexts before jumping)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jump_stack</span><span class="params">(ContextualStack* from, ContextualStack* to)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>接着看下创建一个 bthread 的过程，函数入参分别为协程栈底，栈大小，以及这个 bthread 要执行的函数，返回值，即 context 为协程栈顶，具体看如下代码。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">context = <span class="built_in">bthread_make_fcontext</span>(storage.bottom, storage.stacksize, entry);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BTHREAD_CONTEXT_PLATFORM_linux_x86_64) &amp;&amp; defined(BTHREAD_CONTEXT_COMPILER_gcc)</span></span><br><span class="line">__asm (</span><br><span class="line"><span class="string">".text\n"</span></span><br><span class="line"><span class="string">".globl bthread_make_fcontext\n"</span></span><br><span class="line"><span class="string">".type bthread_make_fcontext,@function\n"</span></span><br><span class="line"><span class="string">".align 16\n"</span></span><br><span class="line"><span class="string">"bthread_make_fcontext:\n"</span></span><br><span class="line"><span class="string">"    movq  %rdi, %rax\n"</span></span><br><span class="line"><span class="string">"    andq  $-16, %rax\n"</span></span><br><span class="line"><span class="string">"    leaq  -0x48(%rax), %rax\n"</span></span><br><span class="line"><span class="string">"    movq  %rdx, 0x38(%rax)\n"</span></span><br><span class="line"><span class="string">"    stmxcsr  (%rax)\n"</span></span><br><span class="line"><span class="string">"    fnstcw   0x4(%rax)\n"</span></span><br><span class="line"><span class="string">"    leaq  finish(%rip), %rcx\n"</span></span><br><span class="line"><span class="string">"    movq  %rcx, 0x40(%rax)\n"</span></span><br><span class="line"><span class="string">"    ret \n"</span></span><br><span class="line"><span class="string">"finish:\n"</span></span><br><span class="line"><span class="string">"    xorq  %rdi, %rdi\n"</span></span><br><span class="line"><span class="string">"    call  _exit@PLT\n"</span></span><br><span class="line"><span class="string">"    hlt\n"</span></span><br><span class="line"><span class="string">".size bthread_make_fcontext,.-bthread_make_fcontext\n"</span></span><br><span class="line"><span class="string">".section .note.GNU-stack,\"\",%progbits\n"</span></span><br><span class="line"><span class="string">".previous\n"</span></span><br><span class="line">);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>将 rdi 赋值给 rax，rdi 保存的是第一个参数，即 stack 的 bottom</li>
<li> 对 rax 进行 16 字节对齐</li>
<li>将 rax 下移 72 字节</li>
<li>将 rdx 保存至 rax + 56，rdx 为第三个参数，即函数 fn 的地址</li>
<li>保存 MXCSR 寄存器 (sse 浮点数运算状态寄存器，32 位) 到 rax 所在位置</li>
<li>将 FPU 控制字的当前值存储到 rax + 4</li>
<li> 计算 finish 的绝对地址，保存到 rcx 中</li>
<li>将 rcx 保存到 rax + 64</li>
<li> 函数退出</li>
<li> rax 保存的是栈顶，因此 context 现在指向协程栈的栈顶</li>
</ul>
<p>这一过程如下图所示：上面为高地址，下面为低地址；左侧为调用此函数的 bthread/pthread 栈，右侧为执行完成后，新 bthread 栈空间结构，大框表示 64 位，小框表示 32 位，这里关于各个寄存器在栈中保存的位置是为了和协程切换函数里保持一致，具体下面会提到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212222333311.png" alt="img"></p>
<p>接下来看下协程的切换过程，首先看下代码，ofc 为旧协程的栈顶，nfc 为新协程的栈顶。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">inline void jump_stack(ContextualStack* from, ContextualStack* to) {</span><br><span class="line">    bthread_jump_fcontext(&amp;from-&gt;context, to-&gt;context, 0/*not skip remained*/);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#if defined(BTHREAD_CONTEXT_PLATFORM_linux_x86_64) &amp;&amp; defined(BTHREAD_CONTEXT_COMPILER_gcc)</span><br><span class="line">__asm (</span><br><span class="line">".text\n"</span><br><span class="line">".globl bthread_jump_fcontext\n"</span><br><span class="line">".type bthread_jump_fcontext,@function\n"</span><br><span class="line">".align 16\n"</span><br><span class="line">"bthread_jump_fcontext:\n"</span><br><span class="line">"    pushq  %rbp  \n"</span><br><span class="line">"    pushq  %rbx  \n"</span><br><span class="line">"    pushq  %r15  \n"</span><br><span class="line">"    pushq  %r14  \n"</span><br><span class="line">"    pushq  %r13  \n"</span><br><span class="line">"    pushq  %r12  \n"</span><br><span class="line">"    leaq  -0x8(%rsp), %rsp\n"</span><br><span class="line">"    cmp  $0, %rcx\n"</span><br><span class="line">"    je  1f\n"</span><br><span class="line">"    stmxcsr  (%rsp)\n"</span><br><span class="line">"    fnstcw   0x4(%rsp)\n"</span><br><span class="line">"1:\n"</span><br><span class="line">"    movq  %rsp, (%rdi)\n"</span><br><span class="line">"    movq  %rsi, %rsp\n"</span><br><span class="line">"    cmp  $0, %rcx\n"</span><br><span class="line">"    je  2f\n"</span><br><span class="line">"    ldmxcsr  (%rsp)\n"</span><br><span class="line">"    fldcw  0x4(%rsp)\n"</span><br><span class="line">"2:\n"</span><br><span class="line">"    leaq  0x8(%rsp), %rsp\n"</span><br><span class="line">"    popq  %r12  \n"</span><br><span class="line">"    popq  %r13  \n"</span><br><span class="line">"    popq  %r14  \n"</span><br><span class="line">"    popq  %r15  \n"</span><br><span class="line">"    popq  %rbx  \n"</span><br><span class="line">"    popq  %rbp  \n"</span><br><span class="line">"    popq  %r8\n"</span><br><span class="line">"    movq  %rdx, %rax\n"</span><br><span class="line">"    movq  %rdx, %rdi\n"</span><br><span class="line">"    jmp  *%r8\n"</span><br><span class="line">".size bthread_jump_fcontext,.-bthread_jump_fcontext\n"</span><br><span class="line">".section .note.GNU-stack,\"\",%progbits\n"</span><br><span class="line">".previous\n"</span><br><span class="line">);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>先将对应寄存器 push 到旧的协程栈中<br>将 rsp 下移 8 字节<br>比较 rcx 和 0，因为 rcx 为 0，所以 zf 为 1<br>因为 zf 为 1，所以跳转<br>将 rsp 保存至 rdi 中，rsp 指向当前协程栈栈顶，rdi 为第一个入参，即 ofc<br>将 rsi 保存到 rsp 中，rsi 为第二个参数，即 nfc，此时栈顶指针 rsp 指向了新的协程栈<br>将 rsp 上移 8 字节<br>将协程栈中 r12-rbp 依次 pop 到对应寄存器<br>将 rdx 保存到 rax，rdx 为第三个参数，rax 为返回值<br>将 rdx 保存到 rdi，rdi 为第一个入参，因此将作为新协程运行的入参<br>跳转到 r8 对应的寄存器运行。<br>在协程切换过程中有两种情况，第一种为新协程是通过 bthread_make_fcontext 函数刚刚创建的栈，另一种是已经运行过的栈，这两种过程分别如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212222338350.png" alt="img"></p>
<p>上图表示切换到新协程的过程，因为 pop 到 r8 的是 fn，所以接下来会运行创建协程时的函数 fn，当协程运行结束后 ret 时会 pop rip，此时便会执行 finish。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2022/202212222338002.png" alt="img"></p>
<p>上图表示切换到已经运行一段时间的协程的过程，因为右侧协程在上一次被切换的时候会将下一条指令地址 push 到栈中，然后在这次切换过程中被 pop 到 r8，因此便会继续执行上次被切换后的代码。</p>
]]></content>
      <tags>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux 平台高级调试和优化（杭州站）》培训笔记</title>
    <url>/posts/7247b32f.html</url>
    <content><![CDATA[<h3 id="第一天上午：大局观和-linux内核源码"><a href="#第一天上午：大局观和-linux内核源码" class="headerlink" title="第一天上午：大局观和 linux内核源码"></a>第一天上午：大局观和 linux 内核源码</h3><p><strong>内核版本介绍</strong></p>
<p>linux4.19 LTS 版本使用率比较高，发的 GDK8 的盒子就是该版本。linux6.1 LTS 版本将会是下一代主流版本，预测生命力至少 5-10 年。</p>
<p>在网站 <a href="https://kernel.org/%E9%87%8C%E8%83%BD%E7%9C%8B%E5%88%B0%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%88%86%E6%94%AF%EF%BC%8Cmainline%E4%B8%BB%E7%BA%BF%E5%88%86%E6%94%AF%E7%94%B1Linus">https://kernel.org/ 里能看到内核版本分支，mainline 主线分支由 Linus</a> Torvalds 维护，stable 稳定分支由 Greg Kroah-Hartman 维护。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304250909830.png" alt="image-20230425090920744"></p>
<blockquote>
<p>开发者不太愿意紧跟 Linux 内核版本更新，因为一旦升级内核，便涉及到驱动之类的代码需要修改，产生很多编译错误。虽然对于有经验的程序员来说，比较容易排错，但这里面的工作量也很巨大。一直使用旧版本也有缺点，比如有些新特性无法使用，即使将新特性代码 patch 到旧版本，仍不能很好使用。</p>
</blockquote>
<p><strong>内核源码重点关注的三部分</strong></p>
<ul>
<li><p>内核三大块：驱动（driver）、架构（arch）、纯软件（kernel）。</p>
</li>
<li><p>三大目录<br>drivers：驱动，外设目录，硬件厂商维护<br>arch：各架构实现代码，arch 下也有 kernel 目录但主要实现架构相关的汇编代码，和一级目录 kernel 有区别的。<br>kernel：通用的代码和处理。</p>
</li>
</ul>
<p>tools 目录里，有些工具是运行在用户空间，像 perf 在 kernel 里有基础支持，在 tools 里面有用户态的代码供编译。</p>
<p>ebpf：动态修补 Linux 的机制，一种新技术，老版本内核可能不兼容。挂钩子函数，高性能，可以篡改内核代码。也有不好的影响如钩子太多的话也会影响内核性能。</p>
<p><strong>GUN 和 Linux</strong></p>
<ul>
<li><p>GNU：也可以认为是操作系统，发起者 stallman 秉持从上到下，从应用环境开始着手，想创造一套操作系统。比如 GCC、GDB 都是他发起的。</p>
</li>
<li><p>Linux：发起者 Linus 与 stallman 思路相反，从下到上开始，从硬件和内核开始研发。</p>
</li>
</ul>
<p>最终两者结合起来，诞生了当前的 GNU/Linux 操作系统，这是标准叫法，但后来常被简称为 Linux。</p>
<blockquote>
<p> 空降兵思路：作为一个空降兵，快速到现场作战，针对问题提出不同解决方案。</p>
</blockquote>
<p>要想性能快，少和外设打交道，不然速度会变慢，要 IO。</p>
<p><strong>dpdk 库</strong>：非常规思路，避免系统调用的开销，把所有操作都弄到用户空间，所以性能比较快，实现用户态加速。贵的网卡就这样做，很快访问，但缺点是不能通用。主要是网络服务，收发包不用切到内核。</p>
<h3 id="第一天下午：两大空间和调试内核代码"><a href="#第一天下午：两大空间和调试内核代码" class="headerlink" title="第一天下午：两大空间和调试内核代码"></a>第一天下午：两大空间和调试内核代码</h3><p>在硬件调试方面，有 jtag 和 coresight（arm 提出来的，硬件调试更方便，相比 Intel 性价比更高）两种技术。</p>
<p>x86 架构 32 位 8 个，64 位 16 个寄存器。寄存器太少，编译器代码不好写。寄存器太多，线程切换开销大。</p>
<p><strong>Windows 上调试命令：</strong></p>
<ul>
<li>r：查看寄存器</li>
<li> u：查看汇编</li>
<li>.sympath：符号表位置</li>
<li>.reload：重载符号表</li>
<li> lm：展示 module</li>
</ul>
<p>openOCD 对接 gdb 或者 dbgengine，risc-v 用的比较多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304261621521.png" alt="coresight"></p>
<p>arm 拥有非常多的系统寄存器，对于嵌入式和驱动开发，需要关注某些系统寄存器。然后 gdb 不能查看 arm 系统寄存器，windbg 可以。</p>
<p>写程序优化思想，尽量在栈上定义变量，不要用全局变量，多用局部变量。局部相关性原理，数据操作在一小段地址范围，可以直接被 cache 装载，这样速度提高很大。避免大范围地址空间跳动，触发 page fault。</p>
<p>局部变量不初始化，也是有好处，并不要刻板的编程规范，内核代码有很多这种示例。可以 strace 看个简单的程序，发现很多都是 mmap 和 memset 之类的内存操作，有些情况下变量没必要提前赋值初始化。</p>
<p><strong>GDB 使用方法</strong></p>
<p>GDB 调试应用程序比较给力，调试内核代码不太好用。</p>
<p>查看 build-id 符号信息（.note.gnu.build）：<code>readelf --notes /bin/ls</code></p>
<p><code>info symbol 0xaaaa</code>：查看地址的符号名</p>
<p><code>run / -R</code>：调试的程序若为 ls，表示传参 ls -R</p>
<p>汇编里的 <code>mmap@plt</code> 含义：编译时先指定，运行时根据 plt 调整位置，运行时链接。</p>
<p><code>ldd -v /bin/ls</code>：显示详细的动态库信息。</p>
<p><code>__brk</code>：相当于去内核批发内存，和 mmap 有些类似。</p>
<p><strong>调试信息</strong>：微软符号格式是 pdb，开放的是 dwarf 符号，<code>!readelf --debug-dump ./labs/gemalloc/gemalloc</code></p>
<p>介绍一种 Linux 图形化 gdb 调试方法：用微软 vs 调试 Linux 程序，可以使用 VS 界面的丰富调试功能，也可以跨架构和交叉调试。</p>
<p>vs 调试应用比较好，windbg 调试内核或驱动比较好，需要针对不同场景进行选择。</p>
<p><strong>当前仍存在的技术缺陷：</strong>调试器都是基于 CPU 调试，无法调 GPU。GPU 如果访问了某个内存，目前没办法找。像 DMA 和 cache 相关问题，无奈只能上仿真器解决。</p>
<p>handle signal pass：收到 signal 传递给用户程序，不让 gdb 接收。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) handle SIGINT pass </span><br><span class="line">SIGINT is used by the debugger.</span><br><span class="line">Are you sure you want to change it? (y or n) y</span><br><span class="line">Signal        Stop	Print	Pass to program	Description</span><br><span class="line">SIGINT        Yes	Yes	Yes		Interrupt</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program terminated with signal SIGINT, Interrupt.</span><br><span class="line">The program no longer exists.</span><br></pre></td></tr></tbody></table></figure>

<p>gdb+qemu：不能调试硬件、wifi 或 GPU 驱动之类的，只能简单看内核。</p>
<h3 id="第二天：内存管理"><a href="#第二天：内存管理" class="headerlink" title="第二天：内存管理"></a>第二天：内存管理</h3><p><strong>各级 cache 速度差：</strong>L1：纳秒；L2：十几纳秒；L3：数十纳秒，L3 如果 miss，则可能几百纳秒或毫秒级别。</p>
<p><strong>编写程序时优化思路：</strong>写程序充分利用程序局部性原理，将常用的变量 / 数据结构之类的写到一起，访问更快。程序规划好执行热路径和冷路径，比如异常处理函数写到最后。</p>
<p><strong>微软优化思路：</strong>将反汇编的热指令和冷指令位置调整，利用 PGO 技术，将程序跑一边，通过插桩分析冷热代码，然后编译器重新编译，将热代码上移，将冷代码下移。</p>
<blockquote>
<p>PGO (Profile-guided optimization) 是一种编译优化技术，原理是编译器使用程序的运行时 profiling 信息，生成更高质量的代码，从而提高程序的性能。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304230949796.png" alt="image-20230423094939697"></p>
<p>内核里有支持，将热代码标记为 likely。分支预测，优先预测附近，分支预测失败就会污染 cache。</p>
<p><strong>内存分配过程：</strong>mmalloc 先分配虚地址，调用 mmset 后初始化，pagefault 后不断挂页，然后就比较慢。不做 memset 就相当于挂一个虚的页表。</p>
<p>time ./a.out：简单看一下时间，不太准确，有波动。</p>
<p>堆内存分配大的话，直接去内核，堆管理器只零售小内存。</p>
<p>循环展开的情况：固定循环变量为 3，则复制 3 份代码顺序执行。有时跟编译器优化有关，可能看不到。</p>
<p><code>perf record -e page-faults ./a.out</code>：通过捕获 pagefault 事件来分析内存分配情况。</p>
<p>看栈的大小：<code>ulimit -s 8192</code></p>
<p><code>cond 2 $_thread!=1</code>：条件断点，线程不等于 1。</p>
<p>内存不对齐导致的错，比如指针显示的地址末位不为 4 倍数，1 或 2 或者 3，说明没有对齐，这样就能通过经验一下子发现。</p>
<p>堆分配内存 8 字节为单位。</p>
<p>gdb 不能单独只调试 coredump 文件，必须跟上主程序。Windows 的 core 文件包含一些摘要信息，可以单独调。另外，分析 core 文件，最好现场环境保持一致。</p>
<p>setjump 和 longjum：保存信息，恢复重新输出一些信息。例如 windows 系统挂掉，并没有直接关闭，再跳一下位置，此时执行指令输出一些报错提示重启信息蓝屏信息。</p>
<p>set disassembly-flavor intel：换汇编成 intel 格式</p>
<p>篡改 PC 指针，跳过当前 sigfalut 指令，强制执行下一条，有时候可能会绕过错误。</p>
<p>看系统中断： cat /proc/interrupts</p>
<p>小于 4096 的都是空指针，小于一个页大小的都是。</p>
<p>进程挂死后，先 ps -aux 找到 pid 为 1111，进入 /proc/1111，然后 cat stack，查看栈。</p>
<p>cat /proc/kallsyms：查看假文件系统。</p>
<h3 id="第三天：调优问题"><a href="#第三天：调优问题" class="headerlink" title="第三天：调优问题"></a>第三天：调优问题</h3><p>内核 current 宏变量，内核代码全局可见。</p>
<p>内核代码若定义了 current 变量，编译时则会和内核展开会冲突。比如代码里有 <code>int current = 1;</code> 编译就会奇怪的报错到 get_current () 函数。</p>
<p>常规宏变量都是大写，这里阴差阳错用了小写 current，原因是之前 current 就是全局变量，后来有场景需要，改成了宏，这是最小的代码修改量。</p>
<p>优化思想：插桩 + 统计</p>
<p>perf 通过采样，不准确，统计学理论。</p>
<p>没有 gdb 和其他工具环境，使用 cat trace 查看函数调用茶庄统计情况。echo function &gt; current_tracer</p>
<ul>
<li><p>uboot：arm 用 uboot，体积小，flash 有限。</p>
</li>
<li><p>grub：x86 喜欢用，体积大，功能多。</p>
</li>
</ul>
<p>本机精确查看三级 cache 的方法，可能只针对 x86：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">root@gedu-VirtualBox:/sys# find -name level</span><br><span class="line">./devices/pci0000:00/0000:00:06.0/usb1/power/level</span><br><span class="line">./devices/pci0000:00/0000:00:06.0/usb1/1-1/power/level</span><br><span class="line">./devices/system/cpu/cpu0/cache/index0/level</span><br><span class="line">./devices/system/cpu/cpu0/cache/index3/level</span><br><span class="line">./devices/system/cpu/cpu0/cache/index1/level</span><br><span class="line">./devices/system/cpu/cpu0/cache/index2/level</span><br><span class="line">root@gedu-VirtualBox:/sys# cd devices/system/cpu/</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu# ls</span><br><span class="line">cpu0  cpufreq  cpuidle  hotplug  isolated  kernel_max  modalias  offline  online  possible  power  present  uevent  vulnerabilities</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu# cd cpu0/cache/index0</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat type </span><br><span class="line">Data</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat ../index1/type </span><br><span class="line">Instruction</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat siz</span><br><span class="line">cat: siz: No such file or directory</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat size</span><br><span class="line">32K</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat ../index1/size </span><br><span class="line">32K</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat ../index2/size </span><br><span class="line">256K</span><br><span class="line">root@gedu-VirtualBox:/sys/devices/system/cpu/cpu0/cache/index0# cat ../index3/size </span><br><span class="line">3072K</span><br></pre></td></tr></tbody></table></figure>

<p>lscpu 看的没法验证</p>
<p>L1d cache:             32K<br>L1i cache:             32K<br>L2 cache:              256K<br>L3 cache:              3072K</p>
<p>stack 大小设置，上限，如何避免 stackflow，没有探讨清楚？？</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>程序中的 fall-through 行为分析</title>
    <url>/posts/cf96db1b.html</url>
    <content><![CDATA[<p>最近移指 dyninst 的时候，发现指令解析模块涉及到 fall-through 概念，查了些英文资料后，初步了解了这个概念。</p>
<span id="more"></span>

<h2 id="wiki上的解释"><a href="#wiki上的解释" class="headerlink" title="wiki上的解释"></a>wiki 上的解释</h2><ul>
<li>fall-through(fallthrough and fall through)</li>
</ul>
<blockquote>
<p>(programming) In certain programming constructs, the situation where execution passes to the next condition in a list unless explicitly redirected. （【编程】）在某些编程构造中，除非明确重定向，否则执行转移到列表中的下一个条件的情况。</p>
<blockquote>
<p>1997, Bjarne Stroustrup, The C++ Programming Language: Language Libraries and Design:<br>It is a good idea to comment the (rare) cases in which a fall-through is intentional so that an uncommented fall-through can be assumed to be an error. 最好对故意失败的（罕见）情况进行注释，以便将未注释的失败视为错误。</p>
<p>2001, Graham M Seed, Barry J Cooper, An Introduction to Object-Oriented Programming in C++<br>If you place default elsewhere, then a break will be required to prevent fall-through. 如果您在其他地方设置了默认值，则需要中断以防止失败。</p>
<p>2008, Nagel et al, Professional C# 2008<br>Specifically, it prohibits fall-through conditions in almost all cases. 具体来说，它禁止在几乎所有情况下出现故障。</p>
</blockquote>
</blockquote>
<h2 id="branch指令中的体现"><a href="#branch指令中的体现" class="headerlink" title="branch指令中的体现"></a>branch 指令中的体现</h2><p>branch 指令包含两类：conditional 和 unconditional，分支指令中的指令流执行路径可分为两种：</p>
<ul>
<li><p>target path：指的是将要跳转的位置，例如 C 中 goto 跳转的标签。</p>
</li>
<li><p>fall-through path：指的是紧跟分支指令之后的指令。</p>
</li>
</ul>
<p>如下图所示，从 C 语言角度来看，当条件满足 a 等于 b 的时候，就会跳转到 target address，不满足则进入到 fall through address；从汇编角度来看，当判断条件寄存器 cr0 表示相等时，就跳转到 target address，不相等时则执行紧跟分支指令的下一条指令，即正常的 pc+4；</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202304211004142.png" alt="image-20230421100435020"></p>
<h2 id="switch语句中的体现"><a href="#switch语句中的体现" class="headerlink" title="switch语句中的体现"></a>switch 语句中的体现</h2><h3 id="fall-through行为的示例"><a href="#fall-through行为的示例" class="headerlink" title="fall-through行为的示例"></a>fall-through 行为的示例</h3><p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">switch</span> (result) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 1\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 5\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result does not exist.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>毫无疑问，上述代码块执行结果是：<code>The result is 5</code>，但如果删掉每条 case 里的 break 语句后，结果就不可控了，代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">switch</span> (result) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 1\n"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 5\n"</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 10\n"</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result does not exist.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Case 5, case 10 和 default case 都会被执行，这就是 switch 语句中的 fall-through 行为表现。</p>
<h3 id="fall-through行为的好处"><a href="#fall-through行为的好处" class="headerlink" title="fall-through行为的好处"></a>fall-through 行为的好处</h3><p>这里的 fall-through 行为看上去好像 bug，但事实上并不是，该行为也是有用处的，常用来分类一些相关联的 cases，例如下面代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (result) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is less than 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is less than 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is less than 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result does not exist.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当 result 为 10 时，进入 case 10，打印：The result is 10。<br>当 result 为 1 时，进入 case 1，打印：The result is less than 10。<br>当 result 为 2 时，进入 case 2，打印：The result is less than 10。<br>当 result 为 5 时，进入 case 5，打印：The result is less than 10。</p>
<p>可以看出，后面三种情况是有关联的，并且打印内容是一样的，因此可以删掉 break，通过 fall-through 行为来归类相关联的 cases，这便是该行为的好处。修改后代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (result) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is less than 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result is 10\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The result does not exist.\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机基础知识 - 软硬件和汇编</title>
    <url>/posts/df8d5ad8.html</url>
    <content><![CDATA[<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ol>
<li>计算机是执行<code>输入、运算、输出</code>的机器</li>
<li>程序是<code>指令</code>和<code>数据</code>的集合</li>
<li>计算机处理方式有时和人类思维习惯不同</li>
</ol>
<h3 id="计算机只会输入、运算、输出"><a href="#计算机只会输入、运算、输出" class="headerlink" title="计算机只会输入、运算、输出"></a>计算机只会输入、运算、输出</h3><p>计算机由大量的 IC（集成电路）组成，每块 IC 上都有很多引脚，用于输入和输出。IC 将输入的信息进行运算，并把运算结果输出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210717161912.png" alt="image-20210717161906146"></p>
<h3 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h3><p>指令就是控制计算机进行输入、运算、输出的命令，把向计算机发出的命令一条条记录下来就构成了程序。程序执行的过程就是计算机依次执行这些指令的过程。把一组指令取个名字就叫做函数了。</p>
<p>数据就是在程序运行过程中需要的内容，比如变量。</p>
<h3 id="计算机认为一切都是数字"><a href="#计算机认为一切都是数字" class="headerlink" title="计算机认为一切都是数字"></a>计算机认为一切都是数字</h3><p>比如人们所说的颜色，计算机都用数字编码来表示，如用 “0，0，255” 表示蓝色。</p>
<h2 id="计算机硬件组成"><a href="#计算机硬件组成" class="headerlink" title="计算机硬件组成"></a>计算机硬件组成</h2><p>计算机硬件有三个基本要素：</p>
<ul>
<li>CPU：负责解释、执行指令，从而执行程序。从内存或 I/O 输入数据，在内部进行运算，再把运算结果输出到内存或 I/O。</li>
<li>内存：存放程序，程序又是指令和数据和集合。</li>
<li>I/O：临时存放着用于和周边设备进行输入输出的数据。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210717165118.png" alt="image-20210717165117971"></p>
<blockquote>
<p>参考资料《计算机是怎样跑起来的》</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>底层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现 dyninst 离线安装</title>
    <url>/posts/237b6614.html</url>
    <content><![CDATA[<p>若想实现 dyninst 离线安装，只需要把源码目录下 cmake/packages.cmake 依赖包的下载规则改下，把 URL 改成 SOURCE_DIR。然后在对应的路径下放上解压的依赖源码。</p>
<span id="more"></span>

<p>提前下载并解压好依赖源码包：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@vm:~/dyninst/packages$ ls</span><br><span class="line">binutils-2.23         boost_1_61_0      dwarf-20130126  elfutils-0.168.tar.bz2</span><br><span class="line">binutils-2.23.tar.gz  boost_1_61_0.zip  elfutils-0.168  libdwarf-20130126.tar.gz</span><br><span class="line">lhx@vm:~/dyninst/packages$ pwd</span><br><span class="line">/home/lhx/dyninst/packages</span><br><span class="line">lhx@vm:~/dyninst/packages$ </span><br></pre></td></tr></tbody></table></figure>

<p>cmake/packages.cmake 具体修改如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">diff --git a/packages.cmake b/packages.cmake</span><br><span class="line">index c9fb42a..23c8d56 100644</span><br><span class="line">--- a/packages.cmake</span><br><span class="line">+++ b/packages.cmake</span><br><span class="line">@@ -6,7 +6,7 @@ if (UNIX)</span><br><span class="line">     include(ExternalProject)</span><br><span class="line">     ExternalProject_Add(LibElf</span><br><span class="line">       PREFIX ${CMAKE_BINARY_DIR}/libelf</span><br><span class="line">-      URL https://sourceware.org/elfutils/ftp/0.168/elfutils-0.168.tar.bz2</span><br><span class="line">+      SOURCE_DIR /home/lhx/dyninst/packages/elfutils-0.168</span><br><span class="line">       CONFIGURE_COMMAND &lt;SOURCE_DIR&gt;/configure --enable-shared --prefix=${CMAKE_BINARY_DIR}/libelf</span><br><span class="line">       BUILD_COMMAND make -C libelf</span><br><span class="line">       INSTALL_COMMAND make -C libelf install</span><br><span class="line">@@ -36,7 +36,7 @@ if (UNIX)</span><br><span class="line">       DEPENDS libelf_imp</span><br><span class="line">       #	URL http://reality.sgiweb.org/davea/libdwarf-20130126.tar.gz</span><br><span class="line">       #	URL http://sourceforge.net/p/libdwarf/code/ci/20130126/tarball</span><br><span class="line">-      URL http://www.paradyn.org/libdwarf/libdwarf-20130126.tar.gz</span><br><span class="line">+      SOURCE_DIR /home/lhx/dyninst/packages/dwarf-20130126</span><br><span class="line">       #	GIT_REPOSITORY git://git.code.sf.net/p/libdwarf/code libdwarf-code</span><br><span class="line">       #	GIT_TAG 20130126</span><br><span class="line">       CONFIGURE_COMMAND CFLAGS=-I${LIBELF_INCLUDE_DIR} LDFLAGS=-L${CMAKE_BINARY_DIR}/libelf/lib &lt;SOURCE_DIR&gt;/libdwarf/configure --enable-shared</span><br><span class="line">@@ -65,7 +65,7 @@ if (UNIX)</span><br><span class="line">       include(ExternalProject)</span><br><span class="line">       ExternalProject_Add(LibIberty</span><br><span class="line"> 	PREFIX ${CMAKE_BINARY_DIR}/binutils</span><br><span class="line">-	URL http://ftp.gnu.org/gnu/binutils/binutils-2.23.tar.gz</span><br><span class="line">+	SOURCE_DIR /home/lhx/dyninst/packages/binutils-2.23</span><br><span class="line"> 	CONFIGURE_COMMAND CFLAGS=-fPIC CPPFLAGS=-fPIC PICFLAG=-fPIC &lt;SOURCE_DIR&gt;/libiberty/configure --prefix=${CMAKE_BINARY_DIR}/libiberty --enable-shared</span><br><span class="line"> 	BUILD_COMMAND make all</span><br><span class="line"> 	INSTALL_DIR ${CMAKE_BINARY_DIR}/libiberty</span><br><span class="line">@@ -167,8 +167,7 @@ if(NOT Boost_FOUND)</span><br><span class="line">   include(ExternalProject)</span><br><span class="line">   ExternalProject_Add(boost</span><br><span class="line">     PREFIX ${CMAKE_BINARY_DIR}/boost</span><br><span class="line">-    URL http://downloads.sourceforge.net/project/boost/boost/1.61.0/boost_1_61_0.zip</span><br><span class="line">-    URL_MD5 015ae4afa6f3e597232bfe1dab949ace</span><br><span class="line">+    SOURCE_DIR /home/lhx/dyninst/packages/boost_1_61_0</span><br><span class="line">           BUILD_IN_SOURCE 1</span><br><span class="line">     CONFIGURE_COMMAND ${BOOST_BOOTSTRAP} --prefix=${CMAKE_INSTALL_PREFIX}</span><br><span class="line">     BUILD_COMMAND ${BOOST_BUILD} ${BOOST_ARGS} stage</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>dyninst</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译 glibc 调试版</title>
    <url>/posts/5c4481d2.html</url>
    <content><![CDATA[<h2 id="下载glibc源码"><a href="#下载glibc源码" class="headerlink" title="下载glibc源码"></a>下载 glibc 源码</h2><p>镜像下载地址：<a href="http://mirrors.ustc.edu.cn/gnu/libc/glibc-2.31.tar.gz">http://mirrors.ustc.edu.cn/gnu/libc/glibc-2.31.tar.gz</a></p>
<h2 id="编译安装glibc"><a href="#编译安装glibc" class="headerlink" title="编译安装glibc"></a>编译安装 glibc</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../glibc-2.31/configure --prefix=/home/lhx/glibc/install/ --disable-werror --enable-debug=yes</span><br><span class="line">make -j</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<h2 id="编译测试用例时指定glibc"><a href="#编译测试用例时指定glibc" class="headerlink" title="编译测试用例时指定glibc"></a>编译测试用例时指定 glibc</h2><p>通过 <code>-Wl,-rpath</code> 选项，在编译阶段指定要链接的 glibc 库</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -g test.c -Wl,-rpath=/home/lhx/glibc/install/lib</span><br></pre></td></tr></tbody></table></figure>

<p>有些情况下会报重定位的错误，这时候需要在编译时指定 <code>ld-linux.so.2</code>，即完整的命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">gcc -g test.c -Wl,-rpath=/home/lhx/glibc/install/lib -Wl,-dynamic-linker=/home/lhx/glibc/install/lib/ld-linux.so.2</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到测试用例 a.out 链接的 glibc 库就是刚才自己编译出来的调试版</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test$ ldd a.out </span><br><span class="line">	linux-vdso.so.1 (0x00007fff60736000)</span><br><span class="line">	libc.so.6 =&gt; /home/lhx/glibc/install/lib/libc.so.6 (0x00007fd4a40a5000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fd4a426f000)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开始gdb调试"><a href="#开始gdb调试" class="headerlink" title="开始gdb调试"></a>开始 gdb 调试</h2><p>使用 gdb 调试刚编译的 a.out，可以在 printf 那行代码，单步 step 进入到 printf 的内部。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">13	    printf("i = %d\n", i); </span><br><span class="line">(gdb) s</span><br><span class="line">__printf (format=0x555555556004 "i = %d\n") at printf.c:28</span><br><span class="line">28	{</span><br><span class="line">(gdb) s</span><br><span class="line">32	  va_start (arg, format);</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  __printf (format=0x555555556004 "i = %d\n") at printf.c:32</span><br><span class="line">#1  0x000055555555517b in main () at test2.c:13</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>glibc</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>用于创建进程的 fork 和 execve 函数</title>
    <url>/posts/449772ec.html</url>
    <content><![CDATA[<p>Linux 中创建进程有两个目的：</p>
<ul>
<li>将一个程序分为多个进程进行处理</li>
<li>创建另一个新的进程</li>
</ul>
<p>为了达到上面两个目的，Linux 提供了 fork 和 execve 函数来创建进程。</p>
<span id="more"></span>

<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><code>fork</code> 函数</h2><p><code>fork</code> 函数能够将一个程序分成多个进程进行处理，调用 <code>fork()</code> 后，就会创建一个新的进程，发出请求的是父进程，创建的新进程是子进程。</p>
<p><code>fork()</code> 创建新进程的流程：</p>
<ul>
<li>为子进程申请内存，并复制父进程内存数据到子进程内存空间。</li>
<li>分裂成父进程和子进程，分别执行不同的代码。</li>
<li>在父进程时，<code>fork()</code> 返回子进程 pid；在子进程时，返回 0；fork 失败返回 - 1。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301041702432.jpg" alt="微信图片_20230104165513"></p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; // provide a declaration of exit()</span><br><span class="line">#include &lt;err.h&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">	pid_t pid = fork();</span><br><span class="line">	if (pid == -1)</span><br><span class="line">		err(EXIT_FAILURE, "fork() failed");</span><br><span class="line">	if (pid == 0) {</span><br><span class="line">		// child process came here because fork() returns 0 for child process</span><br><span class="line">		printf("I'm child! my pid is %d.\n", getpid());</span><br><span class="line">		exit(EXIT_SUCCESS);</span><br><span class="line">	} else {</span><br><span class="line">		// parent process came here because fork() returns the pid of newly created child process (&gt; 1)</span><br><span class="line">		printf("I'm parent! my pid is %d and the pid of my child is %d.\n", getpid(), pid);</span><br><span class="line">		exit(EXIT_SUCCESS);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/book-demo/how_linux_works/chapter_3$ ./fork</span><br><span class="line">I'm parent! my pid is 4015 and the pid of my child is 4016.</span><br><span class="line">I'm child! my pid is 4016.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a><code>execve</code> 函数</h2><p>启动另一个新的程序时，需要调用 <code>execve()</code> 函数，其启动新程序的流程是：</p>
<ul>
<li>读取可执行文件中创建进程内存映像所需的数据。</li>
<li>用新进程数据覆盖当前进程的内存。</li>
<li>从头开始运行新的进程。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301041702066.jpg" alt="微信图片_20230104165518"></p>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; // provide a declaration of exit()</span><br><span class="line">#include &lt;err.h&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">	pid_t pid = fork();</span><br><span class="line">	if (pid == -1)</span><br><span class="line">		err(EXIT_FAILURE, "fork() failed");</span><br><span class="line">	if (pid == 0) {</span><br><span class="line">		// child process came here because fork() returns 0 for child process</span><br><span class="line">		char *args[] = { "/bin/echo", "hello world!" , NULL};</span><br><span class="line">		printf("I'm child! my pid is %d.\n", getpid());</span><br><span class="line">		fflush(stdout);</span><br><span class="line">		execve("/bin/echo", args, NULL);</span><br><span class="line">		err(EXIT_FAILURE, "exec() failed");</span><br><span class="line">	} else {</span><br><span class="line">		// parent process came here because fork() returns the pid of newly created child process (&gt; 1)</span><br><span class="line">		printf("I'm parent! my pid is %d and the pid of my child is %d.\n", getpid(), pid);</span><br><span class="line">		exit(EXIT_SUCCESS);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/book-demo/how_linux_works/chapter_3$ ./fork-and-exec </span><br><span class="line">I'm child! my pid is 4027.</span><br><span class="line">I'm parent! my pid is 4026 and the pid of my child is 4027.</span><br><span class="line">hello world!</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 dyninst-12.3.0 最新版编译依赖报错问题</title>
    <url>/posts/9aaf53d7.html</url>
    <content><![CDATA[<h2 id="dyninst-12-3-0最新版存在的问题"><a href="#dyninst-12-3-0最新版存在的问题" class="headerlink" title="dyninst-12.3.0最新版存在的问题"></a>dyninst-12.3.0 最新版存在的问题</h2><p>dyninst-12.3.0 版本中 README 和 Building Dyninst 部分的说明不准确，可能官方更新版本后，未及时更新文档，导致关于依赖库的版本介绍有错，比如 elfutils 需要 1.8.6 而不是 0.173，Boost 需要 1.70.0 而不是 1.61.0，另外 Intel Thread Building Blocks (TBB) 最新版 2021.8 编译完并不识别。</p>
<span id="more"></span>

<h2 id="boost版本太低"><a href="#boost版本太低" class="headerlink" title="boost版本太低"></a>boost 版本太低</h2><p>下载 Boost-1.70.0 或以上版本源码，三步安装：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./b2</span><br><span class="line">/b2 install --prefix=/path/to/install</span><br></pre></td></tr></tbody></table></figure>

<p>安装后指定 dyninst cmake 配置选项：<code>-DBoost_ROOT_DIR=/path/to/install</code></p>
<h2 id="缺少TBB库"><a href="#缺少TBB库" class="headerlink" title="缺少TBB库"></a>缺少 TBB 库</h2><p>下载 one_TBB-2018_U6 版本源码，通过下面脚本进行编译安装：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>安装后指定 dyninst cmake 配置选项：<code>-DTBB_ROOT_DIR=/path/to/install</code></p>
<h2 id="找不到libiberty库"><a href="#找不到libiberty库" class="headerlink" title="找不到libiberty库"></a>找不到 libiberty 库</h2><p>libiberty 是 binutils 库下面的，属于 GNU 工具集，默认不安装。Ubuntu 下执行 <code>sudo apt-get install libiberty-dev</code> 可以安装此库（未亲测）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install binutils-dev</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo yum install binutils-devel</span><br></pre></td></tr></tbody></table></figure>

<h2 id="elfutils版本太低"><a href="#elfutils版本太低" class="headerlink" title="elfutils版本太低"></a>elfutils 版本太低</h2><p>下载 elfutils-0.186 版本源码，configure 时注意跟上后面两个选项，安装脚本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>安装后指定 dyninst cmake 配置选项：<code>-DElfUtils_ROOT_DIR=/path/to/install</code></p>
<p>注意，这里是 <code>-DElfUtils_ROOT_DIR</code>，而不是官方介绍的 <code>-DLibElf_ROOT_DIR</code>。</p>
]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>dyninst</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 dyninst-9.3.2 编译过程报错问题</title>
    <url>/posts/84787fbd.html</url>
    <content><![CDATA[<h2 id="dyninst-9-3-2编译报错"><a href="#dyninst-9-3-2编译报错" class="headerlink" title="dyninst-9.3.2编译报错"></a>dyninst-9.3.2 编译报错</h2><h3 id="GCC-9-编译elfutils报错属性声明问题"><a href="#GCC-9-编译elfutils报错属性声明问题" class="headerlink" title="GCC 9+编译elfutils报错属性声明问题"></a>GCC 9 + 编译 elfutils 报错属性声明问题</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">error: ‘__elf32_msize’ specifies less restrictive attribute than its target ‘elf32_fsize’: ‘const’ [-Werror=missing-attributes]</span><br></pre></td></tr></tbody></table></figure>

<p>解决方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">diff --git a/libelf/elf32_fsize.c b/libelf/elf32_fsize.c</span><br><span class="line">index 0f468de52c382135a099d97d3842f224ee16e8b1..139f4a91ce78406210378bd9ef3657610b64ea4d 100644 (file)</span><br><span class="line">--- a/libelf/elf32_fsize.c</span><br><span class="line">+++ b/libelf/elf32_fsize.c</span><br><span class="line">@@ -58,5 +58,3 @@ elfw2(LIBELFBITS, fsize) (Elf_Type type, size_t count, unsigned int version)</span><br><span class="line"> </span><br><span class="line">   return (count * __libelf_type_sizes[ELFW(ELFCLASS,LIBELFBITS) - 1][type]);</span><br><span class="line"> }</span><br><span class="line">-#define local_strong_alias(n1, n2) strong_alias (n1, n2)</span><br><span class="line">-local_strong_alias (elfw2(LIBELFBITS, fsize), __elfw2(LIBELFBITS, msize))</span><br><span class="line">diff --git a/libelf/libelfP.h b/libelf/libelfP.h</span><br><span class="line">index bc9a404d56778720b9f923f76a040afcc1e89eca..3a96a3b01075df46945a61a68d8b6ce3340fbb4c 100644 (file)</span><br><span class="line">--- a/libelf/libelfP.h</span><br><span class="line">+++ b/libelf/libelfP.h</span><br><span class="line">@@ -444,16 +444,6 @@ extern const uint_fast8_t __libelf_type_aligns[ELFCLASSNUM - 1][ELF_T_NUM]</span><br><span class="line"> extern Elf_Type __libelf_data_type (Elf *elf, int sh_type, GElf_Xword align)</span><br><span class="line">   internal_function;</span><br><span class="line"> </span><br><span class="line">-/* The libelf API does not have such a function but it is still useful.</span><br><span class="line">-   Get the memory size for the given type.</span><br><span class="line">-</span><br><span class="line">-   These functions cannot be marked internal since they are aliases</span><br><span class="line">-   of the export elfXX_fsize functions.*/</span><br><span class="line">-extern size_t __elf32_msize (Elf_Type __type, size_t __count,</span><br><span class="line">-                            unsigned int __version) __const_attribute__;</span><br><span class="line">-extern size_t __elf64_msize (Elf_Type __type, size_t __count,</span><br><span class="line">-                            unsigned int __version) __const_attribute__;</span><br><span class="line">-</span><br><span class="line"> </span><br><span class="line"> /* Create Elf descriptor from memory image.  */</span><br><span class="line"> extern Elf *__libelf_read_mmaped_file (int fildes, void *map_address,</span><br></pre></td></tr></tbody></table></figure>

<h3 id="报错找不到boost头文件"><a href="#报错找不到boost头文件" class="headerlink" title="报错找不到boost头文件"></a>报错找不到 boost 头文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/home/lhx/dyninst/dyninst-9.3.2/common/h/dyn_regs.h:36:10: fatal error: boost/shared_ptr.hpp: 没有那个文件或目录</span><br><span class="line">   36 | #include "boost/shared_ptr.hpp"</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></tbody></table></figure>

<p>解决方法：<br>先去安装 boost 库：<br><code>./bootstrap.sh</code><br><code>./b2</code><br><code>sudo ./b2 install</code></p>
<h3 id="报错找不到zlib"><a href="#报错找不到zlib" class="headerlink" title="报错找不到zlib"></a>报错找不到 zlib</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">error: zlib not found but is required</span><br></pre></td></tr></tbody></table></figure>

<p>解决方法：<br>安装 zlib 库：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install zlib1g</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>dyninst</tag>
      </tags>
  </entry>
  <entry>
    <title>记录 llvm 获取 tag 的脚本与 lldb 不兼容问题解决过程</title>
    <url>/posts/65837399.html</url>
    <content><![CDATA[<h2 id="不兼容问题描述"><a href="#不兼容问题描述" class="headerlink" title="不兼容问题描述"></a>不兼容问题描述</h2><p>负责 llvm 研发的同事在 cmake 脚本里补充了一个小功能，来获取 llvm 仓库的版本号 tag，实现原理是在官方的生成版本脚本里添加了一个 tag 变量，该 tag 变量值通过执行命令 <code>git describe --contains HEAD</code> 来获取。但是实现过程中，在代码里包含了 <code>${LLVM_SOURCE_DIR}</code> 路径变量，编译 llvm 时不会报错，但当编译 lldb 时这个 cmake 脚本就会报错，提示找不到这个路径变量，从而产生了不兼容问题。</p>
<span id="more"></span>

<h2 id="尝试解决方案"><a href="#尝试解决方案" class="headerlink" title="尝试解决方案"></a>尝试解决方案</h2><p>尝试了两个解决方法，实验后发现都不可行。</p>
<ul>
<li><p>尝试了在构建 lldb 的时候，手动指定这个变量值 - DLLVM_SOURCE_DIR=path/to/llvm/source，但是并不能传递过去，分析发现，该变量值需要通过调用该脚本的那个调用者传递，而不能通过最外层构建 lldb 时传递。</p>
</li>
<li><p>把 <code>${LLVM_SOURCE_DIR}</code> 改成 llvm 项目里更常见的变量 <code>${LLVM_ROOT_SRC}</code>，还是不识别。</p>
</li>
</ul>
<h2 id="深入分析问题"><a href="#深入分析问题" class="headerlink" title="深入分析问题"></a>深入分析问题</h2><p>发现添加该功能时，修改的脚本是：llvm-project/llvm/cmake/modules/GenerateVersionFromVCS.cmake，该脚本是属于工具类脚本，可以指定输入参数后进行调用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># CMake script that writes version control information to a header.</span><br><span class="line">#</span><br><span class="line"># Input variables:</span><br><span class="line">#   NAMES             - A list of names for each of the source directories.</span><br><span class="line">#   &lt;NAME&gt;_SOURCE_DIR - A path to source directory for each name in NAMES.</span><br><span class="line">#   HEADER_FILE       - The header file to write</span><br></pre></td></tr></tbody></table></figure>

<p>经过分析发现，这个脚本里的变量都是通过输入参数解析传递过来的，llvm 编译时之所以能识别到 <code>${LLVM_SOURCE_DIR}</code> 路径变量，是因为这里通过 <code>-DLLVM_SOURCE_DIR</code> 指定了传参：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set(generate_vcs_version_script "${LLVM_CMAKE_PATH}/GenerateVersionFromVCS.cmake")</span><br><span class="line"></span><br><span class="line">  COMMAND ${CMAKE_COMMAND} "-DNAMES=LLVM"</span><br><span class="line">                           "-DLLVM_SOURCE_DIR=${llvm_source_dir}"</span><br><span class="line">                           "-DHEADER_FILE=${version_inc}"</span><br><span class="line">                           -P "${generate_vcs_version_script}")</span><br><span class="line"></span><br><span class="line">  COMMAND ${CMAKE_COMMAND} "-DNAMES=\"LLVM;CLANG\""</span><br><span class="line">                           "-DLLVM_SOURCE_DIR=${llvm_source_dir}"</span><br><span class="line">                           "-DCLANG_SOURCE_DIR=${clang_source_dir}"</span><br><span class="line">                           "-DHEADER_FILE=${version_inc}"</span><br><span class="line">                           -P "${generate_vcs_version_script}")</span><br></pre></td></tr></tbody></table></figure>

<p>而在 lldb 源码只指定 <code>-DLLDB_SOURCE_DIR</code> 传参，故而识别不到 <code>-DLLVM_SOURCE_DIR</code>，lldb 里是这样调用脚本的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">add_custom_command(OUTPUT "${version_inc}"</span><br><span class="line">  DEPENDS "${lldb_vc}" "${generate_vcs_version_script}"</span><br><span class="line">  COMMAND ${CMAKE_COMMAND} "-DNAMES=LLDB"</span><br><span class="line">                           "-DLLDB_SOURCE_DIR=${LLDB_SOURCE_DIR}"</span><br><span class="line">                           "-DHEADER_FILE=${version_inc}"</span><br><span class="line">                           -P "${generate_vcs_version_script}")</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>分析了 cmake 脚本传参的特点，发现 <code>NAMES</code> 参数取值可能是 <code>LLDB</code> 单个形式或者 <code>LLVM;CLANG</code> 列表形式，于是通过 <code>list(GET NAMES 0 current_name)</code> 获取参数 <code>NAMES</code> 的第一个参数。然后再把 <code>${LLVM_ROOT_SRC}</code> 换成 <code>${${current_name}_SOURCE_SRC}</code> 就可以了。</p>
<h2 id="学习cmake语法"><a href="#学习cmake语法" class="headerlink" title="学习cmake语法"></a>学习 cmake 语法</h2><p>在这个过程中，自己查阅资料，也学习了一些 cmake 语法知识。</p>
<ol>
<li><p>通过 execute_process 可以在 cmake 里面执行 shell 命令或脚本，OUTPUT_VARIABLE 参数对应输出的内容。例如：</p>
<blockquote>
<p>execute_process (COMMAND echo “Hello World” OUTPUT_VARIABLE output)// 执行命令 echo “Hello World”，输出到 output</p>
</blockquote>
</li>
<li><p>cmake 中字符串可以通过 string 进行操作。例如：</p>
</li>
</ol>
<blockquote>
<p>string (SUBSTRING “Hello World” 0 5 S_sub)// 获取索引 0，长度 5 的子串 Hello</p>
</blockquote>
<ol start="3">
<li>通过 list 命令来处理 cmake 中的字符串列表。例如：</li>
</ol>
<blockquote>
<p>list (GET  input_list 0 element_0)// 获取列表 input_list 中索引 0 的元素，输出到 element_0</p>
</blockquote>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>llvm</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 PTRACE_SINGLESTEP 实现单步调试</title>
    <url>/posts/505e02a1.html</url>
    <content><![CDATA[<h2 id="单步调试原理"><a href="#单步调试原理" class="headerlink" title="单步调试原理"></a>单步调试原理</h2><p>单步调试可以让程序运行一条指令 / 语句后就停下。GDB 中常用的命令有 next, step, nexti, stepi。单步跟踪又常分为语句单步 (next, step) 和指令单步 (如 nexti, stepi)。</p>
<p>在 Linux 上，指令单步可以通过 ptrace 来实现。通过系统调用 ptrace (PTRACE_SINGLESTEP,pid,…) 可以使被调试的进程在每执行完一条指令后就触发一个 SIGTRAP 信号，让 GDB 运行。</p>
<span id="more"></span>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>下面来看一个例子:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) { <span class="comment">// child process</span></span><br><span class="line">    execl(<span class="string">"./a.out"</span>, <span class="string">"HelloWorld"</span>, <span class="literal">NULL</span>);</span><br><span class="line">  } <span class="keyword">else</span> { <span class="comment">// parent process</span></span><br><span class="line">    ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">      wait(&amp;val);</span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(val))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      counter++;</span><br><span class="line">      ptrace(PTRACE_SINGLESTEP, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total Instruction number= %d\n"</span>, counter);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test/test_ptrace/test_singlestep$ ./test-singlestep </span><br><span class="line">Hello World!</span><br><span class="line">Total Instruction number= 180263</span><br></pre></td></tr></tbody></table></figure>

<p>这段程序比较简单，子进程调用 execve 执行 HelloWorld, 而父进程则先调用 ptrace (PTRACE_ATTACH,pid,…) 建立与子进程的跟踪关系。然后调用 ptrace (PTRACE_SINGLESTEP, pid, …) 让子进程一步一停，以统计子进程一共执行了多少条指令 (你会发现一个简单的 HelloWorld 实际上也执行了好几万条指令才完成)。当然你也完全可以在这个时候查看 EIP 寄存器中存放的指令，或者某个变量的值，当然前提是你得知道这个变量在子进程内存镜像中的位置。<br>指令单步可以依靠硬件完成，如 x86 架构处理器支持单步模式 (通过设置 EFLAGS 寄存器的 TF 标志实现)，每执行一条指令，就会产生一次异常 (在 Intel 80386 以上的处理器上还提供了 DRx 调试寄存器以用于软件调试)。也可以通过软件完成，即在每条指令后面都插入一条断点指令，这样每执行一条指令都会产生一次软中断。<br>语句单步基于指令单步实现，即 GDB 算好每条语句所对应的指令，从什么地方开始到什么地方结束。然后在结束的地方插入断点，或者指令单步一步一步的走到结束点，再进行处理。</p>
]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>ptrace</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 qemu+gdb 实现跨架构调试</title>
    <url>/posts/bf48f70d.html</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有时候身边只有 x86 架构的硬件环境，却想学习和测试 arm、mips 等其他架构特性，此时怎么办呢？众所周知，VMware 只能模拟同架构不同操作系统，对此可以通过 qemu 实现跨架构模拟。</p>
<span id="more"></span>

<h2 id="安装-qemu-user"><a href="#安装-qemu-user" class="headerlink" title="安装 qemu-user"></a>安装 qemu-user</h2><p>qemu 是一个支持跨平台虚拟化的虚拟机，有 user mode 和 system mode 两种配置方式。其中 qemu 在 system mode 配置下模拟出整个计算机，可以在 qemu 之上运行一个操作系统。qemu 的 system mode 与常见的 VMware 和 Virtualbox 等虚拟机比较相似，但是 qemu 的优势是可以跨指令集。例如，VMware 和 Virtualbox 之类的工具通常只能在 x86 计算机上虚拟出一个 x86 计算机，而 qemu 支持在 x86 上虚拟出一个 ARM 计算机。qemu 在 user mode 配置下，可以运行跟当前平台指令集不同的平台可执行程序。例如可以用 qemu 在 x86 上运行 ARM 的可执行程序，但是两个平台必须是同一种操作系统，比如 Linux。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装-gdb-multiarch"><a href="#安装-gdb-multiarch" class="headerlink" title="安装 gdb-multiarch"></a>安装 gdb-multiarch</h2><p>gdb-multiarch 是一个经过交叉编译后的、支持多架构版本的 gdb。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装-aarch64-编译工具链"><a href="#安装-aarch64-编译工具链" class="headerlink" title="安装 aarch64 编译工具链"></a>安装 aarch64 编译工具链</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install gcc-aarch64-linux-gnu</span><br></pre></td></tr></tbody></table></figure>

<h2 id="交叉编译测试用例"><a href="#交叉编译测试用例" class="headerlink" title="交叉编译测试用例"></a>交叉编译测试用例</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test/qemu$ ls</span><br><span class="line">hello.c</span><br><span class="line">lhx@ubuntu:~/test/qemu$ cat hello.c </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void hello()</span><br><span class="line">{</span><br><span class="line">  printf("Hello World !\n");</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">  hello();</span><br><span class="line">  return 0;</span><br><span class="line">}</span><br><span class="line">lhx@ubuntu:~/test/qemu$ aarch64-linux-gnu-gcc -g -static hello.c </span><br><span class="line">lhx@ubuntu:~/test/qemu$ ls</span><br><span class="line">a.out  hello.c</span><br><span class="line">lhx@ubuntu:~/test/qemu$ file a.out </span><br><span class="line">a.out: ELF 64-bit LSB executable, ARM aarch64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=e1fe3c59cad06eff9cab2729a00233bc10d763ce, for GNU/Linux 3.7.0, with debug_info, not stripped</span><br><span class="line">lhx@ubuntu:~/test/qemu$ qemu-aarch64 ./a.out </span><br><span class="line">Hello World !</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开始qemu-gdb跨架构调试"><a href="#开始qemu-gdb跨架构调试" class="headerlink" title="开始qemu+gdb跨架构调试"></a>开始 qemu+gdb 跨架构调试</h2><ul>
<li>窗口 1：启动 a.out<br>通过 qemu-aarch64 运行交叉编译的 a.out, 并指定 gdb 调试端口号为 1234，然后等待 gdb 远程连接。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test/qemu$ qemu-aarch64 -g 1234 ./a.out</span><br><span class="line">Hello World !</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>-g port：该选项表示 QEMU_GDB 环境变量取值，即 等待 gdb 连接的端口号。</p>
</blockquote>
<ul>
<li>窗口 2：gdb 远程调试<br>通过 gdb-multiarch 启动 a.out，这里 a.out 用于读取和远程端一致的调试符号信息。连接上远程端口号后，便可以进行设断点、查看寄存器、反汇编等一系列调试操作。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~/test/qemu$ ls</span><br><span class="line">a.out  hello.c</span><br><span class="line">lhx@ubuntu:~/test/qemu$ gdb-multiarch -q a.out </span><br><span class="line">Reading symbols from a.out...</span><br><span class="line">(gdb) target remote localhost:1234</span><br><span class="line">Remote debugging using localhost:1234</span><br><span class="line">0x0000000000400558 in _start ()</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4006d4: file hello.c, line 10.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at hello.c:10</span><br><span class="line">10	  hello();</span><br><span class="line">(gdb) s</span><br><span class="line">hello () at hello.c:5</span><br><span class="line">5	  printf("Hello World !\n");</span><br><span class="line">(gdb) n</span><br><span class="line">6	}</span><br><span class="line">(gdb) info registers </span><br><span class="line">x0             0xe                 14</span><br><span class="line">x1             0x1                 1</span><br><span class="line">x2             0x0                 0</span><br><span class="line">x3             0x48bf00            4767488</span><br><span class="line">x4             0xfbad2a84          4222429828</span><br><span class="line">x5             0x21a               538</span><br><span class="line">x6             0x10                16</span><br><span class="line">x7             0x7f7f7f7f7f7f7f7f  9187201950435737471</span><br><span class="line">x8             0x40                64</span><br><span class="line">x9             0x3fffffff          1073741823</span><br><span class="line">x10            0x20000000          536870912</span><br><span class="line">x11            0x10000             65536</span><br><span class="line">x12            0x48b000            4763648</span><br><span class="line">x13            0x410               1040</span><br><span class="line">x14            0x0                 0</span><br><span class="line">x15            0x48c738            4769592</span><br><span class="line">x16            0x40b998            4241816</span><br><span class="line">x17            0x416fc0            4288448</span><br><span class="line">x18            0x0                 0</span><br><span class="line">x19            0x400db8            4197816</span><br><span class="line">x20            0x400e80            4198016</span><br><span class="line">x21            0x0                 0</span><br><span class="line">x22            0x400280            4194944</span><br><span class="line">x23            0x489030            4755504</span><br><span class="line">x24            0x18                24</span><br><span class="line">x25            0x48b000            4763648</span><br><span class="line">x26            0x48b000            4763648</span><br><span class="line">x27            0x451000            4526080</span><br><span class="line">x28            0x0                 0</span><br><span class="line">x29            0x4000800260        274886296160</span><br><span class="line">x30            0x4006c0            4196032</span><br><span class="line">sp             0x4000800260        0x4000800260</span><br><span class="line">pc             0x4006c0            0x4006c0 &lt;hello+20&gt;</span><br><span class="line">cpsr           0x60000000          1610612736</span><br><span class="line">fpsr           0x0                 0</span><br><span class="line">fpcr           0x0                 0</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line">#0  hello () at hello.c:6</span><br><span class="line">#1  0x00000000004006d8 in main () at hello.c:10</span><br><span class="line">(gdb) disassemble hello</span><br><span class="line">Dump of assembler code for function hello:</span><br><span class="line">   0x00000000004006ac &lt;+0&gt;:	stp	x29, x30, [sp, #-16]!</span><br><span class="line">   0x00000000004006b0 &lt;+4&gt;:	mov	x29, sp</span><br><span class="line">   0x00000000004006b4 &lt;+8&gt;:	adrp	x0, 0x451000 &lt;_nl_locale_subfreeres+552&gt;</span><br><span class="line">   0x00000000004006b8 &lt;+12&gt;:	add	x0, x0, #0x3e8</span><br><span class="line">   0x00000000004006bc &lt;+16&gt;:	bl	0x407350 &lt;puts&gt;</span><br><span class="line">   0x00000000004006c0 &lt;+20&gt;:	nop</span><br><span class="line">   0x00000000004006c4 &lt;+24&gt;:	ldp	x29, x30, [sp], #16</span><br><span class="line">   0x00000000004006c8 &lt;+28&gt;:	ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior 1 (process 1) exited normally]</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 sar 命令获取用户态内核态运行时间</title>
    <url>/posts/45d232ec.html</url>
    <content><![CDATA[<h2 id="sar命令介绍"><a href="#sar命令介绍" class="headerlink" title="sar命令介绍"></a><code>sar</code> 命令介绍</h2><p><code>sar - Collect, report, or save system activity information.</code><br><code>sar</code> 命令用于获取 Linux 进程分别在用户态和内核态运行的时间比例，通过一定周期采集数据，可以看到每个 CPU 核心的工作负载，<code>sar</code> 命令可以用来分析性能。</p>
<span id="more"></span>

<p>如果系统不识别 <code>sar</code> 命令，则需要安装 <code>sysstat</code> 工具:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install sysstat</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sar命令使用"><a href="#sar命令使用" class="headerlink" title="sar命令使用"></a><code>sar</code> 命令使用</h2><p>命令 <code>sar -P ALL 1</code> 用来查看当前系统下所有的 CPU 信息，用 Ctrl+C 暂停运行后就会自动输出已采集的数据平均值。其中，all 字段是 CPU 两个核的平均值，下面是 0 和 1 两个核的具体值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301041517400.png" alt="image-20230104151720278"></p>
<p>各字段含义：</p>
<ul>
<li>% user 用户空间的 CPU 使用</li>
<li> % nice 改变过优先级的进程的 CPU 使用率</li>
<li> % system 内核空间的 CPU 使用率</li>
<li> % iowait CPU 等待 IO 的百分比</li>
<li> % steal 虚拟机的虚拟机 CPU 使用的 CPU</li>
<li>% idle 空闲的 CPU</li>
</ul>
<p><code>%user</code> 和 <code>%nice</code> 字段相加的值是用户态下的运行时间比例，<code>%system</code> 字段值是内核态的时间比例。</p>
<h2 id="测试用户态执行时间"><a href="#测试用户态执行时间" class="headerlink" title="测试用户态执行时间"></a>测试用户态执行时间</h2><p><code>loop.c</code> 死循环测试用例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">{</span><br><span class="line">  for(;;)</span><br><span class="line">  ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>命令 <code>sar -P ALL 1 1</code> 第四个参数制定采集的次数，这里只采集一次。可以发现 CPU 占用率达 50%，则可以说明这个死循环测试用例几乎占满了用户态时间。由于测试环境是虚拟机，结果可能不同，感觉虚拟机 50% 应该就是本机 100% 的意思。如果在本机测试，CPU 占用率应该接近 100%。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301041550695.png" alt="image-202301041550695"></p>
<h2 id="测试内核态执行时间"><a href="#测试内核态执行时间" class="headerlink" title="测试内核态执行时间"></a>测试内核态执行时间</h2><p><code>loop_ppid.c</code> 测试用例如下，在死循环里一直执行系统调用来获取父进程 pid：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) {</span><br><span class="line">  for(;;)</span><br><span class="line">    getppid();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，在采集信息的这一秒内，用户态和内核态时间比例大约 26:24，这里虚拟机显示的总和 50 应该就是宿主机 100 的意思。这个测试用例中，会涉及到 main 函数中的循环处理（属于用户态）和内核执行系统调用的过程（属于内核态）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202301041606922.png" alt="image-20230104160645849"></p>
]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>通过仓库源安装 glibc 符号来实现 gdb 调试</title>
    <url>/posts/c5780575.html</url>
    <content><![CDATA[<h3 id="安装符号"><a href="#安装符号" class="headerlink" title="安装符号"></a>安装符号</h3><p>从仓库源里，安装官方发布的符号包，可以先模糊搜索下，找下 “debug symbols for glibc……” 类似的关键字介绍，从而确定符号包的具体名字。比如 deb 包为 libc6-dbg，rpm 包为 glibc-debugutils，不同的操作系统发行版名字会有变动，比如有些包名为 libc6.1-dbgsym。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install libc6-dbg</span><br></pre></td></tr></tbody></table></figure>
<p>符号信息会安装在 <code>/usr/lib/debug/.build-id</code> 目录下，以 <code>build-id.debug</code> 来命名。build-id 是 gcc 编译二进制的时候计算的文件标识，类似文件哈希值。<br>可以通过 readelf 和 file 命令来查看：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ file a.out </span><br><span class="line">a.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f27b6b8365c516b14ed4bf830e6a80bf28756456, for GNU/Linux 3.2.0, with debug_info, not stripped</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ readelf -n a.out </span><br><span class="line">……</span><br><span class="line">Displaying notes found in: .note.gnu.build-id</span><br><span class="line">  所有者            Data size 	Description</span><br><span class="line">  GNU                  0x00000014	NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: f27b6b8365c516b14ed4bf830e6a80bf28756456</span><br><span class="line">……</span><br><span class="line">lhx@ubuntu:~$ </span><br></pre></td></tr></tbody></table></figure>

<h3 id="验证版本是否对应"><a href="#验证版本是否对应" class="headerlink" title="验证版本是否对应"></a>验证版本是否对应</h3><p>对比一下 build-id，然后 find 查找 build-id.debug 文件时，注意去掉前 2 位，前 2 位为目录名称。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:/usr/lib/debug$ file /lib/x86_64-linux-gnu/libc-2.31.so </span><br><span class="line">/lib/x86_64-linux-gnu/libc-2.31.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1878e6b475720c7c51969e69ab2d276fae6d1dee, for GNU/Linux 3.2.0, stripped</span><br><span class="line">lhx@ubuntu:/usr/lib/debug$ </span><br><span class="line">lhx@ubuntu:/usr/lib/debug$ find -name 78e6b475720c7c51969e69ab2d276fae6d1dee.debug</span><br><span class="line">./.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug</span><br><span class="line">lhx@ubuntu:/usr/lib/debug$ </span><br></pre></td></tr></tbody></table></figure>

<h3 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h3><p>前提是在 /etc/apt/sources.list 中已经配置过 dbkg-src，这样才能通过 apt 下载源码，源码会下载到当前目录并自动解压。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt source libc6-dev</span><br></pre></td></tr></tbody></table></figure>

<h3 id="开始gdb调试"><a href="#开始gdb调试" class="headerlink" title="开始gdb调试"></a>开始 gdb 调试</h3><p>前面准备工作做好后，下面开始 gdb 调试，默认情况下此时 gdb 没有找到 glibc 的符号信息 (No debugging symbols found in /lib/x86_64-linux-gnu/libc.so.6)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lhx@ubuntu:~$ gdb a.out </span><br><span class="line">Reading symbols from a.out...</span><br><span class="line">(gdb) set verbose on</span><br><span class="line">(gdb) b 5</span><br><span class="line">Reading in symbols for hello.c...</span><br><span class="line">Breakpoint 1 at 0x1151: file hello.c, line 5.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/lhx/a.out </span><br><span class="line">Using PIE (Position Independent Executable) displacement 0x555555554000 for "/home/lhx/a.out".</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">(No debugging symbols found in /lib64/ld-linux-x86-64.so.2)</span><br><span class="line">Reading symbols from system-supplied DSO at 0x7ffff7fcd000...</span><br><span class="line">(No debugging symbols found in system-supplied DSO at 0x7ffff7fcd000)</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">(No debugging symbols found in /lib/x86_64-linux-gnu/libc.so.6)</span><br><span class="line"></span><br><span class="line">Breakpoint 1, hello () at hello.c:5</span><br><span class="line">5	  printf("Hello World !\n");</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>

<p>查看下 gdb 符号搜索路径是否正确，不同的话，需要手动设置 debug-file-directory 后才能找到符号信息，可以看到已经成功找到了：Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug…。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) show debug-file-directory </span><br><span class="line">The directory where separate debug symbols are searched for is "/usr/local/lib/debug".</span><br><span class="line">(gdb) set debug-file-directory /usr/lib/debug/</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/lhx/a.out </span><br><span class="line">Using PIE (Position Independent Executable) displacement 0x555555554000 for "/home/lhx/a.out".</span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-64.so.2...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/45/87364908de169dec62ffa538170118c1c3a078.debug...</span><br><span class="line">Reading symbols from system-supplied DSO at 0x7ffff7fcd000...</span><br><span class="line">(No debugging symbols found in system-supplied DSO at 0x7ffff7fcd000)</span><br><span class="line">Reading in symbols for rtld.c...</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span><br><span class="line">Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug...</span><br><span class="line"></span><br><span class="line">Breakpoint 1, hello () at hello.c:5</span><br><span class="line">5	  printf("Hello World !\n");</span><br></pre></td></tr></tbody></table></figure>

<p>找到符号信息后，就可以在 printf 函数处单步调试进入，这时提示 ioputs.c 文件找不到，需要去 glibc 源码目录下 find 一下该文件，然后把文件目录通过 dir 命令添加进去。</p>
<p>到此就大功告成了，从此可以自由自在的调试 glibc 的源码啦！</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">Reading in symbols for ioputs.c...</span><br><span class="line">__GI__IO_puts (str=0x555555556004 "Hello World !") at ioputs.c:33</span><br><span class="line">33	ioputs.c: 没有那个文件或目录.</span><br><span class="line">(gdb) dir ~/test1/glibc-2.31/libio</span><br><span class="line">Source directories searched: /home/lhx/test1/glibc-2.31/libio:$cdir:$cwd</span><br><span class="line">(gdb) n</span><br><span class="line">35	  size_t len = strlen (str);</span><br><span class="line">(gdb) l</span><br><span class="line">30	</span><br><span class="line">31	int</span><br><span class="line">32	_IO_puts (const char *str)</span><br><span class="line">33	{</span><br><span class="line">34	  int result = EOF;</span><br><span class="line">35	  size_t len = strlen (str);</span><br><span class="line">36	  _IO_acquire_lock (stdout);</span><br><span class="line">37	</span><br><span class="line">38	  if ((_IO_vtable_offset (stdout) != 0</span><br><span class="line">39	       || _IO_fwide (stdout, -1) == -1)</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  __GI__IO_puts (str=0x555555556004 "Hello World !") at ioputs.c:35</span><br><span class="line">#1  0x000055555555515d in hello () at hello.c:5</span><br><span class="line">Reading in symbols for ../sysdeps/x86/libc-start.c...</span><br><span class="line">#2  0x0000555555555172 in main () at hello.c:10</span><br><span class="line">(gdb) </span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>通过设置调试寄存器来支持硬件断点和观察点</title>
    <url>/posts/a54785f5.html</url>
    <content><![CDATA[<p>下面的开发者手册，详细介绍了 x86 调试寄存器的使用方法：</p>
<div class="pdf-container" data-target="/pdf/Intel_Manual_Debug_Registers.pdf" data-height="500px"></div>]]></content>
      <categories>
        <category>调试调优</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Fiddler 抓包来解析下载客户端视频源</title>
    <url>/posts/8f97c73e.html</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>购买的网课视频，一般都是绑定到账户上，然后通过客户端或网页形式进行登录后播放，只能在特定的网页或客户端里面观看视频。有时候，课程视频还有设置效期限，超过期限就无法继续观看视频了。对于这种情况，我们会想到能不能通过一些方法把课程视频下载到本地保存起来。</p>
<p>对此通常有两种方法：</p>
<ul>
<li>手动进行逐个录屏保存，然而有些高级的播放器会检测录屏软件，有录屏软件运行则停止播放。</li>
<li>通过一些技术手段解析破解，然后下载。</li>
</ul>
<p>经过查阅资料，想着通过抓包工具来解析下载视频，经过一些尝试摸索，竟然成功实现了！接下来记录下整个过程。</p>
<span id="more"></span>

<h2 id="抓包工具Fiddler"><a href="#抓包工具Fiddler" class="headerlink" title="抓包工具Fiddler"></a>抓包工具 Fiddler</h2><p>Fiddler 是一个抓包工具，是一个位于客户端和服务器端的 HTTP 代理，功能非常强大，目前最常用的 http 抓包工具之一。浏览器或本地播放器发送请求后，首先经过 Fiddler，然后再发送到服务器；当服务器返回数据时，也会先经过 Fiddler，然后再发送到浏览器或本地播放器中显示。因此 Fiddler 就能够拦截到视频数据流的网址，然后可以通过 PotPlayer 这样的播放器播放网址视频流来检测，成功解析到视频网址后，就可以调用 IDM 下载。</p>
<p><strong>打开 Fiddler 软件，进入主界面：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281015520.png" alt="001"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281015993.png" alt="002"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281015782.png" alt="003"></p>
<h2 id="解析视频流"><a href="#解析视频流" class="headerlink" title="解析视频流"></a>解析视频流</h2><p>在购买该课程视频后，通过后台关联账户，就可以通过该账户登录客户端，进行观看视频。如下图，这是在客户端内视频播放的界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281018267.png" alt="004"></p>
<p>点开客户端视频，正常播放后，切换到 Fiddler 界面，观察解析情况发现，有条 https 协议的链接地址 <code>https://shenggeshu.oss-cn-shanghai.aliyuncs.com/246/video/1.overall.mp4?OSSAccessKeyId=LTAI5tBDu919r3tWxa5e1hzA&amp;Expires=1685248910&amp;Signature=WRVzika%2F%2F%2B7eHV%2Fhn9TuAt14tew%3D</code>，地址里面包含关键字 **<code>..../video/1.overall.mp4....</code>**，然后复制该 URL 链接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281025943.png" alt="007"></p>
<h2 id="播放视频流"><a href="#播放视频流" class="headerlink" title="播放视频流"></a>播放视频流</h2><p>打开 PotPlayer 软件，导入视频流链接：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281031162.png" alt="22"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281033768.png" alt="223"></p>
<p>发现能正常播放视频，即解析成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281033560.png" alt="224"></p>
<h2 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h2><p>复制 URL 后，打开 IDM，直接下载：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281034792.png" alt="008"></p>
<p>下载速度取决于你的网络和服务器带宽，由于刚才 <code>1.overall.mp4</code> 秒下，导致没有抓到截图，这里换成了第二个视频链接进行截图演示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281034945.png" alt="009"></p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Fiddler 抓取抖音、快手直播源</title>
    <url>/posts/6e443868.html</url>
    <content><![CDATA[<p>测试了下通过 Fiddler 抓取抖音、快手直播源，均成功了，下面以抖音直播为例子记录一下，快手直播操作方法类似。</p>
<span id="more"></span>

<h2 id="打开抖音网页"><a href="#打开抖音网页" class="headerlink" title="打开抖音网页"></a>打开抖音网页</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281338704.png" alt="001"></p>
<h2 id="打开抓包软件Fiddler"><a href="#打开抓包软件Fiddler" class="headerlink" title="打开抓包软件Fiddler"></a>打开抓包软件 Fiddler</h2><p>先删除所有会话：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281338086.png" alt="002-1"></p>
<p>回到直播网页刷新一下，然后在 Fiddler 抓取的会话里搜索 flv，一般直播格式主要是 flv 和 m3u8。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281338814.png" alt="002-2"></p>
<p>找到带下载箭头的会话，然后复制 URL：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281339488.png" alt="003"></p>
<h2 id="打开PotPlayer播放直播源"><a href="#打开PotPlayer播放直播源" class="headerlink" title="打开PotPlayer播放直播源"></a>打开 PotPlayer 播放直播源</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2023/202305281339197.png" alt="004"></p>
<p>如果想下载直播的话，可以通过 PotPlayer 录制功能实现，也可以通过 IDM 在网页捕取视频后实时下载。</p>
]]></content>
      <categories>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
</search>
