<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-100.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-50.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.css" integrity="sha256-RvRHGSuWAxZpXKV9lLDt2e+rZ+btzn48Wp4ueS3NZKs=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liu-paopao.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Stay hungry, stay foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="PaoPao&#39;s Blog">
<meta property="og:url" content="https://liu-paopao.github.io/page/8/index.html">
<meta property="og:site_name" content="PaoPao&#39;s Blog">
<meta property="og:description" content="Stay hungry, stay foolish.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="paopao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://liu-paopao.github.io/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PaoPao's Blog</title>
  







<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css" />
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PaoPao's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-folder-open fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="paopao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">paopao</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
<!-- none-select-br -->

<p></p>

<!-- hitokoto -->

<div class="hitokoto-title">
	<i class="fa fa-paragraph"></i>
	<b>一言</b>
</div>

<div id="hitokoto">:D 获取中...</div>
<i id="hitofrom">:D 获取中...</i>

<script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
<script>
  fetch('https://v1.hitokoto.cn')
    .then(function (res){
      return res.json();
    })
    .then(function (data) {
      var hitokoto = document.getElementById('hitokoto');
      hitokoto.innerText = '\xa0\xa0\xa0\xa0\xa0\xa0\xa0' + data.hitokoto;
      var hitofrom = document.getElementById('hitofrom');
      hitofrom.innerText = "——" + data.from + '\xa0'; 
    })
    .catch(function (err) {
      console.error(err);
    })
</script>
        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/21a98812.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/21a98812.html" class="post-title-link" itemprop="url">v2ray 多用户配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-22 22:33:22" itemprop="dateCreated datePublished" datetime="2022-01-22T22:33:22+08:00">2022-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-02 10:12:37" itemprop="dateModified" datetime="2022-04-02T10:12:37+08:00">2022-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>点击阅读全文查看详细内容</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/21a98812.html">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/b53da12e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/b53da12e.html" class="post-title-link" itemprop="url">在 Ubuntu20.04 上安装配置私人网盘 nextcloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-18 17:30:49" itemprop="dateCreated datePublished" datetime="2022-01-18T17:30:49+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-20 16:52:29" itemprop="dateModified" datetime="2023-06-20T16:52:29+08:00">2023-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">折腾日记</span></a>
        </span>
    </span>

  
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol>
<li>具有 sudo 权限的用户</li>
<li>具有 example.com 域名，并成功解析到当前 ip（可选）</li>
</ol>
<h2 id="安装Nextcloud"><a href="#安装Nextcloud" class="headerlink" title="安装Nextcloud"></a>安装 Nextcloud</h2><p>这里使用 <code>snap</code> 包管理工具安装 Nextcloud，该打包系统可以安装自动处理底层系统的 <code>snap</code> 包，而不是安装和配置 Web 和数据库服务器，然后配置 Nextcloud 应用程序在其上运行，非常方便，适合不爱折腾的小白。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/b53da12e.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/121d06ee.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/121d06ee.html" class="post-title-link" itemprop="url">如何通过 WebDAV 将 Nextcloud 挂载到本地</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-18 17:29:49" itemprop="dateCreated datePublished" datetime="2022-01-18T17:29:49+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-20 16:57:17" itemprop="dateModified" datetime="2023-06-20T16:57:17+08:00">2023-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">折腾日记</span></a>
        </span>
    </span>

  
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>点击阅读全文查看详细内容</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/121d06ee.html">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/36fffd2c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/36fffd2c.html" class="post-title-link" itemprop="url">读书笔记 -《编码：隐匿在计算机软硬件背后的语言》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-12 10:56:21" itemprop="dateCreated datePublished" datetime="2021-12-12T10:56:21+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-06 10:55:46" itemprop="dateModified" datetime="2022-11-06T10:55:46+08:00">2022-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>点击阅读全文查看详细内容</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/36fffd2c.html">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/4169710f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4169710f.html" class="post-title-link" itemprop="url">搭建个人免费稳定图床 GitHub+jsDelivr+PicGo+Typora</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-31 11:03:44" itemprop="dateCreated datePublished" datetime="2021-10-31T11:03:44+08:00">2021-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-20 16:58:28" itemprop="dateModified" datetime="2023-06-20T16:58:28+08:00">2023-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">折腾日记</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="搭建个人免费稳定图床 GitHub+jsDelivr+PicGo+Typora" href="/posts/4169710f.html#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::db388fe1f47eca64fce89c511919be93" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora"><a href="#搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora" class="headerlink" title="搭建个人免费稳定图床GitHub+jsDelivr+PicGo+Typora"></a>搭建个人免费稳定图床 GitHub+jsDelivr+PicGo+Typora</h1><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104520.gif" alt="IMG_256"></p>
<p>搭建完个人博客以后，写文章的时候就不可避免需要插入图片，于是就需要使用图床工具把本地图片转换成网络图片再把图片链接分享出来。市面上的图床工具非常多，但很多都需要收费，有些免费的也存在着不稳定的风险。现在有一种基于 GitHub 和 jsDelivr 加速的免费图床。PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具，支持多个图床进行使用，其中当然包括我们现在使用的 GitHub 图床了，它同时支持 Windows、macOS、Linux 平台。GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，也不用担心速度和容量问题，而且完全开源免费，再结合 Typora 编辑器，书写 markdown 格式文章，简直效率神器，快来根据下面教程搭建个人的免费稳定图床吧！ </p>
<h2 id="一、新建GitHub图床仓库"><a href="#一、新建GitHub图床仓库" class="headerlink" title="一、新建GitHub图床仓库"></a>一、新建 GitHub 图床仓库</h2><ol>
<li>登录 GitHub 账户，没有的话就注册下，然后新建 GitHub 仓库。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104523.jpg" alt="img"></p>
<p>2、填写仓库名【CDN1】，勾选上【Public】和【Add a README file】，最后点击创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107307.jpg" alt="Snipaste_2021-10-24_15-30-47"></p>
<p>3、创建 GitHub 中的 Token (令牌)</p>
<p>点击右上角头像，选中头像列表中的【Settings】，进入【Settings】，点击【Developer Settings】，再点击【<a target="_blank" rel="noopener" href="https://github.com/settings/tokens">Personal access tokens</a>】，接着点击【Generate new token】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107067.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107725.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107888.jpg" alt="img"></p>
<p>在 Note 中取一个名字，选中 repo 这个框过后直接点击完成（Generate token）</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107110.jpg" alt="img"></p>
<p>最后生成 token，记住这个令牌一定要复制保存，建议保存到记事本里，如果没有保存的需要删除重来一遍。</p>
<h2 id="二、配置PicGo"><a href="#二、配置PicGo" class="headerlink" title="二、配置PicGo"></a>二、配置 PicGo</h2><p>1、安装 PicGo</p>
<p>下载地址 <a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，根据默认勾选安装即可。</p>
<p>2、打开 PicGo，配置图床</p>
<p>设定仓库名：按照【GitHub 用户名 / 图床仓库名】的格式填写</p>
<p>设定分支名：【main】</p>
<p>设定 Token：粘贴 GitHub 生成的【Token】</p>
<p>指定存储路径：默认路径为【img/】，图片将会储存在此文件夹中，而我改成了 img/2021/。</p>
<p>设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照【自定义域名 + 上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%91">https://cdn.jsdelivr.net/gh/ 用户名 / 图床仓库名】</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104577.jpg" alt="2"></p>
<p>3、进入 PicGo 设置，打开时间戳重命名，避免因图片重名而导致上传失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311345102.jpg" alt="3"></p>
<p>4、可以打开上传区测试一下，选择 URL 的图片链接格式，上传完图片后复制链接，直接再浏览器打开就能看到了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104927.jpg" alt="4"></p>
<h2 id="三、配置typora"><a href="#三、配置typora" class="headerlink" title="三、配置typora"></a>三、配置 typora</h2><p>1、下载 typora：<a target="_blank" rel="noopener" href="https://typora.io/">https://typora.io/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104776.jpeg" alt="111"></p>
<p>2、打开【文件】中【偏好设置】，选择【图像】，根据图片中配置进行勾选。最后再找到 PicGo 软件的安装位置，可以上传验证测试下，默认会上传 typora 图标。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104208.jpg" alt="01"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104756.jpg" alt="02"><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104944.jpg" alt="03"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104504.jpg" alt="04"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/e8c622c9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e8c622c9.html" class="post-title-link" itemprop="url">龙芯服务器重装 UOS 系统 + 搭建本地仓库源</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-26 22:42:54" itemprop="dateCreated datePublished" datetime="2021-10-26T22:42:54+08:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-02 10:14:56" itemprop="dateModified" datetime="2022-04-02T10:14:56+08:00">2022-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>点击阅读全文查看详细内容</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/e8c622c9.html">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/22588541.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/22588541.html" class="post-title-link" itemprop="url">RPM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-17 18:10:04 / 修改时间：18:11:46" itemprop="dateCreated datePublished" datetime="2021-09-17T18:10:04+08:00">2021-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="RPM 介绍" href="/posts/22588541.html#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::01f8ef51f599adc8fd3f5975cfa02d85" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RPM-命令"><a href="#RPM-命令" class="headerlink" title="RPM 命令"></a>RPM 命令</h1><p><strong>一、RPM 介绍</strong></p>
<p>1. 什么是 rpm ？</p>
<p>rpm 即 RedHat Package Management，是 RedHat 的发明之一</p>
<p>2. 为什么需要 rpm ？</p>
<p>在一个操作系统下，需要安装实现各种功能的软件包。这些软件包一般都有各自的程序，<br>但是同时也有错综复杂的依赖关系。同时还需要 解决软件包的版本，以及安装，配置，<br>卸载的自动化问题。为了解决 这些问题，RedHat 针对自己的系统提出了一个较好的办法<br>来管理成千 上百的软件。这就是 RPM 管理系统。在系统中安装了 rpm 管理系统以后，<br>只要是符合 rpm 文件标准的打包程序都可以方便地安装、升级、卸载。</p>
<p>3. 是不是所有的 linux 都使用 rpm ？</p>
<p>任何系统都需要包管理系统，因此很多 linux 都使用 rpm 系统。 rpm 系统是 Redhat Linux 和<br>Fedora Core 的软件包管理器，但是 Mandriva、SuSE 等 Linux 发行版也都使用 rpm。由于 rpm<br>的源程序可以在别的系统上进行编译，所以有可能在别的系统上也使用 rpm。除了 rpm，<br>其他一些系统也有自己的软件包管理程序， 例如 debian 的 deb 包。</p>
<p>4.rpm 包的文件名为什么那么长 ？</p>
<p>rpm 包的文件名中包含了这个软件包的版本信息，操作系统信息，硬件要求等等。<br>比如 mypackage-1.1-2RH.i386.rpm，其中 mypackage 是在系统中登记的软件包的名字 1.1<br>是软件的版本号，2 是发行号，RH 表示用于 RH 操作系统。i386 表示用于 intel x86 平台。</p>
<p>5. 软件包文件名中的 i386,i686 是什么意思</p>
<p>rpm 软件包的文件名中，不仅包含了软件名称，版本信息，还包括了适用的硬件架构的信息。</p>
<p>i386 指这个软件包适用于 intel 80386 以上的 x86 架构的计算机 (AI32)<br>i686 指这个软件包适用于 intel 80686 以上 (奔腾 pro 以上) 的 x86 架构的计算机 (IA32)<br>noarch 指这个软件包与硬件架构无关，可以通用。</p>
<p>i686 软件包通常针对 CPU 进行了优化，现在通常配置的机器都可以使用 i686 软件包。</p>
<p>6. 不同操作系统发行的 rpm 包可否混用？</p>
<p>对于已经编译成二进制的 rpm 包，由于操作系统环境不同，一般不能混用。<br>对于以 src.rpm 发行的软件包，由于需要安装时进行本地编译，所以通常可以在不同系统下安装。</p>
<p><strong>二、RPM 包管理的用途</strong></p>
<p>1、可以安装、删除、升级和管理以 rpm 包形式发布的软件；<br>2、可以查询某个 rpm 包中包含哪些文件，以及某个指定文件属于哪个 rpm 包；<br>3、可以在查询系统中的某个 rpm 包是否已安装以及其版本；<br>4、作为开发者可以把自己开发的软件打成 rpm 包发布；<br>5、依赖性的检查，查询安装某个 rpm 包时，需要哪些其它的 rpm 包。</p>
<p>注：RPM 软件的安装、删除、更新只有 root 权限才能使用；<br>对于查询功能任何用户都可以操作。</p>
<p><strong>三、rpm 的一点简单用法</strong></p>
<p>rpm 的一般格式：</p>
<p>rpm [选项] [rpm 软件包]</p>
<p>1、初始化 rpm 数据库（可以省略）</p>
<p>rpm –initdb<br>rpm –rebuilddb % 注：这个要花好长时间</p>
<p>% 注：有时 rpm 系统出了问题，不能安装和查询，大多是这里出了问题。</p>
<p>2、RPM 软件包管理的查询功能：</p>
<p>rpm -q [select-options] [query-options]</p>
<p>RPM 的查询功能是极为强大，是极为重要的功能之一；这里举几个常用的例子，更为详细的具体的，请参考 man rpm</p>
<p><em>对系统中已安装软件的查询</em></p>
<p>1）查询系统已安装的软件</p>
<p>语法：rpm -q 软件名</p>
<p>例：rpm -q gaim<br>% -q 就是 –query，此选项表示询问系统是不是安装了 gaim 软件包；<br>% 如果已安装会有信息输出；如果没有安装，会输出 gaim 没有安装的信息；</p>
<p>% 查看系统中所有已经安装的包，要加 -a 参数<br>rpm -qa</p>
<p>% 如果分页查看，再加一个管道 | 和 more 命令<br>rpm -qa |more</p>
<p>% 如果要查找某个软件包，可以用 grep 抽取出来<br>rpm -qa |grep mplayer</p>
<p>2）查询一个已经安装的文件属于哪个软件包；</p>
<p>语法: rpm -qf 文件名</p>
<p>注：文件名所在的绝对路径要指出</p>
<p>例：rpm -qf /usr/lib/libacl.la</p>
<p>3）查询已安装软件包都安装到何处；</p>
<p>语法：rpm -ql 软件包名</p>
<p>例：rpm -ql mplayer</p>
<p>4）查询一个已安装软件包的信息</p>
<p>语法： rpm -qi 软件包名</p>
<p>例：rpm -qi mplayer</p>
<p>5）查看一下已安装软件的配置文件；</p>
<p>语法格式：rpm -qc 软件名</p>
<p>例：rpm -qc mplayer</p>
<p>6）查看一个已经安装软件的文档安装位置：</p>
<p>语法格式： rpm -qd 软件名</p>
<p>例：rpm -qd mplayer</p>
<p>7）查看一下已安装软件所依赖的软件包及文件；</p>
<p>语法格式： rpm -qR 软件名</p>
<p>例：rpm -qR mplayer</p>
<p><strong>注</strong>：可以把几个参数组合起来用，如 rpm -qil mplayer</p>
<p><em>对于未安装的软件包的查看</em> : 查看的前提是当前目录下已存在一个.rpm 文件。</p>
<p>1）查看一个软件包的用途、版本等信息；</p>
<p>语法： rpm -qpi file.rpm</p>
<p>例：rpm -qpi mplayer-1.0pre7try2-2.i386.rpm</p>
<p>2）查看一件软件包所包含的文件；</p>
<p>语法： rpm -qpl file.rpm</p>
<p>例：rpm -qpl mplayer-1.0pre7try2-2.i386.rpm</p>
<p>3）查看软件包的文档所在的位置；</p>
<p>语法： rpm -qpd file.rpm</p>
<p>例：rpm -qpd mplayer-1.0pre7try2-2.i386.rpm</p>
<p>4）查看一个软件包的配置文件；</p>
<p>语法： rpm -qpc file.rpm</p>
<p>例：rpm -qpc mplayer-1.0pre7try2-2.i386.rpm</p>
<p>5）查看一个软件包的依赖关系</p>
<p>语法： rpm -qpR file.rpm</p>
<p>例：rpm -qpR mplayer-1.0pre7try2-2.i386.rpm</p>
<p>3、软件包的安装、升级、删除等； <em>安装和升级一个 rpm 包</em></p>
<p>语法：<br>rpm -ivh file.rpm % 这个是用来安装一个新的 rpm 包<br>rpm -Uvh file.rpm % 这是用来升级一个 rpm 包</p>
<p>% 如果有依赖关系的，需解决依赖关系。<br>% 如果找不到依赖关系的包，可以用下面的命令强制安装：</p>
<p>rpm -ivh –nodeps –force file.rpm<br>rpm -Uvh –nodeps –force file.rpm</p>
<p>例：<br>rpm -ivh –test mplayer-1.0pre7try2-2.i386.rpm<br>% –test 表示测试，并不真正安装。</p>
<p>rpm -ivh –relocate /=/usr/local/mplayer mplayer-1.0pre7try2-2.i386.rpm<br>% 为软件包指定安装目录：要加 –relocate 参数<br>% 安装在指定目录中的程序如何调用呢？<br>% 通常可执行程序都放在安装目录下的 bin 或者 sbin 目录中。</p>
<p><em>删除一个 rpm 包</em></p>
<p>首先查出需要删除的 rpm 包，然后用下面的命令来卸载：</p>
<p>rpm -e 软件包名</p>
<p>例：rpm -e mplayer % 卸载 mplayer<br>% 如果有其它的 rpm 依赖于该 rpm 包，系统会出现警告。<br>% 如果一定要卸载，可以用选项 –nodeps 忽略依赖关系。但最好不要这么做。</p>
<p><strong>四、RPM 管理包管理器支持网络安装和查询</strong></p>
<p>rpm [选项] rpm 包的 http 或者 ftp 的地址</p>
<p>比如我们想通过 Fedora Core 4.0 的一个镜像查询、安装软件包。</p>
<p>rpm -qpi <a target="_blank" rel="noopener" href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 查询</p>
<p>rpm -ivh <a target="_blank" rel="noopener" href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 安装</p>
<p><strong>五、对已安装 rpm 包查询的一点补充</strong></p>
<p>可以用 locate 来查询一些软件的安装位置，可能需要先运行 updatedb 来更新已安装软件库</p>
<p><strong>六、从 rpm 软件包抽取文件</strong></p>
<p>rpm2cpio xxx.rpm | cpio -idmv<br>% i 表示提取文件，v 表示指示执行进程<br>% d 表示根据包中文件原来的路径建立目录<br>% m 表示保持文件的更新时间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/659154a1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/659154a1.html" class="post-title-link" itemprop="url">搞懂链接器 4：大型项目的构建过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 10:18:05" itemprop="dateCreated datePublished" datetime="2021-07-30T10:18:05+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-09 17:06:19" itemprop="dateModified" datetime="2023-01-09T17:06:19+08:00">2023-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">编译器</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="搞懂链接器 4：大型项目的构建过程" href="/posts/659154a1.html#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::eb2e739994beb9d9a8ad3c42cdc465cc" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在讲解大型项目如何被构建之前，我们首先来讨论一个问题，有句话说的很好，梦想总是要有的，万一实现了呢，那么问题来了，要怎么实现呢，这里就涉及到了如何实现目标，</p>
<p>目标是如何实现的</p>
<p>其实很简单，本质上只有两点：</p>
<ul>
<li>知道最后想要的是什么</li>
<li>为此需要做些什么</li>
</ul>
<p>有时我们的目标可能不是简单的诸如每天跑五公里之类，比如像通过一门考试，学会一项技能这样的系统性工程。这时我们可能一下子不知道要做些什么，那么这就需要进行任务分解了，即这里的规则就是，把一个大的目标分解为一个个小的目标，如果对于其中一个小的目标还是不够具体，那么就继续将小目标进行分解，直到将每个小目标分解为如每天读懂两个章节，做完十个练习题之类很具体可以马上实施的任务为止。到这时，对于如何实现这个大的目标就很清晰了，只需要严格按照计划去实施就好了。比如对于考研，我们就可以列出如下的计划：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102100.png" alt="image-20210730102100140"></p>
<p>在考研这个例子中我们就按照上述规则将目标进行了分解，每个目标都按如下格式列出：</p>
<blockquote>
<p>  * <strong>目标 (target): 依赖什么 *</strong></p>
<p>​        * <strong>要怎么做 *</strong></p>
</blockquote>
<p>如果 “要怎么做” 还不是一个具体的目标就继续分解，直到分解为类似进程这样的目标，因为像进程这样的目标已经有了具体的实现步骤。最后我们将各个已经实现的小目标汇集起来整个大的目标就实现了。</p>
<p>本质上，一个大型项目的构建过程与此类似。</p>
<p>Make</p>
<p>再大的项目最后生成的都是一个可执行文件，只要是可执行文件就需要依赖各种目标文件，动态库，静态库；静态库同样需要依赖其它目标文件，静态库；而动态库可能又依赖其它目标文件，动态库，静态库，知道了这些又该如何构建呢，我们可以利用上面目标划分的方法规划好构建最终的可执行文件需要哪些原材料，这些原材料又是如何获取的。有了这些规划后，我们就可以依次编译出一些小的目标文件，将这些目标文件链接成静态库，动态库以方便使用。然后再一步步连接目标文件以及各种库从而形成更大的库，最后将几个必要库以及目标文件进行链接从而生成最终的可执行文件。</p>
<p>程序员先驱们确实就是使用这种现在看起来非常原始非常古老的方法进行程序编写的，每个目标文件以及库都是自己手动编译链接出来，然后再将它们链接成更大的库，直到最后生成可执行文件。</p>
<p>这种方法看上去非常简单，但是缺点也很明显，那就是非常繁琐，一旦某个源文件进行了改动，所有依赖此文件的库都需要重新编译链接，手工来完成这项工作是极其枯燥且容易出错的。为解决这个问题，天才的程序员们想出了一个小工具，没错就是 make，从此编译链接这个过程就被 make 自动化了，程序员得以从繁琐的编译链接中解放出来，使用 make 时我们只需要编写规则，也就是告诉 make 最终的可执行文件依赖什么，为此需要做些什么，这些规则类似于上面的目标分解，当编写好这些规则后，然后简单的执行一个命令也就是 make 就可以了。如果某个源文件被修改了，也只需要简单的重新执行一下 make 命令，因为整个过程的规则并没有改变，而 make 也会很聪明的只编译链接那些需要更新的目标文件，库，并重新进行可执行文件的生成。对于那些没有改动的源文件，make 不会重新编译它们。</p>
<p>make 中每一条规则与前面的目标划分非常相似，make 的规则是这样的：</p>
<blockquote>
<p>*<strong>target: prerequisites*</strong></p>
<p>​      *<strong>recipe*</strong></p>
</blockquote>
<p>target 也就类似于我们的一个目标；而 prerequisites，即先决条件，也就是依赖什么；recipe，这个就更形象了，即菜谱，也就是上面的要怎么做。make 中的规则保存在了叫做 Makefile 的文件当中 (没错，这个文件的名字就叫做 Makefile)，当运行 make 命令时，make 程序会自动找到当前路径下的 Makefile，然后开始执行里面的规则。</p>
<p>有些同学可能为此感到疑惑，这里的 Makefile 其实就是脚本，而 make 读取这个脚本然后根据里面的内容来执行命令，而对于 make 大家也不要觉得很神奇，make 也是一个普通程序，和我们平时使用的程序没什么区别。确定好了 make 需要执行的脚本的名字，这样在运行 make 命令时就少打了几个单词，假如用户可以自定义 make 的执行脚本名字，比如用户创建了一个脚本叫做 foo，那么执行 make 的时候就需要多打一个单词 “make foo”，所以干脆就直接确定好了脚本的名字就叫 Makefile，这样在运行命令时只需要打一个单词 make 就可以了。</p>
<p>这里举个简单的例子，比如我们写了一个 helloworld 程序，将源文件命名为了 helloworld.c，我们想把该源文件编程成一个叫做 hw 的可执行文件，那么一个最简单的 Makefile 就可以写成这样：</p>
<blockquote>
<p><em>hw: helloworld.o</em></p>
<p>​    <em>gcc helloworld.o -o hw</em></p>
<p><em>helloworld.o : helloworld.c</em></p>
<p>​    <em>gcc -c helloworld.c</em></p>
</blockquote>
<p>在这里最终的可执行文件 hw 依赖目标文件 helloworld.o，那么假设我们现在已经有 helloworld.o 了就可以利用命令 gcc helloworld.o -o hw 生成我们需要的可执行文件了。那么 helloworld.o 又该如何获得呢？我们看第二条规则，helloworld.o 依赖 helloworld.c，因为 helloworld.c 已经写好了，所以可以直接用命令 gcc -c helloworld.c 来生成。这样整个目标就达成了。</p>
<p>本质上现在我们使用的各种集成开发环境 (IDE)，其自动化编译工具背后的原理和 make 是一样的，比如我们在使用 Visual Studio 时从来没有关心过每个文件是如何被编译链接的，这些 IDE 都为我们代劳了。但是在比如 Linux 环境下进行开发时，这个过程依然是需要程序员了解的。</p>
<p>现在让我们来回答本节提出的问题，也就是大型项目是如何被构建的。</p>
<p>构建大型项目</p>
<p>大型项目中通常会有成百上千甚至上万个源文件，这些源文件统一放在了一个文件夹中方便管理。典型的项目如图所示，圆形代表源文件，其它为文件夹。注意这里仅仅为说明问题，各个公司团队都有自己的代码组织以及命名方式，而且真实项目要比该图复杂的多，但是本质上这里的讨论适用于其它情况。</p>
<p>源码组织方式</p>
<p>通常项目的组织方式如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102125.png" alt="image-20210730102125821"></p>
<p>项目源码会被放置在 src 当中，这个例子当中 src 下有两个文件夹，lib 以及 app，lib 用于存放一些工具性的代码，比如这里列举的网络通信以及字符串处理模块，通常 lib 下的代码会被编译成各种库，方便 app 使用。app 中就是各种需要可执行文件 (程序) 的代码了。通常像这里的 lib 以及 app 都会有专门的团队来负责。更大一些的项目，每个 lib 下的子目录比如这里的 net，strings 都会有专门的团队来负责以方便项目的模块化管理。</p>
<p>从这里可以看出一般项目通常会按模块将源文件放入相应的文件夹下进行分类，我们在上一节中简单介绍了 make 的用法，但是那里仅仅需要编译一个源文件 helloworld.c。对于如上图所示的项目，像 make 这一类的编译工具又该如何处理呢？</p>
<p>make 的嵌套执行能力可以解决这个问题。比如对于模块 net，你可以为 net 模块写一个单独的 Makefile，该 Makefile 只用于编译 net 下的源文件，具体的脚本如下所示，只需要简单的两行。</p>
<p><em>network:</em></p>
<p>​    <em>cd net &amp;&amp; make</em></p>
<ul>
<li></li>
<li></li>
</ul>
<p>这句话的意思是告诉 make，要想编译网络模块 (network) 需要进到 net 文件夹并且执行 make 命令，当 make 进入到 net 文件夹开始执行 make 时，net 下的 Makefile 就开始被执行了。通过这样一个简单的命令就可以实现 make 的嵌套执行了。make 的这项特性使得每个模块都可以当做独立项目进行维护。</p>
<p>编译工具的这项功能，方便了项目的模块化管理。使得项目中每个模块都可以有独立的编译脚本，比如使用 make 进行编译的话，那么每个模块中都会有单独的 Makefile，比如在文件夹 net，strings 中都有自己的 Makefile。如上图中蓝色部分，其中白色部分为源文件，更清晰的关于 Makefile 的组织方式如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102155.png" alt="image-20210730102155778"></p>
<p>这些脚本中定义了如何编译该模块，以及编译该模块需要依赖什么。这些模块的父目录也就是 lib 文件夹下同样也有自己的 Makefile，lib 下的 Makefile 会收集各个子模块的编译结果，然后将其链接成各种库。而对于 app 下面的子目录来说，这些子目录中就是各个可执行文件的源码了，比如这里的 wechat 文件下就是可执行程序微信的源码了，微信中可能会用到 lib 下提供的功能，那么对于 wechat 中的 Makefile 来说，只需要简单的加入对 lib 中所需要的库的依赖就可以了。wechat 的父目录 app 中同样也有 Makefile，这里的 Makefile 就相对简单了，只需要依次执行 QQ，wechat 中的 Makefile 就可以了，因此在 src 目录下简单的运行 make 命令，所有 app 比如 QQ 和 wechat 就都被编译出来了。</p>
<p>接下来我们详细的讲解一下这个过程。请注意一点，接下来讲解的 make 执行过程仅仅是可能的一种实现方式，但是这个示例已足够说明项目的构建过程。</p>
<p>make 的执行过程</p>
<p>在上面的示例中 src 下的 Makefile 是整个编译过程的入口，因此我们进入 src 文件夹开始执行 make 命令。</p>
<p>（1）在 src 目录下，make 首先读取 src 下的 Makefile，./src/Makefile 非常简单，该文件仅仅告诉 make 需要去 app 目录下执行 make 命令。</p>
<p>（2）make 来./src/app 目录下，开始读取该目录下的 Makefile，该文件定义了编译出 QQ，微信的规则，make 首先执行编译 QQ 的规则，该规则告诉 make 编译 QQ 则需要到./src/app/QQ 目录并执行 make 命令。</p>
<p>（3）make 来到./src/app/QQ 目录下，开始读取该目录下的 Makefile，该文件定义了编译 QQ 程序 的规则，make 开始执行这些规则，其中一项规则需要依赖网络模块的库，同时该规则告诉了 make 如果想得到该网络库则需要进入到./src/lib 下执行 make 命令。</p>
<p>（4）make 来到./src/lib 目录下，开始读取该目录下的 Makefile，该文件定义了编译出网络库，字符串处理库的规则，make 首先执行编译网络库的规则，该规则告诉 make 如果想得到该网络库则需要进入到./src/lib/net 下执行 make 命令。</p>
<p>（5）make 来到./src/lib/net 目录下，开始读取该目录下的 Makefile，该文件定义了编译网络库的规则，编译网络库不再依赖任何其它库，make 终于可以安心的开始工作不用再跳来跳去了，make 开始执行该目录下的 Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库 (当然也可以是动态库，依赖编译规则)。make 在./src/lib/net 完成任务后跳转回./src/lib，因为 make 会记住自己是从哪个目录跳转到当前目录的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102227.png" alt="image-20210730102227439"></p>
<p>（6）make 再次回到./src/lib 下，因为 make 执行完了网络库的编译规则，因此继续往下执行，也就是字符串库的编译规则，该规则告诉 make 如果想得到字符串库则需要进入到 src/lib/strings 下执行 make 命令。</p>
<p>（7）make 来到./src/lib/strings 目录项，开始读取该目录下的 Makefile，该文件定义了编译字符串库的规则，同样，编译字符串库不需要依赖任何其它库，make 开始执行该目录下的 Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库 (当然也可以是动态库)。make 在./src/lib/strings 下完成任务后跳转回./src/lib，因为 make 就是从这个目录跳转到./src/lib/strings 的。</p>
<p>（8）make 回到./src/lib，如果该目录下的 Makefile 还有其它编译规则，则继续上面的过程，如果没有其它规则，则该目录下的编译任务执行完成，make 返回到./src/app/QQ。</p>
<p>（9）make 回到./src/app/QQ 下继续执行被中断的规则，这时 QQ 所依赖的库都已经编译完成，因此 make 可以直接进行链接了，QQ 程序编译链接完成。make 返回到./src/app。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102246.png" alt="image-20210730102246124"></p>
<p>（10）make 来到./src/app 下继续执行被中断的规则，make 开始执行微信程序的编译规则，这里和 QQ 的编译是一样的，唯一一点即如果微信也需要依赖网络库和字符串库，那么当 make 调转到./src/lib 下会发现这些库已经生成了，因此直接返回。当 make 执行完./src/app 下的编译规则后，QQ 和微信程序就都编译完成了。make 返回到./src 后，发现该目录下的 Makefile 执行完毕，因此 make 程序退出，整个编译过程完成。</p>
<p>如果你对这个过程还不是很清楚的话，我们用一个游戏的类比来加深你对整个过程的理解。</p>
<p>相信很多同学都玩过 RPG (角色扮演) 游戏，比如仙剑奇侠传，阴阳师。你可以把大型项目的编译过程想象成玩 RPG 游戏，这类的游戏通常都会有一个主线，若干支线，通常主线的每一关都需要你去某个支线完成任务，例如拿到宝物之类，当你完成支线任务拿到宝物后，你才能回到主线进入到下一关。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102319.png" alt="image-20210730102319657"></p>
<p>在这里，make 程序就好比玩家，游戏里的任务就好比编译脚本 Makefile，主线任务就好比 app 下的 Makefile，支线任务就好比编译 app 所依赖的库或者目标文件，比如这里的 lib 下的 Makefile。</p>
<p>首先玩家 make 进入主线，也就是 app 下，读取主线需要完成的任务 (app 下的 Makefile)，主线任务告诉玩家 make 通过其中某一关 (比如编译出可执行文件 app1) 依赖一个支线任务，拿到宝物 (app1 所依赖的 lib 下的某个库)，这时玩家 make 开始去支线场景 (进入 lib 文件夹)，然后读取支线任务 (读取 lib 下的 Makefile)，make 开始在 lib 下打怪升级 (开始编译链接 lib 下源文件并生成相应的库)，当 make 完成支线任务拿到宝物 (lib 中编译出来的库) 回到主线任务 (回到 app 下 Makefile 因跳转到 lib 被中断的接下来的编译脚本) 后，才可以继续接下来的通关。</p>
<p>有的同学可能已经发现了，像上面的这种编译实现方式其实是比较混乱的，既然我们 make 给了我们可以将每个模块当做独立项目进行编译的能力，那么对于非应用程序的代码比如这里的 src/lib，我们可以提前编译出来，最后再来编译 src/app 下的代码，这样当依赖某个库时无需再去将该库编译出来。使用上面的编译顺序是为了说明 make 的构建方式是多样的，实际上使用 make 这一类的工具你可以使用任何你想要的编译顺序进行项目构建，本质上写 Makefile 就是写程序，这些程序告诉 make 该如何构建出最后的可执行文件，至于构建程序该以什么样的顺序构建出可执行文件，一切由你做主。这就是 make 这类编译工具的灵活以及强大之处。</p>
<p>还有一点需要注意的就是，真实的项目中会有很多模块是相互独立的，即这些模块互不依赖，为加快编译速度，make 支持并行编译以充分利用多核的处理能力。</p>
<p>关于大型项目的构建到这里就讲解的差不多了，我们可以看到大型项目的构建其实和我们平时完成一个目标是类似的，先有一个大的目标并将其分解为一个个比较容易实现的小目标，当所有的小目标完成后我们的目的也就是实现了。本质上大型项目的构建与此类似。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/6748ea9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6748ea9.html" class="post-title-link" itemprop="url">搞懂链接器 3：重定位</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-29 21:31:26" itemprop="dateCreated datePublished" datetime="2021-07-29T21:31:26+08:00">2021-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-09 17:06:16" itemprop="dateModified" datetime="2023-01-09T17:06:16+08:00">2023-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">编译器</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="搞懂链接器 3：重定位" href="/posts/6748ea9.html#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::3115e1efab20c61eb1493d297b38f499" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序的运行过程就是 CPU 不断的从内存中取出指令然后执行执行的过程，对于函数调用来说比如我们在 C/C++ 语言中调用简单的加法函数 add，其对应的汇编指令可能是这样的:</p>
<blockquote>
<p> <em>call 0x4004fd</em></p>
</blockquote>
<p>其中 0x4004fd 即为函数 add 在内存中的地址，当 CPU 执行这条语句的时候就会跳转到 0x4004fd 这个位置开始执行函数 add 对应的机器指令。</p>
<p>再比如我们在 C 语言中对一个全局变量 g_num 不断加一来进行计数，其对应的汇编指令可能是这样的：</p>
<blockquote>
<p> <em>mov 0x400fda %eax</em></p>
<p> <em>add $0x1 %eax</em></p>
</blockquote>
<p>这里的意思是把内存中 0x400fda 这个地址的数据放到寄存器当中，然后将寄存器中的数据加一，在这里 g_num 这个全局变量的内存地址就是 0x400fda。</p>
<p>好奇的同学可能会问，那这些函数以及数据的内存地址是怎么来的呢？</p>
<p>确定程序运行时的内存地址就是接下来我们要讲解的重点内容，这里先给出答案，可执行文件中代码以及数据的运行时内存地址是链接器指定的，也就是上面示例中 add 的内存地址 0x4004fd 其是链接器指定的。确定程序运行时地址的过程就是这里重定位 (Relocation)。</p>
<p>为什么这个过程叫做重定位呢，之所以叫做重定位是因为确定可执行文件中代码和数据的运行时地址是分为两个阶段的，在第一个阶段中无法确定这些地址，只有在第二个阶段才可以确定，因此就叫做重定位。接下来让我们来看看这两个阶段，合并同类型段以及引用符号的重定位。</p>
<p>编译器的工作</p>
<p>让我们回忆一下前几节的内容，源文件首先被编译器编译生成目标文件，目标文件种有三段内容：数据段、代码段以及符号表，所有的函数定义被放在了代码段，全局变量的定义放在了数据段，对外部变量的引用放到了符号表。</p>
<p>编译器在将源文件编译生成目标文件时可以确定一下两件事：</p>
<ul>
<li>定义在该源文件中函数的内存地址</li>
<li>定义在该源文件中全局变量的内存地址</li>
</ul>
<p>注意这里的内存地址其实只是相对地址，相对于谁的呢，相对于自己的。为什么只是一个相对地址呢？因为在生成一个目标文件时编译器并不知道这个目标文件要和哪些目标文件进行链接生成最后的可执行文件，而链接器是知道要链接哪些目标文件的。因此编译器仅仅生成一个相对地址。</p>
<p>而对于引用类的变量，也就是在当前代码中引用而定义是在其它源文件中的变量，对于这样的变量编译器是无法确定其内存地址的，这不是编译器需要关心的，确定引用类变量的内存地址是链接器的任务，链接器在进行链接时能够确定这类变量的内存地址。因此当编译器在遇到这样的变量时，比如使用了外部定义的函数时，其在目标文件中对应的机器指令可能是这样的:</p>
<blockquote>
<p><em>call 0x000000</em></p>
</blockquote>
<p>也就是说对于编译器不能确定的地址都这设置为空 (0x000000)，同时编译器还会生成一条记录，该记录告诉链接器在进行链接时要修正这条指令中函数的内存地址，这个记录就放在了目标文件的.rel.text 段中。相应的如果是对外部定义的全局变量的使用，则该记录放在了目标文件的.rel.data 段中。即链接器需要在链接过程中根据.rel.data 以及.rel.text 来填好编译器留下的空白位置</p>
<p>(0x000000)。因此在这里我们进一步丰富目标文件中的内容，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101533.png" alt="image-20210730101533085"></p>
<p>生成目标文件后，编译器完成任务，编译器确定了定义在该源文件中函数以及全局变量的相对地址。对于编译器不能确定的引用类变量，编译器在目标文件的.rel.text 以及.rel.data 段中生成相应的记录告诉链接器要修正这些变量的地址。</p>
<p>接下来就是链接器的工作了。</p>
<p>链接器的工作</p>
<p>我们在静态库下可执行文件的生成一节中知道，链接器会将所有的目标文件进行合并，所有目标文件的数据段合并到可执行文件的数据段，所有目标文件的代码段合并到可执行文件的代码段。当所有合并完成后，各个目标文件中的相对地址也就确定了。因此在这个阶段，链接器需要修正目标文件中的相对地址。</p>
<p>在这里我们以合并目标文件中的数据段为例来说明链接器是如何修正目标文件的相对地址的，合并代码段时修正相对位置的原理是一样的。</p>
<p>我们假设链接器需要链接三个目标文件：</p>
<ul>
<li>目标文件一：该文件数据段定义了两个变量 apple 和 banana，apple 的长度为 2 字节，banana 的长度 4 字节，因此目标文件一的数据段长度为 6 字节。从图中也可以看出 apple 的内存地址为 0，也就是相对地址，即 apple 这个变量在目标文件一的地址是 0，banana 的地址为 2。</li>
<li>目标文件二：该文件的数据段比较简单，只定义了一个变量 orange，其长度为 2，因此该目标文件的数据段长度为 2。</li>
<li>目标文件三：该文件的数据段定义了三个变量 grape、mango 以及 limo，其长度分别为 4 字节、2 字节以及 2 字节，因此该目标文件的数据段长度为 8 字节。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101619.png" alt="image-20210730101619806"></p>
<p>链接器在链接三个目标文件时其顺序是依次链接的，链接完成后：</p>
<ul>
<li>目标文件一：该数据段的起始地址为 0，因此该数据段中的变量的最终地址不变。</li>
<li>目标文件二：由于目标文件一的数据段长度为 6，因此链接完成后该数据段的起始地址为 6 (这里的起始地址其实就是偏移 offset)，相应的 orange 的最终内存地址为 0+offset 即 6。</li>
<li>目标文件三：由于前两个数据段的长度为 8，因此该数据段的起始地址为 8 (即 offset 为 8)，因此所有该数据段中的变量其地址都要加上该 offset，即 grape 的最终地址为 8，即 0+offset，mango 的最终地址为 4+offset 即 12，limo 的最终地址为 6+offset 即 14。</li>
</ul>
<p>从这个过程中可以看到，数据段中的相对地址是通过这个公式来修正的，即：</p>
<blockquote>
<p>相对地址 + offset (偏移) = 最终内存地址</p>
</blockquote>
<p>而每个段的偏移只有在链接完成后才能确定，因此对相对地址的修正只能由链接器来完成，编译器无法完成这项任务。</p>
<p>当所有目标文件的同类型段合并完毕后，数据段和代码段中的相对地址都被链接器修正为最终的内存位置，这样所有的变量以及函数都确定了其各自位置。</p>
<p>至此，重定位的第一阶段完成。接下来是重定位的第二阶段，即引用符号的重定位。</p>
<p>相对地址是编译器在编译过程中确定了，在链接器完成后被链接器修正为最终地址，而对于编译器没有确定的所引用的外部函数以及变量的地址，编译器将其记录在了.rel.text 和.rel.data 中。</p>
<p>由于在第一阶段中，所有函数以及数据都有了最终地址，因此重定位的第二阶段就相对简单了。我们知道编译器引用外部变量时将机器指令中的引用地址设置为空 (比如 call 0x000000)，并将该信息记录在了目标文件的.rel.text 以及.rel.data 段中。因此在这个阶段链接器依次扫描所有的.rel.text 以及.rel.data 段并找到相应变量的最终地址 (这些位置都已在第一阶段确定)，并将机器指令中的 0x000000 修正为所引用变量的最终地址就可以了。</p>
<p>到这里链接器的重定位就讲解的这里，作为程序员一般很少会有问题出现在重定位阶段，因此这个阶段对程序员相对透明。请同学们注意一点，这里的分析仅限于目标文件的静态链接。我们知道静态链接下，链接器会将需要的代码和数据都合并到可执行文件当中，因此需要确定代码和数据的最终位置。而对于动态链接库来说情况则有所不同，动态链接库可以同时被多个进程使用，如果动态链接库的机器指令中不可以存在引用变量的最终位置，否则在被多个进程使用时会出现一个进程中使用的数据被其它进程修改。因此动态库下的机器指令都是 PIC 代码，即位置无关代码 (Position-Independent Code)。关于 PIC 的机制原理就不在这里阐述了，对此感兴趣的同学可以关注微信公众号，码农的荒岛求生，我会在那里来讲解。</p>
<p>问题：为什么链接器能确定运行时地址</p>
<p>我们知道只有把可执行文件加载到内存当中程序才可以开始运行。不同的程序会被加载到内存的不同位置。我们从前两节的过程中可以看出，链接器完全没有考虑不同的程序会被加载不同的内存位置被执行。比如对于一个可执行文件我们分别运行两次，如下图所示，因为两个程序数据段变量的地址是一样的，那么程序一的数据会不会被程序二修改呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101648.png" alt="image-20210730101648724"></p>
<p>如果你去试一试的话就会发现显然不会有这种问题的。而当可执行文件加载到内存的时候也不会根据程序加载的起始地址再去修改可执行文件中变量的地址 (这样就启动速度就太慢了)，那么操作系统又是如何能做到基于同一个可执行文件的两个程序能在各自的内存空间中运行而不相互干扰呢，链接器在可执行文件中确定的到底是不是程序最终的运行地址呢，我会在后面的文章当中给出答案，欢迎同学们关注微信公共账号码农的荒岛求生获取更多内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://liu-paopao.github.io/posts/7173be3f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="paopao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PaoPao's Blog">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PaoPao's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7173be3f.html" class="post-title-link" itemprop="url">搞懂链接器 2：库与可执行文件的生成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-29 21:31:12" itemprop="dateCreated datePublished" datetime="2021-07-29T21:31:12+08:00">2021-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-09 17:06:12" itemprop="dateModified" datetime="2023-01-09T17:06:12+08:00">2023-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">编译器</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="搞懂链接器 2：库与可执行文件的生成" href="/posts/7173be3f.html#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::6244018f66c957e5d37dcf615fadcca2" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>链接器可以操作的最小单元为目标文件，也就是说无论是静态库、动态库、可执行文件，都是基于目标文件构建出来的。目标文件就好比乐高积木中最小的零部件。</p>
<p>给定目标文件以及链接选项，链接器可以生成两种库，分别是静态库以及动态库，如图所示，给定同样的目标文件，链接器可以生成两种不同类型的库，接下来我们分别介绍。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730085852.png" alt="库生成示意图"></p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>假设这样一个应用场景，基础设计团队设计了好多实用并且功能强大的工具函数，业务团队需要用到里面的各种函数。每次新添加其中一个函数，业务团队都要去找相应的实现文件并修改链接选项。使用静态库就可以解决这个问题。静态库在 Windows 下是以.lib 为后缀的文件，Linux 下是以.a 为后缀的文件。</p>
<p>为解决上述问题，基础设计团队可以提前将工具函数集合打包编译链接成为静态库提供给业务团队使用，业务团队在使用时只要链接该静态库就可以了，每次新使用一个工具函数的时候，只要该函数在此静态库中就无需进行任何修改。</p>
<p>你可以简单的将静态库理解为由一堆目标文件打包而成， 使用者只需要使用其中的函数而无需关注该函数来自哪个目标文件（找到函数实现所在的目标文件是链接器来完成的，从这里也可以看出，不是所有静态库中的目标文件都会用到，而是用到哪个链接器就链接哪个）。静态库极大方便了对其它团队所写代码的使用。</p>
<h2 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态库是链接器通过静态链接将其和其它目标文件合并生成可执行文件的，如下图一所示，而静态库只不过是将多个目标文件进行了打包，在链接时只取静态库中所用到的目标文件，因此，你可以将静态链接想象成如下图 2 所示的过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090423.png" alt="image-20210730090423254"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090432.png" alt="image-20210730090431921"></p>
<p>静态库是使用库的最简单的方法，如果你想使用别人的代码，找到这些代码的静态库并简单的和你的程序链接就可以了。静态链接生成的可执行文件在运行时不依赖任何其它代码，要理解这句话，我们需要知道静态链接下，可执行文件是如何生成的。</p>
<h2 id="静态链接下可执行文件的生成"><a href="#静态链接下可执行文件的生成" class="headerlink" title="静态链接下可执行文件的生成"></a>静态链接下可执行文件的生成</h2><p>在上一节中我们知道，可以将静态链接简单的理解为链接器将使用到的目标文件集合进行拼装，拼装之后就生成了可执行文件，同时我们在目标文件里有什么这一节中知道，目标文件分成了三段，代码段，数据段，符号表，那么在静态链接下可执行文件的生成过程如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090553.png" alt="image-20210730090553480"></p>
<p>从上图中我们可以看到可执行文件的特点：</p>
<ul>
<li>可执行文件和目标文件一样，也是由代码段和数据段组成。</li>
<li>每个目标文件中的数据段都合并到了可执行文件的数据段，每个目标文件当中的代码段都合并到了可执行文件的代码段。</li>
<li>目标文件当中的符号表并没有合并到可执行文件当中，因为可执行文件不需要这些字段。</li>
</ul>
<p>可执行文件和目标文件没有什么本质的不同，可执行文件区别于目标文件的地方在于，可执行文件有一个入口函数，这个函数也就是我们在 C 语言当中定义的 main 函数，main 函数在执行过程中会用到所有可执行文件当中的代码和数据。而这个 main 函数是被谁调用执行的呢，答案就是操作系统 (Operating System)，这也是后面文章当中要重点介绍的内容。</p>
<p>现在你应该对可执行文件有一个比较形象的认知了吧。你可以把可执行文件生成的过程想象成装订一本书，一本书中通常有好多章节，这些章节是你自己写的，且一本书不可避免的要引用其它著作。静态链接这个过程就好比不但要装订你自己写的文章，而且也把你引用的其它人的著作也直接装订进了你的书里，这里不考虑版权问题 :)，这些工作完成后，只需要按一下订书器，一本书就制作完成啦。</p>
<p>在这个比喻中，你写的各个章节就好比你写的代码，引用的其它人的著作就好比使用其它人的静态库，装订成一本书就好比可执行文件的生成。</p>
<p>静态链接是使用库的最简单最直观的形式， 从静态链接生成可执行文件的过程中可以看到，静态链接会将用到的目标文件直接合并到可执行文件当中，想象一下，如果有这样的一种静态库，几乎所有的程序都要使用到，也就是说，生成的所有可执行文件当中都有一份一模一样的代码和数据，这将是对硬盘和内存的极大浪费，假设一个静态库为 2M，那么 500 个可执行文件就有 1G 的数据是重复的。如何解决这个问题呢，答案就是使用动态库。</p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>在前三小节中我们了解了静态库、静态链接以及使用静态链接下可执行文件是如何生成的。接下来我们讲解一下动态库，那么什么是动态库？</p>
<p><code>动态库(Dynamic Library)</code>，又叫<code>共享库(Shared Library)</code>，动态链接库等，在 Windows 下就是我们常见的大名鼎鼎的 DLL 文件了，Windows 系统下大量使用了动态库。在 Linux 下动态库是以.so 为后缀的文件，同时以 lib 为前缀，比如进行数字计算的动态库 Math，编译链接后产生的动态库就叫做 libMath.so。从名字中我们知道动态库也是库，本质上动态库同样包含我们已经熟悉的代码段、数据段、符号表。只不过动态库的使用方式以及使用时间和静态库不太一样。</p>
<p>在前面几个小节中我们知道，使用静态库时，静态库的代码段和数据段都会直接打包 copy 到可执行文件当中，使用静态库无疑会增大可执行文件的大小，同时如果程序都需要某种类型的静态库，比如 libc，使用静态链接的话，每个可执行文件当中都会有一份同样的 libc 代码和数据的拷贝，如图所示，动态库的出现解决了此类问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090957.png" alt="image-20210730090956928"></p>
<p>动态库允许使用该库的可执行文件仅仅包含对动态库的引用而无需将该库拷贝到可执行文件当中。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息即可，为了方便理解，你可以将可执行文件当中保存的必要信息仅仅理解为需要记录动态库的名字就可以了，如图所示，同静态库相比，动态库的使用减少了可执行文件的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730091106.png" alt="image-20210730091106648"></p>
<p>从上面这张图中可以看出，动态库的使用解决了静态链接当中可执行文件过大的问题。我们在前几节中将静态链接生成可执行文件的过程比作了装订一本书，静态链接将引用的其它人的著作也装订到了书里，而动态链接可以想象成作者仅仅在引用的地方写了一句话，比如引用了《码农的荒岛求生》，那么作者就在引用的地方写上 “此处参考《码农的荒岛求生》”，那么读者在读到这里的时候会自己去找到码农的荒岛求生这本书并查找相应的内容，其实这个过程就是动态链接的基本思想了。</p>
<p>到这里我们就可以回答之前提到过的问题了，helloworld 程序中的 printf 函数到底是在哪里定义的，答案就是该函数是在 libc.so 当中定义的，Linux 下编译链接生成可执行文件时会默认动态链接 libc.so (Windows 下也是同样的道理)，使用 ldd 命令就会发现每个可执行文件都依赖 libc.so。因此虽然你从没有看到过 printf 的定义也可以正确的使用这个函数。</p>
<h2 id="动态链接。"><a href="#动态链接。" class="headerlink" title="动态链接。"></a>动态链接。</h2><p>我们知道静态库在编译链接期间就被打包 copy 到了可执行文件，也就是说静态库其实是在编译期间 (Compile time) 链接使用的，那么动态库又是在什么时候才链接使用的呢，动态链接可以在两种情况下被链接使用，分别是 load-time dynamic linking (加载时动态链接) 以及 run-time dynamic linking (运行时动态链接)，接下来我们分别讲解一下。</p>
<ul>
<li>load-time dynamic linking (加载时动态链接)</li>
</ul>
<p>首先可能有的同学会问，什么是 load-time 呢，load_time 翻译过来也就是加载时，那么什么又是加载呢？</p>
<p>我们大家都玩过游戏，当我们打开游戏的时候经常会跳出来一句话：“加载中，请稍后。。。” 和这里的加载意思差不多。这里的加载指的是程序的加载，而所谓程序的加载就是把可执行文件从磁盘搬到内存的过程，因为程序最终都是在内存中被执行的。至于这个过程的详解内容我会在接下来的文章《加载器与可执行文件》一文中给大家详细讲解。在这里我们只需要简单的把加载理解为程序从磁盘复制到内存的过程，加载时动态链接就出现在这个过程。</p>
<p>当把可执行文件复制到内存后，且在程序开始运行之前，操作系统会查找可执行文件依赖的动态库信息 (主要是动态库的名字以及存放路径)，找到该动态库后就将该动态库从磁盘搬到内存，并进行符号决议，如果这个过程没有问题，那么一切准备工作就绪，程序就可以开始执行了，如果找不到相应的动态库或者符号决议失败，那么会有相应的错误信息报告为用户，程序运行失败。比如 Windows 下比较常见的启动错误问题，就是因为没有找到依赖的动态库。Linux 下同样会有类似信息提示用户程序启动失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101021.png" alt="image-20210730101021256"></p>
<p>到这里，同学们应该对加载时动态链接应该有一个比较清晰的了解了。从总体上看，加载时动态链接可以分为两个阶段：阶段一，将动态库信息写入可执行文件；阶段二，加载可执行文件时依据动态库信息进行动态链接。</p>
<p><em>阶段一，将动态库信息写入可执行文件</em></p>
<p>在编译链接生成可执行文件时，需要将使用的动态库加入到链接选项当中，比如在 Linux 下引用 libMath.so，就需要将 libMath.so 加入到链接选项当中（比如 libMath.so 放到了 /usr/lib 下，那么使用命令 gcc … -lMath -L/user/lib … 进行编译链接），所以使用这种方式生成的可执行文件中保存了依赖的动态库信息，在 Linux 可使用一个简单的命令 ldd 来查看。</p>
<p><em>阶段二：加载可执行文件时依据动态库信息进行动态链接</em></p>
<p>由于在阶段一生成的可执行文件中保存了动态库信息，当可执行文件加载完成后，就可以依据此信息进行中动态库的查找以及符号决议了。</p>
<p>通过这个过程也可以清楚的看到静态库和动态库的区别，使用动态库的可执行文件当中仅仅保留相应信息，动态库的链接过程被推迟到了程序启动加载时。</p>
<p>为加深你对加载时动态链接这个过程的理解，我们用一个类比来结束本小节，沿用前几节读书的例子，我们正在读的书中引用了《码农的荒岛求生》以及其它著作，那么加载时动态链接就好比，读者开始准备读这本书的时候（还没有真正的读）就把所有该书当中引用的资料著作都找齐放到一旁准备查看，当我们真正看到引用其它文献的地方时就可以直接在一旁找到该著作啦。在这个类比当中，开始读书前的准备工作就好比加载时动态链接。</p>
<p>接下来我们讲解第二种动态链接，run-time dynamic linking (运行时动态链接) 。</p>
<ul>
<li>run-time dynamic linking (运行时动态链接)</li>
</ul>
<p>上一小节中我们看到如果我们想使用加载时动态链接，那么在编译链接生成可执行文件阶段时需要告诉编译器所依赖的动态库信息，而 run-time dynamic linking 运行时动态链接则不需要在编译链接时提供动态库信息，也就是说，在可执行文件被启动运行之前，可执行文件对所依赖的动态库信息一无所知，只有当程序运行到需要调用动态库所提供的代码时才会启动动态链接过程。</p>
<p>我们在上一节中介绍了 load-time，也就是程序加载时，那么程序加载完成后就开始程序执行了，那么所谓 run-time (运行时) 指的就是从程序开始被 CPU 执行到程序执行完成退出的这段时间。</p>
<p>所以运行时动态链接这种方式对于 “动态链接” 阐释的更加淋漓尽致，因为可执行文件在启动运行之前都不知道需要依赖哪些动态库，只在运行时根据代码的需要再进行动态链接。同加载时动态链接相比，运行时动态链接将链接这个过程再次推迟往后推迟，推迟到了程序运行时。</p>
<p>由于在编译链接生成可执行文件的过程中没有提供所依赖的动态库信息，因此这项任务就留给了程序员，在代码当中如果需要使用某个动态库所提供的函数，我们可以使用特定的 API 来运行时加载动态库，在 Windows 下通过 LoadLibrary 或者 LoadLibraryEx，在 Linux 下通过使用 dlopen、dlsym、dlclose 这样一组函数在运行时链接动态库。当这些 API 被调用后，同样是首先去找这些动态库，将其从磁盘 copy 到内存，然后查找程序依赖的函数是否在动态库中定义。这些过程完成后动态库中的代码就可以被正常使用了。</p>
<p>相对于加载时动态链接，运行时动态链接更加灵活，同时将动态链接过程推迟到运行时可以加快程序的启动速度。</p>
<p>为了和加载时动态链接作比对，我们继续使用上一小节当中读书的例子，加载时动态链接就好比在开始准备读一本书之前，将该书中所有引用到的资料文献找齐全，而运行时动态链接则不需要这个过程，运行时动态链接就好比直接拿起一本书开始看，看到有引用的参考文献时再去找该资料，找到后查看该文献然后继续读我们的书。从这个例子当中运行时动态链接更像是我们平时读书时的样子。</p>
<p>至此，两种动态链接的形式我们就都已经清楚了，接下来我们看一下动态链接下生成的可执行文件。</p>
<p>动态链接下可执行文件的生成</p>
<p>在静态链接下，链接器通过将各个目标文件的代码段和数据段合并拷贝到可执行文件，因此静态链接下可执行文件当中包含了所依赖的所有代码和数据，而与之对比的动态链接下可执行文件又是什么样的呢？</p>
<p>其实我们在动态库这一节中已经了解了动态链接下可执行文件的生成，即，在动态链接下，链接器并不是将动态库中的代码和数据拷贝到可执行文件中，而是将动态库的必要信息写入了可执行文件，这样当可执行文件在加载时就可以根据此信息进行动态链接了。为方便理解，我们将该信息仅仅认为是动态库都名字，真实情况当然要更复杂一点，这里我们以 Linux 下可执行文件即 ELF 文件为例（这一系列的文章重点关注最本质的原理思想，所以这里讨论的同样适合 Windows 下的可执行文件即 exe 文件）。</p>
<p>在前几节中我们将可执行文件简单的划分为了两段，数据段和代码段，在这里我们继续丰富可执行文件中的内容，如图所示，在动态链接下，可执行文件当中会新增两段，即 dynamic 段以及 GOT（Global offset table）段，这两段内容就是是我们之前所说的必要信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101148.png" alt="image-20210730101148719"></p>
<p>dynamic 段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息。关于 dynamic 以及 GOT 段的作用限于篇幅就不重点阐述了。如果你对 GOT 段的具体作用很好奇的话，欢迎关注微信公共账号，码农的荒岛求生。</p>
<p>当加载可执行文件时，操作系统根据 dynamic 段中的信息即可找到使用的动态库，从而完成动态链接。</p>
<p>这里需要强调一点，在编译链接过程中，可以同时使用动态库以及静态库。这两种库的使用并不冲突，那么在这种情况下生成的可执行文件中，可执行文件中包含了静态库的数据和代码，以及动态库的必要信息。</p>
<p>至此，关于静态库，静态链接，动态库，动态链接就讲述到这，那么接下来的问题就是静态库和动态库都有什么样的优缺点。</p>
<h2 id="动态库vs静态库"><a href="#动态库vs静态库" class="headerlink" title="动态库vs静态库"></a>动态库 vs 静态库</h2><p>在计算机的历史当中，最开始程序只能静态链接，但是人们很快发现，静态链接生成的可执行文件存在磁盘空间浪费问题，因为对于每个程序都需要依赖的 libc 库，在静态链接下每个可执行文件当中都有一份 libc 代码和数据的拷贝，为解决该问题才提出动态库。</p>
<p>在前几节我们知道，动态链接下可执行文件当中仅仅保留动态库的必要信息，因此解决了静态链接下磁盘浪费问题。动态库的强大之处不仅仅于此，我们知道对于现代计算机系统，比如 PC，通常会运行成百上千个程序（进程），且程序只有被加载到内存中才可以使用，如果使用静态链接那么在内存中就会有成百上千份同样的 libc 代码，这对于宝贵的内存资源同样是极大的浪费，而使用动态链接，内存中只需要有一份 libc 代码，所有的程序（进程）共享这一份代码，因此极大的节省了内存资源，这也是为什么动态库又叫共享库。</p>
<p>动态库还有另外一个强大之处，那就是如果我们修改了动态库的代码，我们只需要重新编译动态库就可以了而无需重新新编译我们自己的程序，因为可执行文件当中仅仅保留了动态库的必要信息，重新编译动态库后这些必要都信息是不会改变的（只要不修改动态库的名字和动态库导出的供可执行文件使用的函数），编译好新的动态库后只需要简单的替换原有动态库，下一次运行程序时就可以使用新的动态库了，因此动态库的这种特性极大的方便了程序升级和 bug 修复。我们平时使用都客户端程序，比如我们常用 QQ，输入法，播放器，都利用了动态库的这一优点，原因就在于方便升级以 bug 修复，只需要更新相应的动态库就可以了。</p>
<p>动态库的优点不止于此，我们知道动态链接可以出现在运行时（run-time dynamic link），动态链接的这种特性可以用于扩展程序能力，那么如何扩展呢？你肯定听说过一样神器，没错，就是插件。你有没有想过插件是怎么实现的？实现插件时，我们只需要实现几个规定好的几个函数，我们的插件就可以运行了，可这是怎么做到的呢，答案就在于运行时动态链接，可以将插件以动态的都方式实现。我们知道使用运行时动态链接无需在编译链接期间告诉链接器所使用的动态库信息，可执行文件对此一无所知，只有当运行时才知道使用什么动态库，以及使用了动态库中哪些函数，但是在编译链接可执行文件时又怎么知道插件中定义了哪些函数呢，因此所有的插件实现函数必须都有一个统一的格式，程序在运行时需要加载所有插件（动态库），然后调用所有插件的入口函数（统一的格式），这样我们写的插件就可以被执行起来了。</p>
<p>动态库都强大优势还体现在多语言编程上。我们知道使用 Python 可以快速进行开发，但 Python 的性能无法同 C/C++ 相比 (因为 Python 是解释型语言，至于什么是解释型语言我会在后面码农的荒岛求生系列文章当中给大家详细讲解)，有没有办法可以兼具 Python 的快速开发能力以及 C/C++ 的高性能呢，答案是可以的，我们可以将 C/C++ 代码编译链接成动态库，这样 python 就可以直接调用动态库中的函数了。不但 Python，Perl 以及 Java 等都可以通过动态库的形式调用 C/C++ 代码。动态库的使用使得同一个项目不同语言混合编程成为可能，而且动态库的使用更大限度的实现了代码复用。</p>
<p>了解了动态库的这么多优点，那么动态库就没有缺点吗，当然是有的。</p>
<p>首先由于动态库是程序加载时或运行是才进行链接的，因此同静态链接相比，使用动态链接的程序在性能上要稍弱于静态链接，这时因为对于加载时动态链接，这无疑会减慢程序都启动速度，而对于运行时链接，当首次调用到动态库的函数时，程序会被暂停，当链接过程结束后才可以继续进行。且动态库中的代码是地址无关代码（Position-Idependent Code，PIC），之所以动态库中的代码是地址无关代码是因为动态库又被成为共享库，所有的程序都可以调用动态库中的代码，因此在使用动态库中的代码时程序要多做一些工作，这里我们不再具体展开讲解到底程序多做了哪些工作，对此感兴趣当同学可以参考 CSAPP（深入理解计算机系统）。这里我们说动态链接的程序性能相比静态链接稍弱，但是这里的性能损失是微乎其微的，同动态库可以带来的好处相比，我们可以完全忽略这里的性能损失，同学们可以放心的使用动态库。</p>
<p>动态库的一个优点其实也是它的缺点，即动态链接下的可执行文件不可以被独立运行（这里讨论的是加载时动态链接，load-time dynamic link），换句话说就是，如果没有提供所依赖的动态库或者所提供的动态库版本和可执行文件所依赖的不兼容，程序是无法启动的。动态库的依赖问题会给程序的安装部署带来麻烦，在 Linux 环境下尤其严重，以笔者曾参与开发维护的一个虚拟桌面系统为例，我们在开发过程中依赖的一些比较有名的第三方库默认不会随着安装包发布，这就会导致用户在较低版本 Linux 中安装时经常会出现程序无法启动的问题，原因就在于我们编译链接使用都动态库和用户 Linux 系统中都动态库不兼容。解决这个问题的方法通常有两种，一个是用户升级系统中都动态库，另一个是我们讲需要都第三方库随安装包一起发布，当然这是在取得许可的情况下。</p>
<p>在了解了动态库的优缺点后，接下来我们来看一下静态库。</p>
<p>静态链接是最古老也是最简单的链接技术。静态链接都最大优点就是使用简单，编译好的可执行文件是完备的，即静态链接下的可执行文件不需要依赖任何其它的库，因为静态链接下，链接器将所有依赖的代码和数据都写入到了最终的可执行文件当中，这就消除了动态链接下的库依赖问题，没有了库都依赖问题就意味着程序都安装部署都得到了极大都简化。请大家不要小看这一点，这对当今那些拥有海量用户的后端系统来说至关重要，比如类似微信这种量级的系统，其后端会部署在成千上万台机器上，这么多的机器其系统的安装部署以及升级会给运维带来极大挑战，而静态链接下的可执行文件由于不依赖任何库，因为部署非常方便，仅仅用一个新的可执行文件进行覆盖就可以了，因此极大的简化了系统部署以及升级。笔者之前所在的某电商广告后端系统就完全使用静态链接来简化部署升级。</p>
<p>而静态库的缺点相信大家都已经清楚了，那就是静态链接会导致可执行文件过大，且多个程序静态链接同一个静态库的话会导致磁盘浪费的问题。</p>
<p>到这里关于静态库和动态库的讨论就告一段落了，相信大家对于这两种链接类型都有了清晰都认知。接下来让我们稍作休息，开始链接器的下一个重要功能，重定位。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heartbeat"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">paopao</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.umd.js" integrity="sha256-q8XkJ6dj5VwSvzI8+nATCHHQG+Xv/dAZBCgqmu93zOY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyw09gPog","appkey":"4488e6b82bfe3d819f4971a5e5c115f4","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
